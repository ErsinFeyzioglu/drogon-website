# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, an-tao
# This file is distributed under the same license as the drogon package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: drogon \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-19 19:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/Controller-HttpController-zh.rstd:3
msgid "HttpController 控制器"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:7
msgid "生成"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:9
msgid "可以由drogon_ctl命令行工具快速生成基于HttpController的自定义类的源文件，命令格式如下："
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:15
msgid "我们创建一个位于demo v1名称空间内且名称为User的控制器："
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:21
msgid "可以看到，目录下新增加了两个文件，demo_v1_User.h和demo_v1_User.cc:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:23
#: ../../source/Controller-HttpController-zh.rstd:59
msgid "*demo_v1_User.h*"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:44
msgid "demo_v1_User.cc is as follows:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:46
#: ../../source/Controller-HttpController-zh.rstd:91
msgid "*demo_v1_User.cc*"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:55
msgid "使用"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:57
msgid "我们编辑一下这两个文件，然后再阐述它们。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:130
msgid "每个*HttpController*类可以定义多个Http请求处理函数(handler)，由于函数数目可以任意多，所以通过虚函数重载是不现实的，我们需要把处理函数本身(而不是类)注册到框架里去。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:132
msgid "从URL路径到处理函数的映射由宏完成，可以用*METHOD_ADD*宏或*ADD_METHOD_TO*宏添加多重路径映射，所有*METHOD_ADD*和*ADD_METHOD_TO*语句应夹在*METHOD_LIST_BEGIN*和*METHOD_LIST_END*宏语句之间。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:134
msgid "*METHOD_ADD*宏会在路径映射中自动把**名字空间和类名**作为路径的前缀，所以，本例子中，login函数，被注册到了*/demo/v1/user/token*路径上，getInfo函数被注册到了*/demo/v1/user/xxx/info*路径上。后面的约束跟HttpSimpleController的PATH_ADD宏类似，不再赘述。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:136
msgid "如果使用了自动的前缀，访问地址要包含命名空间和类名，此例中要使用*http://localhost/demo/v1/user/token?userid=xxx&passwd=xxx*或者*http://localhost/demo/v1/user/xxxxx/info?token=xxxx*来访问。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:138
msgid "*ADD_METHOD_TO*宏的作用与前者几乎一样，除了它不会自动添加任何前缀，即这个宏注册的路径是一个绝对路径。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:140
msgid "我们看到，*HttpController*提供了更为灵活的路径映射功能，并且可以注册多个处理函数，我们可以把一类功能放在一个类里。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:142
msgid "另外可以看到，*METHOD_ADD*宏提供了参数映射的方法，我们可以把路径上的参数映射到函数的参数表里，由参数的数码对应形参的位置，非常方便，常见的可以由字符串类型转换的类型都可以作为参数(如std::string,int,float,double等等)，框架基于模板的类型推断会自动帮你转换类型，非常方便。注意左值引用必须是const类型。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:144
msgid "同一个路径还可以注册多次，相互之间通过Http Method区分，这是合法的，并且是Restful API的通常做法，比如:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:154
msgid "路径参数的占位符有多种写法:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:156
msgid "{}: 表示这个路径参数映射到处理函数的对应位置上，路径上的位置就是函数参数的位置。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:157
msgid "{1},{2}: 中间有个数字的，表示映射到数字指定的处理函数参数上。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:158
msgid "{anystring}: 中间的字符串没有实际作用，但可以提高程序的可读性，与{}等价。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:159
msgid "{1:anystring},{2:xxx}: 冒号前的数字表示位置，后面的字符串没有实际作用，但可以提高程序的可读性，与{1},{2}等价"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:161
msgid "推荐使用后两种写法，如果路径参数和函数参数顺序一直，使用第三种写法即可。容易知道，以下几种写法是等价的："
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:163
msgid "\"/users/{}/books/{}\""
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:164
msgid "\"/users/{}/books/{2}\""
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:165
msgid "\"/users/{user_id}/books/{book_id}\""
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:166
msgid "\"/users/{1:user_id}/books/{2}\""
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:169
msgid "注意：路径匹配大小写不敏感，参数名字大小写敏感，参数值大小写保持原貌"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:173
msgid "参数映射"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:175
msgid "通过前面的叙述我们知道，路径上的参数和问号后面的请求参数都可以映射到处理函数的参数列表里，目标参数的类型需要满足如下条件："
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:177
msgid "必须是值类型、常左值引用或非const右值引用中的一种，不能是非const的左值引用，推荐使用右值引用，这样用户可以随意处置它；"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:179
msgid "int, long, long long, unsigned long, unsigned long long, float, double, long double等基础类型都可以作为参数类型；"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:181
msgid "std::string类型；"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:183
msgid "任何可以使用*stringstream >>*操作符赋值的类型；"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:185
msgid "*另外，drogon框架还提供了从HttpRequestPtr对象到任意类型的参数的映射机制*，当你的handler参数列表中映射参数的数量多于路径上的参数时，后面多余的参数将由HttpRequestPtr对象转换得到，用户可以定义任意类型的转换，定义这种转换的方式是特化drogon命名空间的fromRequest模板(定义于HttpRequest.h头文件))，比如我们需要做一个创建新用户的RESTful的接口，我们定义用户的结构体如下:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:187
msgid "*myapp_User_drogon.cc*"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:215
msgid "有了上面的定义和模板特化，我们就可以向下面这样定义路径和handler::"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:0
msgid "caption"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:218
msgid "**UserController.cc**"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:220
msgid "class UserController:public drogon::HttpController<UserController> { public:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:224
msgid "METHOD_LIST_BEGIN"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:224
msgid "//use METHOD_ADD to add your custom processing function here; ADD_METHOD_TO(UserController::newUser,\"/users\",Post);"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:226
msgid "METHOD_LIST_END //your declaration of processing function maybe like this: void newUser(const HttpRequestPtr &req,"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:229
msgid "std::function<void (const HttpResponsePtr &)> &&callback, myapp::User &&pNewUser) const;"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:231
msgid "};"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:233
msgid "可以看到，第三个*myapp::User*类型的参数在映射路径上没有对应的占位符，框架会将它视为由*req*对象转换的参数，通过用户特化的函数模板得到这个参数，这都是drogon通过模板推导自动在编译期完成的，为用户的开发提供了极大便利。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:235
msgid "更进一步，有些用户除了他们自定义类型的数据外，并不需要访问HttpRequestPtr对象，那么他可以把这个自定义的对象放在第一个参数的位置，框架也能正确完成映射，比如上面的例子也可以写成下面这样:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:237
msgid "*UserController.cc*"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:254
msgid "多路径映射"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:256
msgid "drogon支持在路径映射中使用正则表达式，在{}花括号以外的部分可以有限制的使用，比如:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:258
msgid "ADD_METHOD_TO(UserController::handler1,\"/users/.*\",Post); /// Match any path prefixed with `/users/` ADD_METHOD_TO(UserController::handler2,\"/{name}/[0-9]+\",Post); ///Match any path composed with a name string and a number."
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:261
msgid "这种方法不支持子表达式，负向匹配等正则表达式，如果想使用他们，请用如下的方案。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:265
msgid "正则表达式"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:267
msgid "上面的方法对正则表达式的支持比较有限，如果用户想自由使用正则表达式，drogon提供了ADD_METHOD_VIA_REGEX宏来实现这一点，比如:"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:275
msgid "可以看到，使用正则表达式也可以完成参数映射，所有子表达式匹配的字符串都会按顺序映射到handler的参数上。"
msgstr ""

#: ../../source/Controller-HttpController-zh.rstd:278
msgid "需要注意的是，使用正则表达式要注意匹配冲突（多个不同的handler都匹配），当冲突发生在同一个controller内部时，drogon只会执行第一个handler（先注册进框架的那个handler），当冲突发生在不同controller之间时，执行哪个handler是不确定的，因此用户需要避免这种冲突发生。"
msgstr ""

