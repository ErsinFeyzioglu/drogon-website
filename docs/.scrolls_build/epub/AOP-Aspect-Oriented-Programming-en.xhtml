<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>AOP Aspect Oriented Programming</title>
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="aop-aspect-oriented-programming">
<h1>AOP Aspect Oriented Programming</h1>
<p>AOP(Aspect Oriented Programming) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns(Quoted from Wikipedia).</p>
<p>Limited to the features of the C++ language, Drogon does not provide a flexible AOP solution like Spring, but a simple AOP in which all join points are predefined in the framework, and by using the framework’s AOP series interfaces, one can register handlers(called ‘advices’ in Drogon) onto specific join points.</p>
<div class="section" id="predefined-joinpoints">
<h2>Predefined joinpoints</h2>
<p>Drogon provides seven joinpoints for users. When the application runs to the joinpoints, the user-registered handlers(Advices) are called one by one. The description of these joinpoints is as follows:</p>
<blockquote>
<div><ul class="simple">
<li><p>Beginning: As the name implies, the joinpoint is at the beginning of the program. Specifically, all handlers registered at this joinpoint are executed immediately after the app().run() method has finished initializaiton. At this joinpoint, all the controllers, filters, plugins, and database clients have been built completely, users can get the desired object reference or perform some other initialization work here. The advice on the joinpoint is only run once, the call signature of the adivice is <em>void()</em>, the registration interface is <em>registerBeginningAdvice</em>;</p></li>
<li><p>NewConnection: Advices registered to this joinpoint are called when each new TCP connection is established. The call signature of the advice is <em>bool(const trantor::InetAddress &amp;, const trantor::InetAddress &amp;)</em>, where the first argument is the remote address of the TCP connection and the second one is the local address. Note that the return type is bool, if the user returns false, the corresponding connection will be disconnected. The registration interface is registerNewConnectionAdvice;</p></li>
<li><p>HttpResponseCreation: Advices registered to this joinpoint are called when each HTTP Response object is created. The call signature of the Advice is <em>void(const HttpResponsePtr &amp;)</em>, where the parameter is the newly created object, and the user can perform some unified operations on all Responses with this joinpoint, such as adding a special header, etc. This joinpoint affects all Responses, including 404 or any drogon internal error response, and also including all responses generated by user’s application. The registration interface is <em>registerHttpResponseCreationAdvice</em>;</p></li>
<li><p>Sync: This joinpoint is located at the front end of Http request processing. Users can intercept this request by returning a non-empty Response object. The call signature of Advices is <em>HttpRequestPtr(const HttpRequestPtr &amp;)</em>. The registration interface is <em>‘registerSyncAdvice’</em>.</p></li>
<li><p>Pre-Routing: Advices registered to this joinpoint are called immediately after the request is created and before it matches any handler paths. Advices for the joinpoint have two call signatures, <em>void(const HttpRequestPtr &amp;,AdviceCallback &amp;&amp;,AdviceChainCallback &amp;&amp;)</em> and <em>void(const HttpRequestPtr &amp;)</em>, the previous one is exactly the same as the call signature of the filter’s <em>doFilter</em> method. In fact, they all run in the same way (please refer to [05-Filter]), users can intercept the client request or let it pass through this joinpoint. The advice with second call signature has no interception capability, but the overhead of it is lower, if the user does not intend to intercept requests, please select this kind of advices. The registration interface is <em>registerPreRoutingAdvice</em>;</p></li>
<li><p>Post-Routing: Advices registered to this joinpoint are called immediately after the request matchs a handler path, The call signatures of Advices are the same as the above joinpoint’s. The registration interface is <em>registerPostRoutingAdvice</em>;</p></li>
<li><p>Pre-Handling: Advices registered to this joinpoint are called immediately after the request is approved by all filters and before it is handled, The call signatures of Advices are the same as the above joinpoint’s. The registration interface is <em>registerPostRoutingAdvice</em>;</p></li>
<li><p>Post-Handling: Advices registered to this joinpoint are called immediately after the request is handled and a response object is created by the handler, The call signature of Advices is <em>void(const HttpRequestPtr &amp;, const HttpResponsePtr &amp;)</em>, The registration interface is <em>registerPostHandlingAdvice</em>;</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aop-schematic">
<h2>AOP schematic</h2>
<p>The following figure shows the location of the above four joinpoints in the HTTP Requests processing flow, where the red dots represent the joinpoints and the green arrows represent the asynchronous calls.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>