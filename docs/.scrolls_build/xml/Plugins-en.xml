<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Plugins-en.rstd">
    <section ids="plugins" names="plugins">
        <title>Plugins</title>
        <paragraph>Plugins are use to help users build complex applications. In Drogon, all plugins are built and installed into the application based on the configuration file. Plugins in Drogon are single-instance, and users can implement any functionality they want with plugins.</paragraph>
        <paragraph>When Drogon runs the run() interface, it instantiates each plugin one by one according to the configuration file and calls the <emphasis>initAndStart()</emphasis> interface of them.</paragraph>
        <section ids="configuration" names="configuration">
            <title>Configuration</title>
            <paragraph>Plugin configuration is done through the configuration file, for example:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"plugins": [
    {
    //name: The class name of the plugin
    "name": "DataDictionary",
    //dependencies: Plugins that the plugin depends on. It can be commented out
    "dependencies": [],
    //config: The configuration of the plugin. This json object is the parameter to initialize the plugin.
    //It can be commented out
    "config": {
    }
    }],</literal_block>
            <paragraph>It can be seen that there are three configurations for each plugin:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>name: is the class name of the plugin (including the namespace). The framework will create a plugin instance based on the class name. If the item is commented out, the plugin becomes disabled.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>dependencies: Is a list of names of other plugins that the plugin depends on. The framework creates and initializes all plugins in a specific order. Prioritize the creation and initialization of plugins that are dependent by others. At the end of the program, plugins are closed and destroyed in reverse order. Please note that circular dependencies in plugins are forbidden. Drogon will report an error and exit the program if it detects a circular dependency. If the item is commented out, the list of dependencies is empty.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>config: is the json object used to initialize the plugin, the object is passed as an input parameter to the plugin’s initAndStart() interface. If the item is commented out, the json object passed to the initAndStart interface is an empty object;</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="definition" names="definition">
            <title>Definition</title>
            <paragraph>User-defined plugins must inherit from the drogon::Plugin class template, and the template parameter is the plugin type, such as the following definition:</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class DataDictionary : public drogon::Plugin&lt;DataDictionary&gt;
{
public:
    virtual void initAndStart(const Json::Value &amp;config) override;
    virtual void shutdown() override;
    ...
};</literal_block>
            <paragraph>One can create source files of plugin by drogon_ctl command:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create plugin &lt;[namespace::]class_name&gt;</literal_block>
        </section>
        <section ids="getting-instance" names="getting\ instance">
            <title>Getting Instance</title>
            <paragraph>The plugin instance is created by drogon, and the user can get the plugin instance through the following interface of drogon:</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">template &lt;typename T&gt; T *getPlugin();</literal_block>
            <paragraph>Or</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PluginBase *getPlugin(const std::string &amp;name);</literal_block>
            <paragraph>Obviously, the first method is more convenient. For example, the DataDictionary plugin mentioned above can be obtained like this:</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">auto *pluginPtr=app().getPlugin&lt;DataDictionary&gt;();</literal_block>
            <paragraph>Note that it is best to get the plugin after calling the framework’s run() interface, otherwise one will get an uninitialized plugin instance (this doesn’t necessarily lead to an error, it is ok to just make sure to use the plugin after initialization). Of course, since the plugin is initialized in a dependency order, it is no problem to get the instance of another plugin in the <emphasis>initAndStart()</emphasis> interface.</paragraph>
        </section>
        <section ids="life-cycle" names="life\ cycle">
            <title>Life Cycle</title>
            <paragraph>All plugins are initialized in the run() interface of the framework and are destroyed when the application exits. Therefore, the plugin’s lifecycle is almost identical to the application, which is why the getPlugin() interface does not need to return a smart pointer.</paragraph>
        </section>
    </section>
</document>
