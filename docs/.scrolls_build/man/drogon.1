.\" Man page generated from reStructuredText.
.
.TH "DROGON" "1" "Sep 19, 2020" "" "drogon"
.SH NAME
drogon \- drogon Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH ENGLISH DOCUMENTATION
.SS Welcome to drogon’s documentation!
.SS Overview
.sp
\fIDrogon\fP is a C++14/17\-based HTTP application framework. Drogon can be used to easily build various types of web application server programs using C++.
.sp
\fIDrogon\fP is the name of a dragon in the American TV series “Game of Thrones” that I really like.
.sp
Drogon’s main application platform is Linux. It also supports Mac OS, FreeBSD and Windows.
.sp
Its main features are as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Use a non\-blocking I/O network lib based on epoll (kqueue under macOS/FreeBSD) to provide high\-concurrency, high\-performance network IO, please visit the \fI\%TFB Tests Results\fP  for more details;
.IP \(bu 2
Provide a completely asynchronous programming mode;
.IP \(bu 2
Support Http1.0/1.1 (server side and client side);
.IP \(bu 2
Based on template, a simple reflection mechanism is implemented to completely decouple the main program framework, controllers and views.
.IP \(bu 2
Support cookies and built\-in sessions;
.IP \(bu 2
Support back\-end rendering, the controller generates the data to the view to generate the Html page. Views are described by CSP template files, C++ codes are embedded into Html pages through CSP tags. And the drogon command\-line tool automatically generates the C++ code files for compilation;
.IP \(bu 2
Support view page dynamic loading (dynamic compilation and loading at runtime);
.IP \(bu 2
Provide a convenient and flexible routing solution from the path to the controller handler;
.IP \(bu 2
Support filter chains to facilitate the execution of unified logic (such as login verification, Http Method constraint verification, etc.) before handling HTTP requests;
.IP \(bu 2
Support https (based on OpenSSL);
.IP \(bu 2
Support WebSocket (server side and client side);
.IP \(bu 2
Support JSON format request and response, very friendly to the Restful API application development;
.IP \(bu 2
Support file download and upload;
.IP \(bu 2
Support gzip, brotli compression transmission;
.IP \(bu 2
Support pipelining;
.IP \(bu 2
Provide a lightweight command line tool, drogon_ctl, to simplify the creation of various classes in Drogon and the generation of view code;
.IP \(bu 2
Support non\-blocking I/O based asynchronously reading and writing database (PostgreSQL and MySQL(MariaDB) database);
.IP \(bu 2
Support asynchronously reading and writing sqlite3 database based on thread pool;
.IP \(bu 2
Support ARM Architecture;
.IP \(bu 2
Provide a convenient lightweight ORM implementation that supports for regular object\-to\-database bidirectional mapping;
.IP \(bu 2
Support plugins which can be installed by the configuration file at load time;
.IP \(bu 2
Support AOP with build\-in joinpoints.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Installation
.sp
This section takes Linux as an example to introduce the installation process. Other systems are similar;
.SS System Requirements
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The Linux kernel should be not lower than 2.6.9, 64\-bit version;
.IP \(bu 2
The gcc version is not less than 5.4.0;
.IP \(bu 2
Use cmake as the build tool, and the cmake version should be not less than 3.5;
.IP \(bu 2
Use git as the version management tool;
.UNINDENT
.UNINDENT
.UNINDENT
.SS Library Dependencies
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
trantor, a non\-blocking I/O C++ network library, also developed by the author of Drogon, has been used as a git repository submodule, no need to install in advance;
.IP \(bu 2
jsoncpp, JSON’s c++ library, the version should be no \fIless than 1.7\fP;
.IP \(bu 2
libuuid, generating c library of uuid;
.IP \(bu 2
zlib, used to support compressed transmission;
.IP \(bu 2
OpenSSL, not mandatory, if the OpenSSL library is installed, drogon will support HTTPS as well, otherwise drogon only supports HTTP.
.IP \(bu 2
c\-ares, not mandatory, if the c\-ares library is installed，drogon will be more efficient with DNS;
.IP \(bu 2
libbrotli, not mandatory, if the libbrotli library is installed, drogon will support brotli compression when sending HTTP responses;
.IP \(bu 2
boost, the version should be no less than 1.61, is required only if the C++ compiler does not support C++ 17.
.IP \(bu 2
the client development libraries of postgreSQL, mariadb and sqlite3, not mandatory, if one or more of them is installed, drogon will support access to the according database.
.IP \(bu 2
gtest, not mandatory, if the gtest library is installed, the unit tests can be compiled.
.UNINDENT
.UNINDENT
.UNINDENT
.SS System Preparation Examples
.SS Ubuntu 18.04
.sp
Environment
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install git
sudo apt install gcc
sudo apt install g++
sudo apt install cmake
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
jsoncpp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install libjsoncpp\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
uuid
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install uuid\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
OpenSSL
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install openssl
sudo apt install libssl\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
zlib
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install zlib1g\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.SS CentOS 7.5
.sp
Environment
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install git
yum install gcc
yum install gcc\-c++
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The default installed cmake version is too low, use source installation
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/Kitware/CMake
cd CMake/
\&./bootstrap && make && make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Upgrade gcc
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install centos\-release\-scl
yum install devtoolset\-8
scl enable devtoolset\-8 bash
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Command scl enable devtoolset\-8 bash only activate the new gcc temporarily until the session is end. If you want to always use the new gcc, you could run command \fIecho “scl enable devtoolset\-8 bash” >> ~/.bash_profile\fP, system will automatically activate the new gcc after restarting.
.UNINDENT
.UNINDENT
.sp
jsoncpp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/open\-source\-parsers/jsoncpp
cd jsoncpp/
mkdir build
cd build
cmake ..
make && make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
uuid
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install libuuid\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
OpenSSL
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install openssl\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
zlib
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install zlib\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Database Environment
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: These libraries below are not mandatory. You could choose to install one or more database according to your actual needs.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: If you want to develop you webapp with database, please install the database develop environment first, then install drogon, otherwise you will encounter a \fINO DATABASE FOUND\fP issue.
.UNINDENT
.UNINDENT
.SS PostgreSQL
.sp
PostgreSQL’s native C library libpq needs to be installed. The installation is as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu 16: sudo apt\-get install postgresql\-server\-dev\-all
.IP \(bu 2
ubuntu 18: sudo apt\-get install postgresql\-all
.IP \(bu 2
centOS 7: yum install postgresql\-devel
.IP \(bu 2
MacOS: brew install postgresql
.UNINDENT
.UNINDENT
.UNINDENT
.SS MySQL
.sp
MySQL’s native library does not support asynchronous read and write. Fortunately, MySQL also has a version of MariaDB maintained by the original developer community. This version is compatible with MySQL, and its development library supports asynchronous read and write. Therefore, Drogon uses the MariaDB development library to provide the right MySQL support, as a best practice，your operating system shouldn’t install both Mysql and MariaDB at the same time.
.sp
MariaDB installation is as follows：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu: sudo apt install libmariadbclient\-dev
.IP \(bu 2
centOS 7: yum install mariadb\-devel
.IP \(bu 2
MacOS: brew install mariadb
.UNINDENT
.UNINDENT
.UNINDENT
.SS Sqlite3
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu: sudo apt\-get install libsqlite3\-dev
.IP \(bu 2
centOS: yum install sqlite\-devel
.IP \(bu 2
MacOS: brew install sqlite3
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Some of the above commands only install the development library. If you want to install a server also, please use Google search yourself.
.UNINDENT
.UNINDENT
.SS Drogon installation
.sp
Assuming that the above environment and library dependencies are all ready, the installation process is very simple;
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd $WORK_PATH
git clone https://github.com/an\-tao/drogon
cd drogon
git submodule update \-\-init
mkdir build
cd build
cmake ..
make && sudo make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The default is to compile the debug version. If you want to compile the release version, the cmake command should take the following parameters:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cmake \-DCMAKE_BUILD_TYPE=Release ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the installation is complete, the following files will be installed in the system（One can change the installation location with the CMAKE_INSTALL_PREFIX option）:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The header file of drogon is installed into /usr/local/include/drogon;
.IP \(bu 2
The drogon library file libdrogon.a is installed into /usr/local/lib;
.IP \(bu 2
Drogon’s command line tool drogon_ctl is installed into /usr/local/bin;
.IP \(bu 2
The trantor header file is installed into /usr/local/include/trantor;
.IP \(bu 2
The trantor library file libtrantor.a is installed into /usr/local/lib;
.UNINDENT
.UNINDENT
.UNINDENT
.SS Include drogon source code locally
.sp
Of course, you can also include the drogon source in your project. Suppose you put the drogon under the third_party of your project directory (don’t forget to update submodule in the drogon source directory). Then, you only need to add the following two lines to your project’s cmake file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
add_subdirectory(third_party/drogon)
target_link_libraries(${PROJECT_NAME} PRIVATE drogon)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Use vcpkg
.sp
The easiest way to install drogon on windows is to use vcpkg
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vcpkg.exe install drogon
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vcpkg.exe install drogon:x64\-windows
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Use Docker Image
.sp
We also provide a pre\-build docker image on the \fI\%docker hub\fP . All dependencies of Drogon and Drogon itself are already installed in the docker environment, where users can build Drogon\-based applications directly.
.SS Quick Start
.SS Static Site
.sp
Let’s start with a simple example that introduces the usage of drogon. In this example we create a project using the command line tool \fIdrogon_ctl\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create project your_project_name
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
There are several useful folders in the project directory already:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
├── build                         Build folder
├── CMakeLists.txt                Project cmake configuration file
├── config.json                   Drogon application configuration file
├── controllers                   The folder where the controller source files are stored
├── filters                       The folder where the filter files are stored
├── main.cc                       Main program
├── models                        The folder of the database model file
│   └── model.json
└── views                         The folder where view csp files are stored
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Users can put various files (such as controllers, filters, views, etc.) into corresponding folders. For more convenience and less error, we strongly recommend that users create their own web application projects using the \fBdrogon_ctl\fP command. See drogon_ctl for more details.
.sp
Let’s look at the main.cc file:
\fImain.cpp\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <drogon/HttpAppFramework.h>
int main() {
    //Set HTTP listener address and port
    drogon::app().addListener("0.0.0.0",80);
    //Load config file
    //drogon::app().loadConfigFile("../config.json");
    //Run HTTP framework,the method will block in the internal event loop
    drogon::app().run();
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then build your project as below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd build
cmake ..
make
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the compilation is complete, run the target \fI\&./your_project_name\fP\&.
.sp
Now, we add one simply static file index.html to the Http root path:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo \(aq<h1>Hello Drogon!</h1>\(aq >>index.html
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The default root path is \fI“./”\fP, this could be modified by config.json also, See Configureation File for more details. Then you can visit this page by URL \fI“http://localhost”\fP or \fI“http://localhost/index.html”\fP (or the IP of the server where your wepapp running).
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
Hello Drogon!
.UNINDENT
.UNINDENT
.sp
If server cannot find the the page you have requested, it return 404 page: 404 page
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Make sure your server firewall have allowed the 80 port, otherwise you won’t see these pages.
.UNINDENT
.UNINDENT
.sp
We could copy the directory and files of a static website to the startup directory of this running webapp, then we can access them from the browser. The file types supported by drogon are “html”, “js”, “css”, “xml”, “xsl”, “txt”, “svg”, “ttf”, “otf”, “woff2”, “woff” , “eot”, “png”, “jpg”, “jpeg”, “gif”, “bmp”, “ico”, “icns”, etc by default. Drogon also provides interfaces to change these file types. For details, please refer to the HttpAppFramework API.
.SS Dynamic Site
.sp
Let’s see how to add controllers to this application， and let the controller respond contents.
.sp
One can use the drogon_ctl command line tool to generate controller source files. Let’s run it in the \fIcontrollers\fP directory:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller TestCtrl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As you can see, there are two new files, TestCtrl.h and TestCtrl.cc：
.sp
TestCtrl.h is as follows:
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
TestCtrl.cc is as follows:
\fITestCtrl.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Let’s edit the two files and let the controller handle the function response to a simple “Hello World!”
.sp
TestCtrl.h is as follows:
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_ADD("/",Get,Post);
    PATH_ADD("/test",Get);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Use PATH_ADD to map processing functions on the two paths ‘/’ and ‘/test’ respectively, and adding constraints on these path.
.sp
TestCtrl.cc is as follows:
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
    auto resp=HttpResponse::newHttpResponse();
    resp\->setStatusCode(k200OK);
    resp\->setContentTypeCode(CT_TEXT_HTML);
    resp\->setBody("Hello World!");
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Recompile this project with cmake, then run the target ./your_project_name:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd ../build
cmake ..
make
\&./your_project_name
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Typing \fI“http://localhost/”\fP or \fI“http://localhost/test”\fP in the browser address bar, and you will see “Hello World!” in the browser.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: If your server both have static and dynamic resource, Drogon use dynamic resource first, In this example，the respond of \fI\%http://localhost/\fP is Hello Word! in TestCtrl controller instead of Hello Drogon! in static file index.html.
.UNINDENT
.UNINDENT
.sp
We see that adding a controller to an application is very simple. You only need to add the corresponding source file. Even the main file does not need to be modified. This low\-coupling design is very effective for web application development.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Drogon has no restrictions to the location of the controllers source file, you could save it at the project directory also, even you could define new directory in the CMakeLists.txt, it is recommended to use the controllers directory for the convenience of management.
.UNINDENT
.UNINDENT
.SS Controller Introduction
.SS Controller
.sp
The controller is very important in web application development. It processes the request sent by the browser and then generates a response to the browser. The drogon framework has helped us to handle the network transmission, Http protocol analysis and so on. We only need to pay attention to the logic of the controller; each controller object can have one or more processing functions (generally called handlers), and the interface of the function is generally defined as follows:
.INDENT 0.0
.TP
.B Void handlerName(const HttpRequestPtr &\fIreq\fP, std::function<void(const HttpResponsePtr&)> &&\fIcallback\fP, \&...) 
.UNINDENT
.sp
Where \fIreq\fP is the object of the Http request (wrapped by the smart pointer), the \fIcallback\fP is the callback function object that the framework passes to the controller, and the controller generates the response object (also wrapped by the smart pointer) and then passes the object to the drogon through the callback. Then the framework will send the response content to the browser for you. The last part \fI…\fP is a list of parameters. The drogon maps the parameters in the Http request to the corresponding parameter parameters according to the mapping rules. This is very convenient for application development.
.sp
Obviously, this is an asynchronous interface, one can call the callback after completing the time\-consuming operation at other threads;
.sp
Drogon have three types controllers, HttpSimpleController, HttpController, and WebSocketController. When you use them, the corresponding class template needs to be inherited. For example, a custom class “MyClass” declaration of HttpSimpleController is as follows:
\fIMyClass.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class MyClass:public drogon::HttpSimpleController<MyClass>
{
public:
    //TestController(){}
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback) override;

    PATH_LIST_BEGIN
    PATH_ADD("/json");
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Controller life cycle
.sp
A controller registered to a drogon framework will have at most only one instance and will not be destroyed during the entire application run, so users can declare and use member variables in the controller class. Note that when the handler of the controller is called, it is in a multi\-threaded environment (when the number of IO threads of the framework is configured to be greater than 1), if you need to access non\-temporary variables, please do the concurrent protection work.
.SS Controller HttpSimpleController
.sp
You could use the \fIdrogon_ctl\fP command line tool to quickly generate custum controller class source files based on \fIHttpSimpleController\fP, the command format is as bellow:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We create one controller class named \fITestCtrl\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller TestCtrl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As you can see, there are two new files, TestCtrl.h and TestCtrl.cc. Now, let’s have a look at them:
\fBTestCtrl.h：\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fBTestCtrl.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Each HttpSimpleController class can only define one Http request handler, and it is defined by a virtual function override.
.sp
The route (or called mapping) from the URL path to the handler is done by a macro. You could add multipath mappings with the \fIPATH_ADD\fP macro. All \fIPATH_ADD\fP statements should be set between the \fIPATH_LIST_BEGIN\fP and \fIPATH_LIST_END\fP macro statements.
.sp
The first parameter is the path to be map, parameters behind the path are constraints on this path. Currently, two types of constraints are supported. One is the \fIHttpMethod\fP enum Type, which means the Http method allowed. The other type is the name of the \fIHttpFilter\fP class. One can configure any number of these two types of constraints and there are no order requirements for them. For Filter, please refer to Filter.
.sp
Users can register the same Simple Controller to multiple paths, or register multiple Simple Controllers on the same path (using different HTTP methods).
.sp
You could define an HttpResponse class variable, and then use the callback() to return it:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//write your application logic here
auto resp=HttpResponse::newHttpResponse();
resp\->setStatusCode(k200OK);
resp\->setContentTypeCode(CT_TEXT_HTML);
resp\->setBody("Your Page Contents");
callback(resp);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBThe mapping from the above path to the handler is done at compile time. In fact, the drogon framework also provides an interface for runtime completion mapping. The runtime mapping allows the user to map or modify the mapping through configuration files or other user interfaces without Recompile this program (For performance reasons, it is forbidden to add any controller mapping after running app().run() method).\fP
.SS Controller HttpController
.SS Generation
.sp
You can use the \fIdrogon_ctl\fP command line tool to quickly generate custum controller class source files based on \fIHttpController\fP, the command format is as bellow:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-h <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We create one controller class named \fIUser\fP, under namespace \fIdemo v1\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-h demo::v1::User
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As you can see, two files have been added to the current directory, demo_v1_User.h and demo_v1_User.cc.
.sp
demo_v1_User.h is as follows:
\fIdemo_v1_User.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpController.h>
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController<User>
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
        };
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
demo_v1_User.cc is as follows:
\fIdemo_v1_User.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Usage
.sp
Let’s edit the two files:
.sp
demo_v1_User.h is as follows:
\fIdemo_v1_User.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpController.h>
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController<User>
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
                METHOD_ADD(User::login,"/token?userId={1}&passwd={2}",Post);
                METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get);
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
            void login(const HttpRequestPtr &req,
                    std::function<void (const HttpResponsePtr &)> &&callback,
                    std::string &&userId,
                    const std::string &password);
            void getInfo(const HttpRequestPtr &req,
                        std::function<void (const HttpResponsePtr &)> &&callback,
                        std::string userId,
                        const std::string &token) const;
        };
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
demo_v1_User.cc is as follows:
\fIdemo_v1_User.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here

void User::login(const HttpRequestPtr &req,
        std::function<void (const HttpResponsePtr &)> &&callback,
        std::string &&userId,
        const std::string &password)
{
    LOG_DEBUG<<"User "<<userId<<" login";
    //Authentication algorithm, read database, verify identity, etc...
    //...
    Json::Value ret;
    ret["result"]="ok";
    ret["token"]=drogon::utils::getUuid();
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}
void User::getInfo(const HttpRequestPtr &req,
            std::function<void (const HttpResponsePtr &)> &&callback,
            std::string userId,
            const std::string &token) const
{
    LOG_DEBUG<<"User "<<userId<<" get his information";

    //Verify the validity of the token, etc.
    //Read the database or cache to get user information
    Json::Value ret;
    ret["result"]="ok";
    ret["user_name"]="Jack";
    ret["user_id"]=userId;
    ret["gender"]=1;
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Each \fIHttpController\fP class can define many Http request handlers. Since the number of functions can be arbitrarily large, it is unrealistic to overload them with virtual functions. We need to register the handler itself (not the class) in the framework.
.sp
The mapping from the URL path to the handler is done by macros. You can add a multipath map with the \fIMETHOD_ADD\fP macro or the \fIADD_METHOD_TO\fP macro. All \fIMETHOD_ADD\fP and \fIADD_METHOD_TO\fP statements should be sandwiched between the \fIMETHOD_LIST_BEGIN\fP and \fIMETHOD_LIST_END\fP macro statements.
.sp
The \fIMETHOD_ADD\fP macro automatically prefixes the namespace and class name in the path map. Therefore, in this example, the login function is registered to the \fI/demo/v1/user/token\fP path, and the getInfo function is registered to the \fI/demo/v1/user/xxx/info\fP path. Constraints are similar to the \fIPATH_ADD\fP macro of HttpSimpleController and not be described here.
.sp
The \fIADD_METHOD_TO\fP macro acts almost as much as the former, except that it does not automatically add any prefixes, i.e. the path registered by the macro is an absolute path.
.sp
We see that \fIHttpController\fP provides a more flexible path mapping mechanism, we can put a class of functions in a class.
.sp
In addition, you can see that the macros provide a method for parameters mapping. We can map the parameters on the path to the parameter list of the function. The number of URL path parameter corresponds to the function parameter’s position, this is very convenient. The common types which can be converted by string type all can be used as function parameters (such as std::string, int, float, double, etc.), the drogon framework will automatically help you convert the type, this is very convenient for developing. Note that lvalue references must be of type const.
.sp
The same path can be mapped multiple times, distinguished from each other by Http Method, which is legal and is a common practice of the Restful API, such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
METHOD_LIST_BEGIN
    METHOD_ADD(Book::getInfo,"/{1}?detail={2}",Get);
    METHOD_ADD(Book::newBook,"/{1}",Post);
    METHOD_ADD(Book::deleteOne,"/{1}",Delete);
METHOD_LIST_END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When you use the \fIADD_METHOD\fP macro and the class belongs to some namespace, you should add namespace to the access url, in this example, use \fIhttp://localhost/demo/v1/user/token?userid=xxx&passwd=xxx\fP or \fIhttp://localhost/demo/v1/user/xxxxx/info?token=xxxx\fP to access.
.sp
The placeholders of path parameters can be written in several ways:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
{}: The position on the path is the position of the function parameter, which indicates that the path parameter maps to the corresponding position of the handler parameters.
.IP \(bu 2
{1},{2}: The path parameters with a number in are mapped to the handler parameters specified by the number.
.IP \(bu 2
{anystring}: Strings here have no practical effect, but can improve the readability of the program, equivalent to {}.
.IP \(bu 2
{1:anystring},{2:xxx}: The number before the colon represents the position, and the string behind it does not actually work, but can improve the readability of the program, which is equivalent to the {1} and {2}.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The latter two writes are recommended, and if the path parameters and function parameters are in the same order, the third is enough. It is easy to know that the following writes are equivalent:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
“/users/{}/books/{}”
.IP \(bu 2
“/users/{}/books/{2}”
.IP \(bu 2
“/users/{user_id}/books/{book_id}”
.IP \(bu 2
“/users/{1:user_id}/books/{2}”
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Path matching is not case sensitive, parameter names are case sensitive, (Parameter values ​​can be mixed in uppercase and lowercase and passed unchanged to the controller)
.UNINDENT
.UNINDENT
.SS Parameters mapping
.sp
Through the previous description, we know that the parameters on the path and the query parameters after the question mark can be mapped to the parameter list of the handler function. The type of the target parameter needs to meet the following conditions:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Must be one of a value type, a constant left value reference, or a non\-const right value reference. It cannot be a non\-const lvalue reference. It is recommended to use an rvalue reference so that the user can dispose of it at will;
.IP \(bu 2
Basic types such as int, long, long long, unsigned long, unsigned long long, float, double, long double, etc can be used as parameter types;
.IP \(bu 2
std::string；
.IP \(bu 2
Any type that can be assigned using the \fIstringstream >>\fP operator;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fIIn addition, the drogon framework also provides a mapping mechanism from the HttpRequestPtr object to any type of parameter\fP\&. When the number of mapping parameters in your handler parameter list is more than the parameters on the path, the extra parameters will be converted by the HttpRequestPtr object. The user can define any type of conversion, the way to define this conversion is to specialize the \fIfromRequest\fP template (which is defined in the HttpRequest.h header file) in the drogon namespace, for example, say we need to make a RESTful interface to create a new user, we define the user’s structure as follows:
\fImyapp_User_drogon.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
namespace myapp{
struct User{
    std::string userName;
    std::string email;
    std::string address;
};
}
namespace drogon
{
template <>
inline myapp::User fromRequest(const HttpRequest &req)
{
    auto json = req.getJsonObject();
    myapp::User user;
    if(json)
    {
        user.userName = (*json)["name"].asString();
        user.email = (*json)["email"].asString();
        user.address = (*json)["address"].asString();
    }
    return user;
}

}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With the above definition and template specialization, we can define the path map and handler as follows:
\fIUserController.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class UserController:public drogon::HttpController<UserController>
{
public:
    METHOD_LIST_BEGIN
        //use METHOD_ADD to add your custom processing function here;
        ADD_METHOD_TO(UserController::newUser,"/users",Post);
    METHOD_LIST_END
    //your declaration of processing function maybe like this:
    void newUser(const HttpRequestPtr &req,
                std::function<void (const HttpResponsePtr &)> &&callback,
                myapp::User &&pNewUser) const;
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It can be seen that the third parameter of \fImyapp::User\fP type has no corresponding placeholder on the mapping path, and the framework regards it as a parameter converted from the \fIreq\fP object, and obtains this parameter through the user\-specialized function template. This is very convenient for users.
.sp
Further, some users do not need to access the HttpRequestPtr object except for their custom type data, so he can put the custom object in the position of the first parameter, and the framework can also correctly complete the mapping, such as the above example. It can also be written as follows:
\fIUserController.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class UserController:public drogon::HttpController<UserController>
{
public:
    METHOD_LIST_BEGIN
        //use METHOD_ADD to add your custom processing function here;
        ADD_METHOD_TO(UserController::newUser,"/users",Post);
    METHOD_LIST_END
    //your declaration of processing function maybe like this:
    void newUser(myapp::User &&pNewUser,
                std::function<void (const HttpResponsePtr &)> &&callback) const;
};
.ft P
.fi
.UNINDENT
.UNINDENT
.SS multiple path mapping
.sp
Drogon supports the use of regular expressions in path mapping, which can be used outside the ‘{}’ curly brackets, for example:
.sp
ADD_METHOD_TO(UserController::handler1,”/users/.*”,Post); /// Match any path prefixed with \fI/users/\fP
ADD_METHOD_TO(UserController::handler2,”/{name}/[0\-9]+”,Post); ///Match any path composed with a name string and a number.
.SS Regular expression
.sp
The above method has limited support for regular expressions. If users want to use regular expressions freely, drogon provides the \fIADD_METHOD_VIA_REGEX\fP macro to achieve this, such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ADD_METHOD_VIA_REGEX(UserController::handler1,"/users/(.*)",Post); /// Match any path prefixed with \(ga/users/\(ga and map the rest of the path to a parameter of the handler1.
ADD_METHOD_VIA_REGEX(UserController::handler2,"/.*([0\-9]*)",Post); /// Matche any path that ends in a number and map that number to a parameter of the handler2.
ADD_METHOD_VIA_REGEX(UserController::handler3,"/(?!data).*",Post); /// Matches any path that does not start with \(aq/data\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
As can be seen, parameter mapping can also be done using regular expressions, and all strings matched by subexpressions will be mapped to the parameters of the handler in order.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
It should be noted that when using regular expressions, you should pay attention to matching conflicts (multiple different handlers are matched). When conflicts happen in the same controller, drogon will only execute the first handler (the one registered in the framework first). When conflicts happen between different controllers, which handler to be executed is uncertain. Therefore, users need to avoid this kind of conflicts.
.UNINDENT
.UNINDENT
.SS Controller WebSocketController
.SS WebSocketController
.sp
As the name implies, \fIWebSocketController\fP is used to process websocket logic. Websocket is a persistent HTTP\-based connection scheme. At the beginning of the websocket, there is an HTTP format request and response exchange. After the websocket connection is established, all messages are transmitted on the websocket. The message is wrapped in a fixed format. There is no limit to the message content and the order in which messages are transmitted.
.sp
The source file of the \fIWebSocketController\fP can be generated by the \fIdrogon_ctl\fP tool. The command format is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-w <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Suppose we want to implement a simple echo function through websocket, that is, the server simply sends back the message sent by the client. We can create the implementation class EchoWebsock of \fIWebSocketController\fP through \fIdrogon_ctl\fP, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-w EchoWebsock
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The command will generate two files of EchoWebsock.h and EchoWebsock.cc,as follows:
\fIEchoWebsock.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/WebSocketController.h>
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                std::string &&)override;
    virtual void handleNewConnection(const HttpRequestPtr &,
                                    const WebSocketConnectionPtr&)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fIEchoWebsock.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
{
    //write your application logic here
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After edited:
\fIEchoWebsock.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/WebSocketController.h>
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                std::string &&)override;
    virtual void handleNewConnection(const HttpRequestPtr &,
                                    const WebSocketConnectionPtr&)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_ADD("/echo");
    WS_PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fIEchoWebsock.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
{
    //write your application logic here
    wsConnPtr\->send(message);
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
First, in this example, the controller is registered to the \fI/echo\fP path via the \fIWS_PATH_ADD\fP macro. The usage of the \fIWS_PATH_ADD\fP macro is similar to the macros of other controllers introduced earlier. One can also register the path with several Filters. Since websocket is handled separately in the framework, it can be repeated with the paths of the first two controllers（\fIHttpSimpleController\fP and \fIHttpApiController\fP） without affecting each other.
.sp
Secondly, in the implementation of the three virtual functions in this example, only the handleNewMessage has the substance, but simply sends the received message back to the client through the send interface.Compile this controller into the framework, you can see the effect, please test it yourself.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Like the usual HTTP protocol, http websocket can be sniffed. If security is required, encryption should be provided by HTTPS. Of course, it is also possible for users to complete encryption and decryption on the server and client side, but HTTPS is more convenient. The underlying layer is handled by drogon, and users only need to care about business logic.
.UNINDENT
.UNINDENT
.sp
The user\-defined websocket controller class inherits from the drogon::WebSocketController class template. The template parameter is a subclass type. The user needs to implement the following three virtual functions to process the establishment, shutdown, and messages of the websocket:
.sp
Easy to know:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
handleNewConnection is called after the websocket is established. req is the setup request sent by the client. At this time, the framework has returned the response. What users can do is to get some additional information through req, such as token. wsConn is a smart pointer to this websocket object, and the commonly used interface will be discussed later.
.IP \(bu 2
handleNewMessage is called after the websocket receives the new message. The message is stored in the message variable. Note that the message is the message payload. The framework has finished the decapsulation and decoding of the message. The user can directly process the message itself.
.IP \(bu 2
handleConnectionClosed is called after the websocket connection is closed, and the user can do some finishing work.
.UNINDENT
.UNINDENT
.UNINDENT
.SS WebSocketConnection
.sp
The common interfaces of the WebSocketConnection object are as follows:
\fIWebSocketConnection.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//Send a websocket message, the encoding and encapsulation
//of the message are the responsibility of the framework
void send(const char *msg,uint64_t len);
void send(const std::string &msg);

//Local and remote addresses of the websocket
const trantor::InetAddress &localAddr() const;
const trantor::InetAddress &peerAddr() const;

//The connection state of the weosocket
bool connected() const;
bool disconnected() const;

//close websocket
void shutdown();//close write
void forceClose();//close

//set up and get the context of the websocket, and store some business data from users.
//the any type means that you can store any type of object.
void setContext(const any &context);
const any &getContext() const;
any *getMutableContext();
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Filter
.sp
In HttpController’s example, the getInfo method should check whether the user is logged in before returning the user’s information. We can write this logic in the getInfo method, but obviously, checking the user’s login membership is general logic which will be used by many interfaces, it should be extracted separately and configured before calling handler, which is what filters do. After the drogon framework completes the URL path matching, it first calls the filters registered on the path in turn, and only when all the filters allow “pass”, the corresponding handler will be called;
.SS Built\-in Filter
.sp
Drogon contains the following common filters:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIdrogon::IntranetIpFilter\fP: allow HTTP requests from intranet IP only, or return the 404 page.
.IP \(bu 2
\fIdrogon::LocalHostFilter\fP: allow HTTP requests from 127.0.0.1 or ::1 only, or return the 404 page.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Custom Filter
.sp
Of course, users can customize the filter, you need to inherit the HttpFilter class template, the template type is the subclass type, for example, if you want to create a LoginFilter, you could define it as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class LoginFilter:public drogon::HttpFilter<LoginFilter>
{
public:
    virtual void doFilter(const HttpRequestPtr &req,
                        FilterCallback &&fcb,
                        FilterChainCallback &&fccb) override ;
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You could create filter by the \fIdrogon_ctl\fP command, see drogon_ctl.
.sp
You need to override the doFilter virtual function of the parent class to implement the filter logic;
.sp
This virtual function has three parameters, which are:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIreq\fP: http request;
.IP \(bu 2
\fIfcb\fP: filter callback function, the function type is void (HttpResponsePtr), when the filter determines that the request is not valid, the specific response is returned to the browser through this callback;
.IP \(bu 2
\fIfccb\fP: filter chain callback function, the function type is void (), when the filter determines that the request is legal, tells drogon to call the next filter or the final handler through this callback;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The specific implementation can refer to the implementation of the drogon built\-in filter.
.SS Filter Registration
.sp
The registration of filters is always accompanied by the registration of controllers.the macros (PATH_ADD, METHOD_ADD, etc.) mentioned earlier can add the name of one or more filters at the end; for example, we change the registration line of the previous \fIgetInfo\fP method to the following form:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get,"LoginFilter");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the path is successfully matched, the \fIgetInfo\fP method will be called only when the following conditions were met:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
The request must be an HTTP Get request;
.IP 2. 3
The requesting party must have logged in;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
As you can see, the configuration and registration of filters are very simple. The controller source file that registers filters does not need to include the filter’s header file. The filter and controller are fully decoupled.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: If the filter is defined in the namespace, you must write the namespace completely when you register the filter.
.UNINDENT
.UNINDENT
.SS View
.SS Views Introduction
.sp
Although the front\-end rendering technology is popular, the back\-end application service only needs to return the corresponding data to the front\-end. However, a good web framework should provide back\-end rendering technology, so that the server program can dynamically generate HTML pages. Views can help users generate these pages. As the name implies, it is only responsible for doing the work related to the presentation, and the complex business logic should be handed over to the controller.
.sp
The earliest web applications embed HTML into the program code to achieve the purpose of dynamically generating HTML pages, but this is inefficient, not intuitive, and so on. So there are languages such as JSP, which are the opposite. , embed the program code into the HTML page. The drogon is of course the latter solution. However, it is obvious that since C++ is compiled and executed, we need to convert the page embedded in C++ code into a C++ source program to compile into the application. Therefore, drogon defines its own specialized CSP (C++ Server Pages) description language, using the command line tool drogon_ctl to convert CSP files into C++ source files for compilation.
.SS Drogon’s CSP
.sp
Drogon’s CSP solution is very simple, we use special markup symbols to embed C++ code into the HTML page. among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The content between the tags <%inc and %> is considered to be the part of the header file that needs to be referenced. Only the #include statement can be written here, such as <%inc#include “xx.h” %>, but many common header files are automatically included by drogon. The user basically does not use this tag;
.IP \(bu 2
Everything between the tags <%c++ and %> is treated as C++ code, such as <c++ std:string name=”drogon”; %>;
.IP \(bu 2
.INDENT 2.0
.TP
.B C++ code is generally transferred to the target source file intact, except for the following two special tags:
.INDENT 7.0
.IP \(bu 2
@@ represents the data variable passed by the controller, from which you can get the content you want to display;
.IP \(bu 2
$$ represents a stream object representing the content of the page, and the content to be displayed can be displayed on the page by the << operator;
.UNINDENT
.UNINDENT
.IP \(bu 2
The content sandwiched between the tags [[ and ]] is considered to be the variable name. The view will use the name as the key to find the corresponding variable from the data passed from the controller and output it to the page. Spaces before and after the variable name will be omitted. Paired [[ and ]] should be on the same line. And for performance reasons, only three string data types are supported(const char *, std::string and const std::string), other data types should be output in the above\-mentioned way(by $$);
.IP \(bu 2
The content sandwiched between the tags {% and %} is considered to be the name of a variable or an expression of the C++ program (not the keyword of the data passed by the controller), and the view will output the contents of the variable or the value of the expression to the page. It’s easy to know that {%val.xx%} is equivalent to <%c++$$<<val.xx;%>, but the former is simpler and more intuitive. Similarly, do not write two tags in separate lines;
.IP \(bu 2
The content sandwiched between the tags <%view and %> is considered to be the name of the sub\-view. The framework will find the corresponding sub\-view and fill its contents to the location of the tag; the spaces before and after the view name will be ignored. Do not write <%view and %> in separate lines. Can use multiple levels of nesting, but not loop nesting;
.IP \(bu 2
The content between the tags <%layout and %> is considered as the name of the layout. The framework will find the corresponding layout and fill the content of this view to a position in the layout (in the layout the placeholder [[]] marks this position); spaces before and after the layout name will be ignored, and <%layout and %> should not be written in separate lines. You can use multiple levels of nesting, but not loop nesting. One template file can only inherit from one base layout, multiple inheritance from different layouts is not supported.
.UNINDENT
.UNINDENT
.UNINDENT
.SS The use of views
.sp
The http response of the drogon application is generated by the controller handler, so the response rendered by the view is also generated by the handler, generated by calling the following interface:
.sp
This interface is a static method of the HttpResponse class, which has two parameters:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
viewName: the name of the view, the name of the incoming csp file (\fIthe extension can be omitted\fP);
.IP \(bu 2
data: The controller’s handler passes the data to the view. The type is \fIHttpViewData\fP\&. This is a special map. You can save and retrieve any type of object. For details, please refer to [HttpViewData API] (API\-HttpViewData) Description
.UNINDENT
.UNINDENT
.UNINDENT
.sp
As you can see, the controller does not need to reference the header file of the view. The controller and the view are well decoupled; their only connection is the data variable.
.SS A simple example
.sp
Now let’s make a view that displays the parameters of the HTTP request sent by the browser in the returned html page.
.sp
This time we directly define the handler with the HttpAppFramework interface. In the main file, add the following code before calling the run() method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance()
        .registerHttpMethod("/list_para",
                           [=](const HttpRequestPtr &req,
                               std::function<void (const HttpResponsePtr &)> &&callback)
                           {
                                auto para=req\->getParameters();
                                HttpViewData data;
                                data.insert("title","ListParameters");
                                data.insert("parameters",para);
                                auto resp=HttpResponse::newHttpViewResponse("ListParameters.csp",data);
                                callback(resp);
                           });
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above code registers a lambda expression handler on the \fI/list_para\fP path, passing the requested parameters to the view display. Then, Go to the views folder and create a view file ListParameters.csp with the following contents:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<!DOCTYPE html>
<html>
<%c++
    auto para=@@.get<std::unordered_map<std::string,std::string>>("parameters");
%>
<head>
    <meta charset="UTF\-8">
    <title>[[ title ]]</title>
</head>
<body>
    <%c++ if(para.size()>0){%>
    <H1>Parameters</H1>
    <table border="1">
    <tr>
        <th>name</th>
        <th>value</th>
    </tr>
    <%c++ for(auto iter:para){%>
    <tr>
        <td>{%iter.first%}</td>
        <td><%c++ $$<<iter.second;%></td>
    </tr>
    <%c++}%>
    </table>
    <%c++ }else{%>
    <H1>no parameter</H1>
    <%c++}%>
</body>
</html>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We can use drogon_ctl command tool to convert ListParameters.csp into C++ source files as bellow:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create view ListParameters.csp
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the operation is finished, two source files, ListParameters.h and ListParameters.cc, will appear in the current directory, which can be used to compile into the web application;
.sp
Recompile the entire project with cmake, run the target program webapp, you can test the effect in the browser, enter \fIhttp://localhost/list_para?p1=a&p2=b&p3=c\fP in the address bar, you can see the following page :
.sp
view page
.sp
The html page rendered by the backend is simply added.
.SS Automated processing of csp files
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: If your project is create by the \fIdrogon_ctl\fP command, the work described in this section is done automatically by \fIdrogon_ctl\fP\&.
.UNINDENT
.UNINDENT
.sp
Obviously, it is too inconvenient to manually run the drogon_ctl command every time you modify the csp file. We can put the processing of drogon_ctl into the CMakeLists.txt file. Still use the previous example as an example. Let’s assume that we put all the csp files In the views folder, CMakeLists.txt can be added as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
FILE(GLOB SCP_LIST ${CMAKE_CURRENT_SOURCE_DIR}/views/*.csp)
foreach(cspFile ${SCP_LIST})
    message(STATUS "cspFile:" ${cspFile})
    EXEC_PROGRAM(basename ARGS "\-s .csp ${cspFile}" OUTPUT_VARIABLE classname)
    message(STATUS "view classname:" ${classname})
    add_custom_command(OUTPUT ${classname}.h ${classname}.cc
        COMMAND drogon_ctl
        ARGS create view ${cspFile}
        DEPENDS ${cspFile}
        VERBATIM )
set(VIEWSRC ${VIEWSRC} ${classname}.cc)
endforeach()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Then add a new source file collection ${VIEWSRC} to the add_executable statement as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Add_executable(webapp ${SRC_DIR} ${VIEWSRC})
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dynamic compilation and loading of views
.sp
Drogon provides a way to dynamically compile and load csp files during the application runtime, using the following interface:
.sp
The interface is a member method of \fIHttpAppFramework\fP, and the parameter is an array of strings representing a list of directories in which the view csp file is located. After calling this interface, drogon will automatically search for csp files in these directories. After discovering new or modified csp files, the source files will be automatically generated, compiled into dynamic library files and loaded into the application. The application process does not need to be restarted. Users can experiment on their own and observe the page changes caused by the modification of csp file.
.sp
Obviously, this function depends on the development environment. If both drogon and webapp are compiled on this server, there should be no problem in dynamically loading the csp page.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Dynamic views should not be compiled into the application statically. This means that if the view is statically compiled, it cannot be updated via dynamic view loading. You can create a directory outside the compilation folder and move views into it during development.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: This feature is best used to adjust the HTML page during the development phase. In the production environment, it is recommended to compile the csp file directly into the target file. This is mainly for security and stability.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: If a \fIsymbol not found\fP error occurs while loading a dynamic view, please use the \fIcmake .. \-DCMAKE_ENABLE_EXPORTS=on\fP to configure your project, or uncomment the last line (\fIset_property(TARGET ${PROJECT_NAME} PROPERTY ENABLE_EXPORTS ON)\fP) in your project’s CMakeLists.txt, and then rebuild the project
.UNINDENT
.UNINDENT
.SS Session
.sp
\fISession\fP is an important concept of the web application. It is used to save the state of the client on the server. Generally, it cooperates with the browser’s \fIcookie\fP, and drogon provides support for the session. Drogon close the session selection by default, you can also close or open it through the following interface:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void disableSession();
void enableSession(const size_t timeout=0);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above methods are all called through the \fIHttpAppFramework\fP singleton. The timeout parameter represents the time when the session is invalid. The unit is second. The default value is 1200. That is, if the user does not access the web application for more than 20 minutes, the corresponding session will be invalid. Setting timeout to 0 means that drogon will retain the user’s session for the entire lifetime;
.sp
Make sure your client supports cookies before opening the session feature. Otherwise, drogon will create a new session for each request without \fISessionID\fP cookie, which will waste memory and computing resources.
.SS Session object
.sp
The session object type of drogon is \fIdrogon::Session\fP, which is very similar to \fIHttpViewData\fP\&. It can access any type of object through keywords; support concurrent reading and writing; please refer to the description of Session class for specific usage;
.sp
The drogon framework will pass the session object to the \fIHttpRequest\fP object and pass it to the user. The user can get the Session object through the following interface of the \fIHttpRequest\fP class.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
SessionPtr session() const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The interface returns a smart pointer of the \fISession\fP object, through which various objects can be accessed;
.SS Examples of sessions
.sp
We add a feature that requires session support. For example, we want to limit the user’s access frequency. After a visit, if it is accessed again within 10 seconds, it will return an error, otherwise it will return ok. We need to record the last access time in the session, and then compare it with the time of this visit, you can achieve this function.
.sp
We create a Filter to implement this function, assuming the class name is TimeFilter, the implementation is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TimeFilter.h"
#include <trantor/utils/Date.h>
#include <trantor/utils/Logger.h>
#define VDate "visitDate"
void TimeFilter::doFilter(const HttpRequestPtr &req,
                        FilterCallback &&cb,
                        FilterChainCallback &&ccb)
{
    trantor::Date now=trantor::Date::date();
    LOG_TRACE<<"";
    if(req\->session()\->find(VDate))
    {
        auto lastDate=req\->session()\->get<trantor::Date>(VDate);
        LOG_TRACE<<"last:"<<lastDate.toFormattedString(false);
        req\->session()\->insert(VDate,now);
        LOG_TRACE<<"update visitDate";
        if(now>lastDate.after(10))
        {
            //10 sec later can visit again;
            ccb();
            return;
        }
        else
        {
            Json::Value json;
            json["result"]="error";
            json["message"]="Access interval should be at least 10 seconds";
            auto res=HttpResponse::newHttpJsonResponse(json);
            cb(res);
            return;
        }
    }
    LOG_TRACE<<"first access,insert visitDate";
    req\->session()\->insert(VDate,now);
    ccb();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
We then register a lambda expression to the \fI/slow\fP path and attach the TimeFilter with the following code:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance()
            .registerHttpMethod("/slow",
                               [=](const HttpRequestPtr &req,
                                   std::function<void (const HttpResponsePtr &)> &&callback)
                               {
                                   Json::Value json;
                                   json["result"]="ok";
                                   auto resp=HttpResponse::newHttpJsonResponse(json);
                                   callback(resp);
                               },
                               {Get,"TimeFilter"});
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Call the framework interface to open the session:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance().enableSession(1200);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Recompile the entire project with cmake, run the target program webapp, and you can see the effect through the browser.
.SS Database General
.SS General
.sp
\fIDrogon\fP has built\-in database read/write engine. The operation of database connection is based on non\-blocking I/O technology. Therefore, the application works in an efficient non\-blocking asynchronous mode from the bottom to the upper layer, which ensures Drogon’s high concurrency performance. Currently, Drogon supports PostgreSQL and MySQL databases. If you want to use a database, the development environment of the corresponding database must be installed first. Drogon will automatically detect the header files and library files of these libraries and compile the corresponding parts. For the preparation of the database development environment, see Development Environment.
.sp
Drogon supports the sqlite3 database in order to support lightweight applications. The asynchronous interface is implemented through the thread pool, which is the same as the interfaces of the aforementioned databases.
.SS DbClient
.sp
The basic class of Drogon’s database is \fIDbClient\fP (this is an abstract class, the specific type depends on the interface that constructs it). Unlike a generic database interface, a DbClient object does not represent a single database connection. It can contain one or more database connections, so you can think of it as a \fIconnection pool object\fP\&.
.sp
\fIDbClient\fP provides both synchronous and asynchronous interfaces. The asynchronous interface also supports both blocking and non\-blocking modes. Of course, for the cooperation with the Drogon asynchronous framework, it is recommended that you use the the asynchronous interface with non\-blocking mode.
.sp
Usually, when an asynchronous interface is called, \fIDbClient\fP will randomly select one of the idle connections it manages to perform related query operations. When the result returns, \fIDbClient\fP will process the data and return it to the caller through the callback function object; Without an idle connection, the execution content will be cached. Once a connection has executed its own sql request, the pending command will be fetched from the cache to execute.
.sp
For details on DbClient, see DbClient.
.SS Transaction
.sp
The transaction object can be generated by \fIDbClient\fP to support transaction operations. In addition to the extra \fIrollback()\fP interface, the transaction object is basically the same as \fIDbClient\fP\&. The transaction class is \fITransaction\fP\&. For details of the \fITransaction\fP class, see Transaction.
.SS ORM
.sp
Drogon also provides support for \fIORM\fP\&. Users can use the drogon_ctl command to read the tables in the database and generate the corresponding model source code. Then, execute the database operations of these models through the \fIMapper<MODEL>\fP class template. Mapper provides simple and convenient interfaces for standard database operations, allowing users to make the additions, deletions, and changes to the table without writing sql statements. For \fIORM\fP, please refer to ORM
.SS DataBase DbClient
.SS DbClient Object Construction
.sp
There are two ways to construct a DbClient object. One is through the static method of the DbClient class. You can see the definition in the DbClient.h header file, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#if USE_POSTGRESQL
    static std::shared_ptr<DbClient> newPgClient(const std::string &connInfo, const size_t connNum);
#endif
#if USE_MYSQL
    static std::shared_ptr<DbClient> newMysqlClient(const std::string &connInfo, const size_t connNum);
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Use the above interface to get the smart pointer of the DbClient implementation object. The parameter connInfo is a connection string. Set a series of connection parameters in the form of key=value. For details, please refer to the comments in the header file. The parameter connNum is the number of database connections of DbClient, which has a key impact on concurrency. Please set it according to the actual situation.
.sp
The object obtained by the above method, the user has to find a way to \fBpersist\fP it, such as putting it in some global container. \fBCreating a temporary object and then releasing it after use is a very unrecommended solution\fP for the following reasons:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
This will waste time creating connections and disconnections, increasing system latency;
.IP \(bu 2
The interface is also a non\-blocking interface. That is to say, when the user gets the DbClient object, the connection managed by the it has not been established yet. The framework does not (intentionally) provide a callback interface for successful connection establishment. Do you still have to sleep before starting the query?? This is contrary to the original intention of the asynchronous framework.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Therefore, DbClient objects should be built at the beginning of the program and held and used throughout the life time. Obviously, this work can be done entirely by the framework. So the drogon framework provides the second build method, which is built by configuration file or the createDbClient() method. For the configuration method of the configuration file, see db_clients.
.sp
When needed, the DbClient smart pointer is obtained through the interface of the framework. The interface is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
orm::DbClientPtr getDbClient(const std::string &name = "default");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The parameter name is the value of the name configuration option in the configuration file to distinguish multiple different DbClient objects of the same application. The connections managed by DbClient are always reconnected, so users don’t need to care about the connection status. They are almost always connected.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: This method cannot be called before running app.run(), otherwise the user will get an empty shared_ptr.
.UNINDENT
.UNINDENT
.SS Execution Interface
.sp
DbClient provides several different interfaces to users, as listed below:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// Asynchronous mothod
template <
        typename FUNCTION1,
        typename FUNCTION2,
        typename... Arguments>
void execSqlAsync(const std::string &sql,
                FUNCTION1 &&rCallback,
                FUNCTION2 &&exceptCallback,
                Arguments &&... args) noexcept;

/// Asynchronous mothod by \(aqfuture\(aq
template <typename... Arguments>
std::future<const Result> execSqlAsyncFuture(const std::string &sql,
                                            Arguments &&... args) noexcept;

/// Synchronous method
template <typename... Arguments>
const Result execSqlSync(const std::string &sql,
                        Arguments &&... args) noexcept(false);

/// Streaming\-type method
internal::SqlBinder operator<<(const std::string &sql);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Since the number and type of binding parameters cannot be predetermined, these methods are function templates.
.sp
The properties of these methods are shown in the following table:
.TS
center;
|l|l|l|l|.
_
T{
Methods
T}	T{
Synchronous/Asynchronous
T}	T{
Blocking/Non\-blocking
T}	T{
Exception
T}
_
T{
void execSqlAsync
T}	T{
Asynchronous
T}	T{
Non\-blocking
T}	T{
Will not throw an exception
T}
_
T{
std::future execSqlAsyncFuture
T}	T{
Asynchronous
T}	T{
Block when calling the get method of the future
T}	T{
May throw an exception when calling the get method of the future
T}
_
T{
const Result execSqlSync
T}	T{
Synchronous
T}	T{
Blocking
T}	T{
May throw an exception
T}
_
T{
internal::SqlBinder operator<<
T}	T{
Asynchronous
T}	T{
Default non\-blocking
T}	T{
Will not throw an exception
T}
_
.TE
.sp
You may be confused about the combination of asynchronous and blocking. In general, the synchronization method involving network IO is blocking, and the asynchronous method is non\-blocking. However, the asynchronous method can also work in blocking mode, meaning that this method will Block until the callback function has finished executing. When the asynchronous method of DbClient works in blocking mode, the callback function will be executed in the thread of the caller, and then the method will return.
.sp
If your application involves high\-concurrency scenarios, please use asynchronous non\-blocking methods. If it is in a low concurrent scene (such as a network device management page), you can choose synchronization methods for convenience and intuitiveness.
.SS execSqlAsync
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename FUNCTION1,
        typename FUNCTION2,
        typename... Arguments>
void execSqlAsync(const std::string &sql,
                FUNCTION1 &&rCallback,
                FUNCTION2 &&exceptCallback,
                Arguments &&... args) noexcept;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is the most commonly used asynchronous interface, working in non\-blocking mode;
.sp
The parameter \fIsql\fP is a string of sql statements. If there are placeholders for binding parameters, use the placeholder rules of the corresponding database. For example, PostgreSQL placeholders are $1, $2 …, while MySQL placeholders are \fI?\fP\&.
.sp
The indefinite parameter \fIargs\fP represents the bound parameter, which can be zero or more. The number of parameters is the same as the number of placeholders in the sql statement. The types can be the following:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Integer type: can be an integer of various word lengths, and should match the database field type;
.IP \(bu 2
Floating point type: can be float or double, should match the database field type;
.IP \(bu 2
String type: can be std::string or const char[], corresponding to the string type of the database or other types that can be represented by strings;
.IP \(bu 2
Date type: trantor::Date type, corresponding to the database date, datetime, timestamp types.
.IP \(bu 2
Binary type: std::vector<char> type, corresponding to PostgreSQL’s bytea type or Mysql’s blob type;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
These parameters can be left or right, can be variables or literal constants, and users are free to use them.
.sp
The parameters rCallback and exceptCallback represent the result callback function and the exception callback function, respectively, which have a fixed definition, as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The result callback function: the call type is void (const Result &), various callable objects conforming to this call type, std::function, lambda, etc. can be passed as parameters;
.IP \(bu 2
Exception callback function: the call type is void (const DrogonDbException &), which can pass various callable objects that are consistent with this call type;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
After the execution of sql is successful, the execution result is wrapped by the Result class and passed to the user through the result callback function; if there is any exception in the sql execution, the exception callback function is executed, and the user can obtain the exception information from the DrogonDbException object.
.sp
Let us give an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto clientPtr = drogon::app().getDbClient();
clientPtr\->execSqlAsync("select * from users where org_name=$1",
                            [](const Result &r) {
                                std::cout << r.size() << " rows selected!" << std::endl;
                                int i = 0;
                                for (auto row : r)
                                {
                                    std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
                                }
                            },
                            [](const DrogonDbException &e) {
                                std::cerr << "error:" << e.base().what() << std::endl;
                            },
                            "default");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
From the example we can see that the Result object is a std standard compatible container, support iterators, you can get the object of each row through the range loop. the various interfaces of Result, Row and Field objects, please refer to the source code.
.sp
The DrogonDbException class is the base class for all database exceptions. Please refer to the comments in the source code.
.SS execSqlAsyncFuture
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename... Arguments>
std::future<const Result> execSqlAsyncFuture(const std::string &sql,
                                            Arguments &&... args) noexcept;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The asynchronous future interface omits the two callback parameters of the previous interface. Calling this interface will immediately return a future object. The user must call the get() method of the future object to get the returned result. The exception is obtained through the try/catch mechanism. if the get() method isn’t in the \fItry/catch\fP, and there is no \fItry/catch\fP in the entire call stack, the program will exit when the sql execution exception occurs.
.sp
For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto f = clientPtr\->execSqlAsyncFuture("select * from users where org_name=$1",
                                    "default");
try
{
    auto result = f.get(); // Block until we get the result or catch the exception;
    std::cout << r.size() << " rows selected!" << std::endl;
    int i = 0;
    for (auto row : r)
    {
        std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
    }
}
catch (const DrogonDbException &e)
{
    std::cerr << "error:" << e.base().what() << std::endl;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS execSqlSync
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename... Arguments>
const Result execSqlSync(const std::string &sql,
                        Arguments &&... args) noexcept(false);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Synchronous interface is the most simple and intuitive, the input parameters are sql string and bound parameters, return a Result object, the call will block the current thread, and throw an exception when an error occurs, so also pay attention to catch exception with \fItry/catch\fP\&.
.sp
E.g:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
try
{
    auto result = clientPtr\->execSqlSync("update users set user_name=$1 where user_id=$2",
                                        "test",
                                        1); // Block until we get the result or catch the exception;
    std::cout << r.affectedRows() << " rows updated!" << std::endl;
}
catch (const DrogonDbException &e)
{
    std::cerr << "error:" << e.base().what() << std::endl;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS operator<<
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
internal::SqlBinder operator<<(const std::string &sql);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The streaming interface is special. It inputs the sql statement and parameters in turn through the << operator, and specifies the result callback function and the exception callback function through the >> operator. For example, the previous example of selecting, using the streaming interface is Look like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
*clientPtr  << "select * from users where org_name=$1"
            << "default"
            >> [](const Result &r)
                {
                    std::cout << r.size() << " rows selected!" << std::endl;
                    int i = 0;
                    for (auto row : r)
                    {
                        std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
                    }
                }
            >> [](const DrogonDbException &e)
                {
                    std::cerr << "error:" << e.base().what() << std::endl;
                };
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This usage is completely equivalent to the first asynchronous non\-blocking interface, and which interface is used depends on the user’s usage habits. If you want it to work in blocking mode, you can use << to enter a Mode::Blocking parameter, which is not described here.
.sp
In addition, the streaming interface has a special usage. Using a special result callback, the framework can pass the result to the user row by row. The call type of this callback is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void (bool,Arguments...);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When the first bool parameter is true, it means that the result is a empty row, that is, all the results have been returned, this is the last callback; Behind is a series of parameters, corresponding to the value of each column of a row of records, the framework will do type conversion, of course, the user should also pay attention to the type of matching. These types can be const\-type lvalue references, or rvalue references, and of course value types.
.sp
Let’s rewrite the previous example with this callback:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 0;
*clientPtr  << "select user_name, user_id from users where org_name=$1"
            << "default"
            >> [&i](bool isNull, const std::string &name, int64_t id)
                    {
                    if (!isNull)
                        std::cout << i++ << ": user name is " << name << ", user id is " << id << std::endl;
                    else
                        std::cout << i << " rows selected!" << std::endl;
                    }
            >> [](const DrogonDbException &e)
                {
                    std::cerr << "error:" << e.base().what() << std::endl;
                };
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It can be seen that the values ​​of the user_name and user_id fields in the select statement are respectively assigned to the name and id variables in the callback function, and the user does not need to handle these conversions by themselves, which obviously provides a certain convenience, and the user can use it flexibly.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: It is important to emphasize that in asynchronous programming the user must pay attention to the variable i in the above example. The user must ensure that the variable i is valid when the callback occurs because it is caught by the reference. The callback will be called in another thread, and the current context may have failed when the callback occurred. Programmers typically use smart pointers to hold temporarily created variables and then capture them through callbacks to ensure the validity of the variables.
.UNINDENT
.UNINDENT
.SS Summary
.sp
Each DbClient object has one or multiple its own EventLoop threads controlling the database connection IO, accepting the request via an asynchronous or synchronous interface, and returning the result via a callback function.
.sp
Blocking interfaces of DbClient only block the caller thread, as long as the caller thread is not the EventLoop thread, it will not affect the normal operation of the EventLoop thread. When the callback function is called, the program inside the callback is run on the EventLoop thread. Therefore, do not perform any blocking operations within the callback, otherwise it will affect the concurrency performance of database read and write. Anyone familiar with non\-blocking I/O programming should understand this constraint.
.SS DataBase Transaction
.sp
\fITransactions\fP are an important feature of relational databases, and Drogon provides transaction support with the \fITransaction\fP class.
.sp
Objects of the \fITransaction\fP class are created by \fIDbClient\fP, and many transaction\-related operations are performed automatically:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
At the beginning of the Transaction object creation, the begin statement is automatically executed to start the transaction;
.IP \(bu 2
When the Transaction object is destructed, the commit statement is automatically executed to end the transaction;
.IP \(bu 2
If there is an exception that causes the transaction to fail, the rollback statement is automatically executed to \fI\(garoll back the transaction\(ga\fP;
.IP \(bu 2
If the transaction has been rolled back, then the sql statement will return an exception (throw an exception or perform an exception callback);
.UNINDENT
.UNINDENT
.UNINDENT
.SS Transaction Creation
.sp
The method of transaction creation is provided by \fIDbClient\fP as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
std::shared_ptr<Transaction> newTransaction(const std::function<void(bool)> &commitCallback = std::function<void(bool)>())
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This interface is very simple, it returns a smart pointer to a \fITransaction\fP object. Obviously, when the smart pointer loses all the holders and destructs the transaction object, the transaction ends. The parameter \fIcommitCallback\fP is used to return whether the transaction commit is successful. It should be noted that this callback is only used to indicate whether the \fIcommit\fP command is successful. If the transaction is automatically or manually rolled back during execution, the \fIcallback\fP will not be executed. Generally, the commit command will succeed，the bool type parameter of this callback is true. Only some special cases, such as the connection disconnection during the commit process, will cause the \fIcommitCallback\fP to notify the user that the commit fails, at this time, the state of the transaction on the server is not certain, the user needs to deal with this situation specially. Of course, considering that this situation rarely occurs, with non\-critical services the user can choose to ignore this event by ignoring the \fIcommitCallback\fP parameter when creating the transaction (The default empty callback will be passed to the newTransaction method).
.sp
The transaction must monopolize the database connection. Therefore, during transaction creation, \fIDbClient\fP needs to select an idle connection from its own connection pool and hand it over to transaction object management. This has a problem. If all connections in the DbClient are executing sql or other transactions, the interface will block until there is an idle connection.
.sp
The framework also provides an asynchronous interface for creating transactions, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void newTransactionAsync(const std::function<void(const std::shared_ptr<Transaction> &)> &callback);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This interface returns the transaction object through the callback function, does not block the current thread, and ensures high concurrency of the application. Users can use it or the synchronous version according to the actual situation.
.SS Transaction Interface
.sp
The \fITransaction\fP interface is almost identical to \fIDbClient\fP, except for the following two differences:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fITransaction\fP provides a \fIrollback()\fP interface that allows the user to roll back the transaction under any circumstances. Sometimes, the transaction has been automatically rolled back, and then calling the \fIrollback()\fP interface has no negative impact, so explicitly using the rollback() interface is a good strategy to at least ensure that it is not committed incorrectly.
.IP \(bu 2
The user cannot call the transaction’s \fInewTransaction()\fP interface, which is easy to understand. Although the database has the concept of a sub\-transaction, the framework does not currently support it.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
In fact, \fITransaction\fP is designed as a subclass of \fIDbClient\fP, in order to maintain the consistency of these interfaces, and at the same time, it also creates convenient conditions for the use of ORM.
.sp
The framework currently does not provide an interface to control transaction isolation levels, that is, the isolation level is the default level of the current database service.
.SS Transaction Life Cycle
.sp
The smart pointer of the transaction object is held by the user. When it has unexecuted sql, the framework will hold it, so don’t worry about the transaction object being destructed when there is still unexecuted sql. In addition, the transaction object smart pointer is often caught and used in the result callback of one of its interfaces. This is the normal way to use, don’t worry that the circular reference will cause the transaction object to never be destroyed, because the framework will help the user break the circular reference automatically.
.SS One Example
.sp
For the simplest example, suppose there is a task table from which the user selects an unprocessed task and changes it to the state being processed. To prevent concurrent race conditions, we use the \fITransaction\fP class, the program is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    auto transPtr = clientPtr\->newTransaction();
    transPtr\->execSqlAsync( "select * from tasks where status=$1 for update order by time",
                            "none",
                            [=](const Result &r) {
                                if (r.size() > 0)
                                {
                                    std::cout << "Got a task!" << std::endl;
                                    *transPtr << "update tasks set status=$1 where task_id=$2"
                                            << "handling"
                                            << r[0]["task_id"].as<int64_t>()
                                            >> [](const Result &r)
                                                {
                                                    std::cout << "Updated!";
                                                    ... do something about the task;
                                                }
                                            >> [](const DrogonDbException &e)
                                                {
                                                    std::cerr << "err:" << e.base().what() << std::end;
                                                };
                                }
                                else
                                {
                                    std::cout << "No new tasks found!" << std::endl;
                                }
                            },
                            [](const DrogonDbException &e) {
                                std::cerr << "err:" << e.base().what() << std::end;
                            });
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In this case, select for update is used to avoid concurrent modifications. The update statement is completed in the result callback of the select statement. The outermost braces are used to limit the scope of the transPtr so that it can be destroyed in time after the execution of sql to end the transaction.
.SS DataBase ORM
.SS Model
.sp
Using Drogon’s ORM, you first need to create model classes. Drogon’s command\-line program drogon_ctl provides the ability to generate model classes. The program reads tables information from a user\-specified database and automatically generates multiple source files for the model classes based on this information. When the user uses the model, please include the corresponding header file.
.sp
Obviously, each Model class corresponds to a specific database table, and an instance of a model class, corresponds a row of records in the table.
.sp
The command to create model classes is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create model <model_path>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The last parameter is the path to store model classes. There must be a configuration file model.json in the path to configure the connection parameters of drogon_ctl to the database. It is a file in JSON format and supports comments. The examples are as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "rdbms":"postgresql",
    "host":"127.0.0.1",
    "port":5432,
    "dbname":"test",
    "user":"test",
    "passwd":"",
    "tables":[]
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The configured parameters are the same as the application’s configuration file. Please refer to Configuration File.
.sp
The \fItables\fP configuration option is unique to the model configuration. It is an array of strings. Each string represents the name of the table to be converted into a model class. If this option is empty, all tables will be used to generate model classes.
.sp
The models directory and the corresponding model.json file have been created in advance in the project directory created with the \fIdrogon_ctl create project\fP command. The user can edit the configuration file and create model classes with the drogon_ctl command.
.SS Model Class Interface
.sp
There are mainly two types of interfaces that the user directly uses, getter interfaces and setter interfaces.
.sp
There are two types of getter interfaces:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
An interface of the form like \fIgetColumnName\fP gets the smart pointer of the field. The return value is a pointer instead of a value is primarily used for the NULL field. The user can determine whether the field is a NULL field by determining whether the pointer is empty.
.IP \(bu 2
An interface of the form like \fIgetValueOfColumnName\fP, hence the name, is the value obtained. For efficiency reasons, the interface returns a constant reference. If the corresponding field is NULL, the interface returns the default value given by the function parameter.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
In addition, the binary block type (blob, bytea) has a special interface, in the form of \fIgetValueOfColumnNameAsString\fP, which loads the binary data into the std::string object and returns it to the user.
.sp
The setter interface is used to set the value of the corresponding field, in the form of \fIsetColumnName\fP, and the parameter type and field type correspond. Automatically generated fields (such as self\-incrementing primary keys) do not have a setter interface.
.sp
The toJson() interface is used to convert the model object into a JSON object. The binary block type is base64 encoded. Please experiment with it yourself.
.sp
The static members of the Model class represent the information of the table. For example, the name of each field can be obtained through the Cols static member, which is convenient to use in an editor that supports automatic prompting.
.SS Mapper Class Template
.sp
The mapping between the model object and the database table is performed by the Mapper class template. The Mapper class template encapsulates common operations such as adding, deleting, and changing, so that the user can perform the above operations without writing a SQL statement.
.sp
The construction of the Mapper object is very simple. The template parameter is the type of the model you want to access. The constructor has only one parameter, which is the DbClient smart pointer mentioned earlier. As mentioned earlier, the Transaction class is a subclass of DbClient, so you can also construct a Mapper object with a smart pointer to a transaction, which means that the Mapper mapping also supports transactions.
.sp
Like DbClient, Mapper also provides asynchronous and synchronous interfaces. The synchronous interface is blocked and may throw an exception. The returned future object is blocked in get() and may throw an exception. The normal asynchronous interface does not throw an exception, but returns the result through two callbacks (result callback and exception callback). The type of the exception callback is the same as that in the DbClient interface. The result callback is also divided into several categories according to the interface function. The list is as follows (T is the template parameter, which is the type of the model):
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: When using a transaction, the exception does not necessarily cause a rollback. Transactions will not be rolled back in the following cases: When the findByPrimaryKey interface does not find a qualified row, when the findOne interface finds fewer or more than one record, the mapper will throw an exception or enter an exception callback, the exception type is UnexpectedRows. If the business logic needs to be rolled back in this condition, please explicitly call the rollback() interface.
.UNINDENT
.UNINDENT
.SS Criteria
.sp
In the previous section, many interfaces required input criteria object parameters. The criteria object is an instance of the Criteria class, indicating a certain condition, such as a field greater than, equal to, less than a given value, or a condition such as \fIis Null\fP\&.
.sp
The constructor of a criteria object is very simple. Generally, the first argument is the name of the field, the second argument is the enumeration value representing the comparison type, and the third argument is the value being compared. If the comparison type is IsNull or IsNotNull, the third parameter is not required.
.sp
E.g：
.. code\-block:: cpp
.INDENT 0.0
.INDENT 3.5
Criteria(“user_id”,CompareOperator::EQ,1);
.UNINDENT
.UNINDENT
.sp
The above example shows that the field user_id is equal to 1 as a condition. In practice, we prefer to write the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Criteria(Users::Cols::_user_id,CompareOperator::EQ,1);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is equivalent to the previous one, but this can use the editor’s automatic prompts, which is more efficient and less prone to errors;
.sp
Criteria objects support AND and OR operations. The sum of two criteria objects constructs a new criteria object, which makes it easy to construct nested conditions. For example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Mapper<Users> mp(dbClientPtr);
auto users = mp.findBy(
(Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Smith")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,0))
||(Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Johnson")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,1))
));
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above program is to query all the men named Smith or the women named Johnson from the users table.
.SS Mapper’s Chain Interface
.sp
Some common sql constraints, such as limit, offset, etc., Mapper class templates also provide support, provided in the form of a chained interface, meaning that users can string multiple constraints to write. After executing any of the interfaces in Section 10.5.3, these constraints are cleared, that is, they are valid in one operation:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Mapper<Users> mp(dbClientPtr);
auto users = mp.orderBy(Users::Cols::_join_time).limit(25).offset(0).findAll();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This program is to select the user list from the users table, return the first page of 25 rows per page.
.sp
Basically, the name of the chain interface expresses its function, so I won’t go into details here. Please refer to the Mapper.h header file.
.SS Relationships
.sp
The \fIrelationship\fP between the database tables can be configured through the relationships option in the model.json configuration file. We use manual configuration instead of automatically detecting the foreign key of the table because the actual project does not use foreign keys. It is also very common.
.sp
If the \fIenable\fP option is true, the generated model classes will add corresponding interfaces according to the \fIrelationships\fP configuration.
.sp
There are three types of relationships,*’has one’\fI,\fP’has many’* and \fI‘many to many’\fP\&.
.SS has one
.sp
\fIhas one\fP represents a one\-to\-one relationship. A record in the original table can be associated with a record in the target table, and vice versa. For example, the \fIproducts\fP table and \fIskus\fP table have a one\-to\-one relationship, we can define as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "has one",
    "original_table_name": "products",
    "original_table_alias": "product",
    "original_key": "id",
    "target_table_name": "skus",
    "target_table_alias": "SKU",
    "target_key": "product_id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
“type”: Indicates that this relationship is one\-to\-one;
.IP \(bu 2
“original_table_name”: the name of the original table (the corresponding method will be added to the model corresponding to this table);
.IP \(bu 2
“original_table_alias”: alias (the name in the method, because the one\-to\-one relationship is singular, so set it to product), if this option is empty, the table name is used to generate the method name;
.IP \(bu 2
“original_key”: the associated key of the original table;
.IP \(bu 2
“target_table_name”: the name of the target table;
.IP \(bu 2
“target_table_alias”: the alias of the target table, if this option is empty, the table name is used to generate the method name;
.IP \(bu 2
“target_key”: the associated key of the target table;
.IP \(bu 2
“enable_reverse”: Indicate whether to automatically generate a reverse relationship, that is, add a method to obtain records of the original table in the model class corresponding to the target table.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
According to this setting, in the model class corresponding to the products table, the following method will be added:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// Relationship interfaces
void getSKU(const DbClientPtr &clientPtr,
            const std::function<void(Skus)> &rcb,
            const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is an asynchronous interface that returns the SKU object associated with the current product in the callback.
.sp
At the same time, since the enable_reverse option is set to true, the following method will be added to the model class corresponding to the skus table:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// Relationship interfaces
void getProduct(const DbClientPtr &clientPtr,
                const std::function<void(Products)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS has many
.sp
\fIhas many\fP represents a one\-to\-many relationship. In such a relationship, the table representing \fImany\fP generally has a field associated with the primary key of another table. For example, products and reviews usually have a one\-to\-many relationship, we can define as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "has many",
    "original_table_name": "products",
    "original_table_alias": "product",
    "original_key": "id",
    "target_table_name": "reviews",
    "target_table_alias": "",
    "target_key": "product_id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The meaning of each configuration above is the same as the previous example, so I won’t repeat it here, because there are multiple reviews for a single product, so there is no need to create an alias of reviews. According to this setting, after running drogon_ctl create model, the following interface will be added to the model corresponding to the products table:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getReviews(const DbClientPtr &clientPtr,
                const std::function<void(std::vector<Reviews>)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In the model corresponding to the reviews table, the following interface will be added:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getProduct(const DbClientPtr &clientPtr,
                const std::function<void(Products)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS many to many
.sp
As the name implies, many to many represents a many\-to\-many relationship. Usually, a many\-to\-many relationship requires a pivot table. Each record in the pivot table corresponds to a record in the original table and another record in the target table. For example, the products table and carts table have a many\-to\-many relationship, which can be defined as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "many to many",
    "original_table_name": "products",
    "original_table_alias": "",
    "original_key": "id",
    "pivot_table": {
        "table_name": "carts_products",
        "original_key": "product_id",
        "target_key": "cart_id"
    },
    "target_table_name": "carts",
    "target_table_alias": "",
    "target_key": "id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For the pivot table, there is an additional pivot_table configuration. The options inside easy to understand and are omitted here.
.sp
The model of products generated according to this configuration will add the following method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getCarts(const DbClientPtr &clientPtr,
              const std::function<void(std::vector<std::pair<Carts,CartsProducts>>)> &rcb,
              const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The model class of the carts table will add the following method:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getProducts(const DbClientPtr &clientPtr,
                 const std::function<void(std::vector<std::pair<Products,CartsProducts>>)> &rcb,
                 const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Restful API controllers
.sp
drogon_ctl can also generate restful\-style controllers for each model (or table) while creating models, so that users can generate APIs that can add, delete, modify, and search tables with zero coding. These APIs support many functions such as quering by primary key, quering by conditions, sorting by specific fields, returning specified fields, and assigning alias for each field to hide the table structure. It is controlled by the \fIrestful_api_controllers\fP option in model.json. these options have corresponding comments in the json file.
.sp
It should be noted that the controller of each table is designed to be composed of a base class and a subclass. Among them, the base class and the table are closely related, and the subclass is used to implement special business logic or modify the interface format. The advantage of this design is that when the table structure changes, users can update only the base class without overwriting the subclass(by setting the \fIgenerate_base_only\fP option to \fItrue\fP).
.SS DataBase FastDbClient
.sp
As the name implies, FastDbClient will provide higher performance than the normal DbClient. Unlike DbClient has own event loop, it shares the event loop with network IO threads and the main thread of the web application, which makes the internal implementation of FastDbClient available in a lock\-free mode and more efficient.
.sp
Tests show that FastDbClient has a 10% to 20% performance improvement over DbClient under extremely high load conditions.
.SS Create and Get
.sp
FastDbClient must be created automatically by the framework with the configuration file, or by calling the app.createDbClient() interface:
.sp
The sub\-option \fIis_fast\fP of the db_client option in the configuration file indicates if the client is a FastDbClient.Or user can create a FastDbClient by calling the app.createDbClient() method with the last parameter set to true.
.sp
The framework creates a separate FastDbClient for each IO’s event loop and the main event loop, and each FastDbClient manages several database connections internally. The number of event loop of IO is controlled by the framework’s “threads_num” option, which is generally set to the number of CPU cores of the host. The number of the DB connections per event loop is the value of the DB client “connection_number” option. Please refer to Configuration File. Therefore, the total number of DB connections held by FastDbClient is \fI(threads_num+1) * connection_number\fP\&.
.sp
The interface to get a FastDbClient is similar to the normal DbClient, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
orm::DbClientPtr getFastDbClient(const std::string &name = "default");
/// Use drogon::app().getFastDbCLient("clientName") to get a FastDbClient object.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It should be pointed out that due to the special nature of FastDbClient, the user must call the above interface in the IO event loop thread or the main thread to get the correct smart pointer. In other threads, only the null pointer can be obtained and cannot be used.
.SS Usage
.sp
The use of FastDbClient is almost identical to that of the normal DbClient, except for the following limitations:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Both the get and the use of it must be in the framework’s IO event loop thread or the main thread. If it is used in other threads, there will be unpredictable errors (because the lock\-free condition is destroyed). Fortunately, most of the application programming is in the IO thread, such as within the processing functions of various controllers, within the filter function of filters. It is easy to know that the various callback functions of the FastDbClient interface are also in the current IO thread, and can be safely nestedly used.
.IP \(bu 2
Never use the blocking interface of FastDbClient, because this interface will block the current thread, and the current thread is also the thread that handles the database IO of this object, which will cause permanent blocking, and the user has no chance to get the result.
.IP \(bu 2
Synchronous transaction creation interfaces are likely to block (when all connections are busy), so FastDbClient’s synchronous transaction creation interface returns null pointers directly. If you want to use transactions on FastDbClient, please use the asynchronous transaction creation interface.
.IP \(bu 2
After using the FastDbClient to create an Orm Mapper object, you should also use only asynchronous non\-blocking interfaces of the mapper object.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Plugins
.sp
Plugins are use to help users build complex applications. In Drogon, all plugins are built and installed into the application based on the configuration file. Plugins in Drogon are single\-instance, and users can implement any functionality they want with plugins.
.sp
When Drogon runs the run() interface, it instantiates each plugin one by one according to the configuration file and calls the \fIinitAndStart()\fP interface of them.
.SS Configuration
.sp
Plugin configuration is done through the configuration file, for example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"plugins": [
    {
    //name: The class name of the plugin
    "name": "DataDictionary",
    //dependencies: Plugins that the plugin depends on. It can be commented out
    "dependencies": [],
    //config: The configuration of the plugin. This json object is the parameter to initialize the plugin.
    //It can be commented out
    "config": {
    }
    }],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It can be seen that there are three configurations for each plugin:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
name: is the class name of the plugin (including the namespace). The framework will create a plugin instance based on the class name. If the item is commented out, the plugin becomes disabled.
.IP \(bu 2
dependencies: Is a list of names of other plugins that the plugin depends on. The framework creates and initializes all plugins in a specific order. Prioritize the creation and initialization of plugins that are dependent by others. At the end of the program, plugins are closed and destroyed in reverse order. Please note that circular dependencies in plugins are forbidden. Drogon will report an error and exit the program if it detects a circular dependency. If the item is commented out, the list of dependencies is empty.
.IP \(bu 2
config: is the json object used to initialize the plugin, the object is passed as an input parameter to the plugin’s initAndStart() interface. If the item is commented out, the json object passed to the initAndStart interface is an empty object;
.UNINDENT
.UNINDENT
.UNINDENT
.SS Definition
.sp
User\-defined plugins must inherit from the drogon::Plugin class template, and the template parameter is the plugin type, such as the following definition:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class DataDictionary : public drogon::Plugin<DataDictionary>
{
public:
    virtual void initAndStart(const Json::Value &config) override;
    virtual void shutdown() override;
    ...
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
One can create source files of plugin by drogon_ctl command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create plugin <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Getting Instance
.sp
The plugin instance is created by drogon, and the user can get the plugin instance through the following interface of drogon:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename T> T *getPlugin();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Or
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PluginBase *getPlugin(const std::string &name);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Obviously, the first method is more convenient. For example, the DataDictionary plugin mentioned above can be obtained like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto *pluginPtr=app().getPlugin<DataDictionary>();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Note that it is best to get the plugin after calling the framework’s run() interface, otherwise one will get an uninitialized plugin instance (this doesn’t necessarily lead to an error, it is ok to just make sure to use the plugin after initialization). Of course, since the plugin is initialized in a dependency order, it is no problem to get the instance of another plugin in the \fIinitAndStart()\fP interface.
.SS Life Cycle
.sp
All plugins are initialized in the run() interface of the framework and are destroyed when the application exits. Therefore, the plugin’s lifecycle is almost identical to the application, which is why the getPlugin() interface does not need to return a smart pointer.
.SS Configuration File
.sp
You can control various behaviors of the Http server by configuring various parameters through multiple interfaces of the DrogonAppFramework instance. However, using a configuration file is a better way for the following reasons:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Using a configuration file instead of source code can determine the behavior of the application at runtime rather than at compile time, which is undoubtedly a more convenient and flexible way;
.IP \(bu 2
Using a configuration file can make the main file more concise;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Based on these additional benefits, it is recommended that application developers use configuration files to configure various parameters of the application.
.sp
The configuration file can be loaded very simply by calling the loadConfigFile() interface before calling the run() interface. The parameter of the loadConfigFile() method is the file name of the configuration file, for example:
\fImain.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int main()
{
    drogon::app().loadConfigFile("config.json");
    drogon::app().run();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above program loads the configuration file \fIconfig.json\fP and then runs the application. The specific listening port, log output, database configuration and so on can be configured by the configuration file. In fact, this program can basically be the entire code of the main file of the web application.
.SS Configuration File Details
.sp
An example of a configuration file is at the top level of the source directory, config.example.json. If you use the drogon_ctl create project command to create a project, you can also find the file config.json with the same content in the project directory. So, you basically don’t need to create a new configuration file but make some changes to this file to complete the configuration of the web application.
.sp
The file is in \fIJSON\fP format and supports comments. You can comment out the unneeded configuration items with the c++ comment symbols /**/ and //.
.sp
After commenting out a configuration option, the framework initializes it with default values. The default value for each option can be found in the comments in the configuration file.
.SS SSL
.sp
The ssl option is to configure SSL files of the https service as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"ssl": {
  "cert": "../../trantor/trantor/tests/server.pem",
  "key": "../../trantor/trantor/tests/server.pem"
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Where \fIcert\fP is the path of the certificate file and \fIkey\fP is the path of the private key file. If a file contains both a certificate and a private key, the two paths can be made the same.
.sp
The file is in PEM encoding format.
.SS listeners
.sp
As the name implies, the \fIlisteners\fP option is to configure listeners for the web application. It is a JSON array type. Each JSON object represents a listener. The specific configuration is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"listeners": [
    {
    "address": "0.0.0.0",
    "port": 80,
    "https": false
    },
    {
    "address": "0.0.0.0",
    "port": 443,
    "https": true,
    "cert": "",
    "key": ""
    }
]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIaddress\fP: With the string type indicates the IP address to be listened to. If this option is not available, the default value “0.0.0.0” is used.
.IP \(bu 2
\fIport\fP: port: An integer type option indicating the port to be listened to. It must be a valid port number. There is no default value.
.IP \(bu 2
\fIhttps\fP: Boolean type, indicating whether to use https, the default value is false, which means using http.
.IP \(bu 2
\fIcert\fP and \fIkey\fP: The string type, is valid when https is true, indicating the certificate and private key of https. The default value is an empty string, indicating the certificate and private key file configured by the global option ssl;
.UNINDENT
.UNINDENT
.UNINDENT
.SS db_clients
.sp
This option is used to configure the database client. It is a JSON array type. Each JSON object represents a separate database client. The specific configuration is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"db_clients":[
  {
    "name":"",
    "rdbms": "postgresql",
    "host": "127.0.0.1",
    "port": 5432,
    "dbname": "test",
    "user": "",
    "passwd": "",
    "is_fast": false,
    "connection_number": 1,
    "file_name": ""
  }
]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIname\fP: string type, client name, the default value is “default”, name is the application developer to get the database client’s markup from the framework, if there are multiple clients, the name field must be different;
.IP \(bu 2
\fIrdbms\fP：A string indicating the type of database server. Currently supports “postgresql” and “mysql”, which is not case sensitive;
.IP \(bu 2
\fIhost\fP：String, database server address, \fIlocalhost\fP is the default value;
.IP \(bu 2
\fIport\fP：An integer representing the port number of the database server;
.IP \(bu 2
\fIdbname\fP：String, database name;
.IP \(bu 2
\fIuser\fP：String, user name;
.IP \(bu 2
\fIpasswd\fP：String, password;
.IP \(bu 2
\fIis_fast\fP：bool，false by default, indicate if the client is a FastDbClient
.IP \(bu 2
\fIconnection_number\fP：A integer indicating the number of connections to the database server, at least 1, the default value is also 1, affecting the concurrent performance of data read and write; If the ‘is_fast’ is true, the number is the number of connections per event loop, otherwise it is the total number of all connections.
.IP \(bu 2
\fIfilename\fP: The filename of sqlite3 database;
.UNINDENT
.UNINDENT
.UNINDENT
.SS threads_num
.sp
Suboption belonging to the app option, an integer, the default value is 1, indicating the number of IO threads, which has a clear impact on network concurrency. This number is not as big as possible. Users who understand the non\-blocking I/O principle should know that this value should be the same as the number of processors that he expects network IO to occupy. If the value is set to 0, the number of IO threads will be the number of all hardware cores.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"threads_num": 16,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
The above example shows that network IO uses 16 threads and can run up to 16 CPU cores under high load conditions.
.SS Session
.sp
Session\-related options are also children of the app option, controlling whether session is used and the session timeout. Such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"enable_session": true,
"session_timeout": 1200,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIenable_session\fP：A Boolean value indicating whether to use a session. The default is false. If the client does not support cookies, set it to false because the framework will create a new session for each request without a session cookie, which will result in completely unnecessary resource and performance loss;
.IP \(bu 2
\fIsession_timeout\fP：An integer value indicating the timeout period of the session, in seconds. The default value is 0, indicating permanent validity. Only works if enable_session is true.
.UNINDENT
.UNINDENT
.UNINDENT
.SS document_root
.sp
The suboption of the \fIapp\fP option, a string, indicates the document path corresponding to the Http root directory, and is the root path of the static file download. The default value is “./”, which indicates the current path of the program running. such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"document_root": "./",
.ft P
.fi
.UNINDENT
.UNINDENT
.SS upload_path
.sp
The child of the app option, a string, represents the default path for uploading files. The default value is “uploads”. If the value is not starting with /, ./ or ../, and this value is not .or..\(ga, then this path is the relative path of the previous document_root entry, otherwise it is an absolute path or a relative path to the current directory. Such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"upload_path":"uploads",
.ft P
.fi
.UNINDENT
.UNINDENT
.SS file_types
.sp
The suboption of the app option, an array of strings, with default values ​​as follows, indicates the static file download type supported by the framework. If the requested static file extension is outside of these types, the framework will return a 404 error.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"file_types": [
    "gif",
    "png",
    "jpg",
    "js",
    "css",
    "html",
    "ico",
    "swf",
    "xap",
    "apk",
    "cur",
    "xml"
    ],
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Connection number control
.sp
The children of the app option have two options, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"max_connections": 100000,
"max_connections_per_ip": 0,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fImax_connections\fP：Integer, the default value is 100000, which means the maximum number of simultaneous concurrent connections; when the number of connections maintained by the server reaches this number, the new TCP connection request will be rejected directly.
.IP \(bu 2
\fImax_connections_per_ip\fP：Integer, the default value is 0, which means the maximum number of connections for a single client IP, and 0 means no limit.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Log option
.sp
The child of the \fIapp\fP item, a JSON object, controls the behavior of the log output as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"log": {
    "log_path": "./",
    "logfile_base_name": "",
    "log_size_limit": 100000000,
    "log_level": "TRACE"
    },
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIlog_path\fP：String, the default value is an empty string, indicating the path where the log file is stored. If it is an empty string, all logs are output to the standard output.
.IP \(bu 2
\fIlogfile_base_name\fP：A string indicating the basename of the log file. The default value is an empty string which means the basename will be drogon.
.IP \(bu 2
\fIlog_size_limit\fP：A integer, in bytes. The default value is 100000000 (100M). When the size of the log file reaches this value, the log file will be switched.
.IP \(bu 2
\fIlog_level\fP：A string, the default value is “DEBUG”, which indicates the lowest level of log output. The optional values ​​are from low to high: “TRACE”, “DEBUG”, “INFO”, “WARN”, where the TRACE level is only valid when compiling in DEBUG mode.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Drogon’s file log uses a non\-blocking output structure that can achieve a log output of millions of lines per second and can be used with confidence.
.UNINDENT
.UNINDENT
.SS Application control
.sp
They are also children of the \fIapp\fP option and have two options, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"run_as_daemon": false,
"relaunch_on_error": false,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIrun_as_daemon\fP：Boolean value, the default value is false. When it is true, the application will be a child process of the No.1 process in the form of a daemon running in the background of the system.
.IP \(bu 2
\fIrelaunch_on_error\fP：Boolean value, the default value is false. When it is true, the application will relaunches itself on error.
.UNINDENT
.UNINDENT
.UNINDENT
.SS use_sendfile
.sp
The suboption of app option, boolean, indicates whether the linux system call sendfile is used when sending the file. The default value is true. Using sendfile can improve the sending efficiency and reduce the memory usage of large files. as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"use_sendfile": true,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: Even if this option is true, the sendfile system call will not be used, because the use of sendfile for small files is not necessarily cost\-effective, and the framework will decide whether to adopt it according to its own optimization strategy.
.UNINDENT
.UNINDENT
.SS use_gzip
.sp
The \fIapp\fP suboption, boolean, default value is true, indicating whether the body of the Http response uses compressed transmission. When it is true, compression is used in the following cases:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The client supports gzip compression;
.IP \(bu 2
The Http body is the text type;
.IP \(bu 2
The length of the body is greater than a certain value;
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The configuration example is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"use_gzip": true,
.ft P
.fi
.UNINDENT
.UNINDENT
.SS static_files_cache_time
.sp
The \fIapp\fP suboption, integer value, in seconds, indicates the cache time of the static file, that is, for the repeated request for the file during this time, the framework will return the response directly from the memory without reading the file system. The default value is 5 seconds, 0 means always cache (only read the file system once, use with caution), negative value means no cache. as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"static_files_cache_time": 5,
.ft P
.fi
.UNINDENT
.UNINDENT
.SS simple_controllers_map
.sp
The \fIapp\fP suboption, an array of JSON objects, each representing a mapping from the Http path to the HttpSimpleController, this configuration is just an alternative, not necessarily configured here, see HttpSimpleController. The specific configuration is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"simple_controllers_map": [
    {
        "path": "/path/name",
        "controller": "controllerClassName",
        "http_methods": ["get","post"],
        "filters": ["FilterClassName"]
    }
    ],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIpath\fP：String, Http path;
.IP \(bu 2
\fIcontroller\fP：String, the name of the HttpSimpleController;
.IP \(bu 2
\fIhttp_methods\fP：An array of strings representing the supported Http methods. Requests outside this list will be filtered out, returning a 405 error.
.IP \(bu 2
\fIfilters\fP：String array, list of filters on the path, see Filter;
.UNINDENT
.UNINDENT
.UNINDENT
.SS Idle connection timeout control
.sp
The app suboption, integer value, in seconds, the default value is 60. When a connection exceeds this time without any reading and writing, the connection will be forcibly disconnected. as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"idle_connection_timeout":60
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Dynamic view loading
.sp
The sub\-options of the app, which control the enabling and the path of the dynamic view, have two options, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"load_dynamic_views":true,
"dynamic_views_path":["./views"],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Among them：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIdynamic_views_path\fP：Boolean value, the default value is false. When it is true, the framework searches view files in the view path and dynamically compiles them into .so files, then loads them into the application. When any view file changes, it will also cause automatic compilation and re\-loading;
.IP \(bu 2
\fIdynamic_views_path\fP：An array of strings, each of which represents the search path of the dynamic view. If the path value is not starting with /, ./ or ../, and the value is not . or .., then This path is the relative path of the previous document_root entry, otherwise it is an absolute path or a relative path to the current directory.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
See View
.SS Server header field
.sp
The sub\-option of the app configures the server header field of all responses sent by the framework. The default value is an empty string. When this option is empty, the framework automatically generates a header field of the form \fIServer: drogon/version string\fP\&. It’s as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"server_header_field": ""
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Keepalive requests
.sp
The \fIkeepalive_requests\fP option sets the maximum number of requests that can be served through one keep\-alive connection. After the maximum number of requests are made, the connection is closed. The default value of 0 means no limit. It’s as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"keepalive_requests": 0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Pipelining requests
.sp
The \fIpipelining_requests\fP sets the maximum number of unhandled requests that can be cached in pipelining buffer. After the maximum number of requests are made, the connection is closed. The default value of 0 means no limit. For details about pipelining, please see the \fIrfc2616\-8.1.1.2\fP\&. It’s as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"pipelining_requests": 0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS drogon_ctl Command
.sp
After the Drogon framework is compiled and installed, a command line program \fIdrogon_ctl\fP is also installed in the system, for convenience, also installed an identical copy dg_ctl. Users can choose according to their preferences.
.sp
The main function of the program is to make it easy for users to create various drogon project files. Use the \fIdg_ctl help\fP command to see the functions it supports, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl help
usage: drogon_ctl <command> [<args>]
commands list:
create                  create some source files(Use \(aqdrogon_ctl help create\(aq for more information)
help                    display this message
version                 display version of this tool
press                   Do stress testing(Use \(aqdrogon_ctl help press\(aq for more information)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Version subcommand
.sp
The \fIversion\fP subcommand is used to print the drogon version currently installed on the system, as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
     _
  __| |_ __ ___   __ _  ___  _ __
 / _\(ga | \(aq__/ _ \e / _\(ga |/ _ \e| \(aq_ \e
| (_| | | | (_) | (_| | (_) | | | |
 \e__,_|_|  \e___/ \e__, |\e___/|_| |_|
                  |___/
drogon ctl tools
version:0.9.30.771
git commit:d4710d3da7ca9e73b881cbae3149c3a570da8de4
compile config:\-O3 \-DNDEBUG \-Wall \-std=c++17 \-I/root/drogon/trantor \-I/root/drogon/lib/inc \-I/root/drogon/orm_lib/inc \-I/usr/local/include \-I/usr/include/uuid \-I/usr/include \-I/usr/include/mysql
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Create sub command
.sp
The \fIcreate\fP subcommand is used to create various objects. It is currently the main function of drogon_ctl. Use the \fIdg_ctl help create\fP command to print detailed help for this command, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl help create

Use create command to create some source files of drogon webapp

Usage:drogon_ctl create <view|controller|filter|project|model> [\-options] <object name>

drogon_ctl create view <csp file name> //create HttpView source files from csp file

drogon_ctl create controller [\-s] <[namespace::]class_name> //create HttpSimpleController source files

drogon_ctl create controller \-h <[namespace::]class_name> //create HttpController source files

drogon_ctl create controller \-w <[namespace::]class_name> //create WebSocketController source files

drogon_ctl create filter <[namespace::]class_name> //create a filter named class_name

drogon_ctl create project <project_name> //create a project named project_name

drogon_ctl create model <model_path> //create model classes in model_path
.ft P
.fi
.UNINDENT
.UNINDENT
.SS View creation
.sp
The \fIdg_ctl create view\fP command is used to generate source files from csp files, see the View section. In general, this command does not need to be used directly. It is better practice to configure the cmake file to executed this command automatically. The command example is as follows, assuming the csp file is \fIUsersList.csp\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create view UsersList.csp
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Controller creation
.sp
The \fIdg_ctl create controller\fP command is used to help the user create the controller’s source files. The three controllers currently supported by drogon can be created by this command.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The command to create an HttpSimpleController is as follows:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller SimpleControllerTest
dg_ctl create controller webapp::v1::SimpleControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The last parameter is the controller’s class name, which can be prefixed by a namespace.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The command to create an HttpController is as follows:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller \-h ControllerTest
dg_ctl create controller \-h api::v1::ControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
The command to create a WebSocketController is as follows:
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller \-w WsControllerTest
dg_ctl create controller \-w api::v1::WsControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Filter creation
.sp
The \fIdg_ctl create filter\fP command is used to help the user create the source files for filters, see the Filter section.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create filter LoginFilter
dg_ctl create filter webapp::v1::LoginFilter
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Create project
.sp
The best way the user creates a new Drogon application project is via the drogon_ctl command, as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create project ProjectName
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the command is executed, a complete project directory will be created in the current directory. The directory name is \fIProjectName\fP, and the user can directly compile the project in the build directory (cmake .. && make). Of course, it does not have any business logic.
.sp
The directory structure of the project is as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
├── build                         Build folder
├── CMakeLists.txt                Project cmake configuration file
├── cmake_modules                 Cmake scripts for third\-party libraries lookup
│   ├── FindJsoncpp.cmake
│   ├── FindMySQL.cmake
│   ├── FindSQLite3.cmake
│   └── FindUUID.cmake
├── config.json                   The configuration file of the drogon application, please refer to the introduction section of the configuration file.
├── controllers                   The directory where the controller source files are stored
├── filters                       The directory where the filter files are stored
├── main.cc                       Main program
├── models                        The directory of the database model file, model source file creation see 11.2.5
│   └── model.json
└── views                         The directory where view csp files are stored, the source file does not need to be manually created by the user, and csp files are automatically preprocessed to obtain view source files when the project is compiled.
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Create models
.sp
Use the \fIdg_ctl create model\fP command to create database model source files. The last parameter is the directory where models is stored. This directory must contain a model configuration file named \fImodel.json\fP to tell dg_ctl how to connect to the database and which tables to be mapped.
.sp
For example, if you want to create models in the project directory mentioned above, execute the following command in the project directory:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create model models
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This command will prompt the user that the file will be overwritten directly. After the user enters y, it will generate all the model files.
.sp
Other source files need to reference model classes should include model header files, such as:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "models/User.h"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note that the models directory name is included to distinguish between multiple data sources in the same project. See ORM.
.UNINDENT
.UNINDENT
.SS Stress Testing
.sp
One can use the \fIdg_ctl press\fP command to do a stress testing, there are several options for this command.
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\-n num\fP Set the number of requests(default : 1)
.IP \(bu 2
\fI\-t num\fP Set the number of threads(default : 1), Set the number to the number of CPUs to achieve maximum performance
.IP \(bu 2
\fI\-c num\fP Set the number of concurrent connections(default : 1)
.IP \(bu 2
\fI\-q\fP No progress indication(default: no)
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For example, users can test an HTTP server as follows:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl press \-n1000000 \-t4 \-c1000 \-q http://localhost:8080/
dg_ctl press \-n 1000000 \-t 4 \-c 1000 https://www.domain.com/path/to/be/tested
.ft P
.fi
.UNINDENT
.UNINDENT
.SS AOP Aspect Oriented Programming
.sp
AOP(Aspect Oriented Programming) is a programming paradigm that aims to increase modularity by allowing the separation of cross\-cutting concerns(Quoted from Wikipedia).
.sp
Limited to the features of the C++ language, Drogon does not provide a flexible AOP solution like Spring, but a simple AOP in which all join points are predefined in the framework, and by using the framework’s AOP series interfaces, one can register handlers(called ‘advices’ in Drogon) onto specific join points.
.SS Predefined joinpoints
.sp
Drogon provides seven joinpoints for users. When the application runs to the joinpoints, the user\-registered handlers(Advices) are called one by one. The description of these joinpoints is as follows:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Beginning: As the name implies, the joinpoint is at the beginning of the program. Specifically, all handlers registered at this joinpoint are executed immediately after the app().run() method has finished initializaiton. At this joinpoint, all the controllers, filters, plugins, and database clients have been built completely, users can get the desired object reference or perform some other initialization work here. The advice on the joinpoint is only run once, the call signature of the adivice is \fIvoid()\fP, the registration interface is \fIregisterBeginningAdvice\fP;
.IP \(bu 2
NewConnection: Advices registered to this joinpoint are called when each new TCP connection is established. The call signature of the advice is \fIbool(const trantor::InetAddress &, const trantor::InetAddress &)\fP, where the first argument is the remote address of the TCP connection and the second one is the local address. Note that the return type is bool, if the user returns false, the corresponding connection will be disconnected. The registration interface is registerNewConnectionAdvice;
.IP \(bu 2
HttpResponseCreation: Advices registered to this joinpoint are called when each HTTP Response object is created. The call signature of the Advice is \fIvoid(const HttpResponsePtr &)\fP, where the parameter is the newly created object, and the user can perform some unified operations on all Responses with this joinpoint, such as adding a special header, etc. This joinpoint affects all Responses, including 404 or any drogon internal error response, and also including all responses generated by user’s application. The registration interface is \fIregisterHttpResponseCreationAdvice\fP;
.IP \(bu 2
Sync: This joinpoint is located at the front end of Http request processing. Users can intercept this request by returning a non\-empty Response object. The call signature of Advices is \fIHttpRequestPtr(const HttpRequestPtr &)\fP\&. The registration interface is \fI‘registerSyncAdvice’\fP\&.
.IP \(bu 2
Pre\-Routing: Advices registered to this joinpoint are called immediately after the request is created and before it matches any handler paths. Advices for the joinpoint have two call signatures, \fIvoid(const HttpRequestPtr &,AdviceCallback &&,AdviceChainCallback &&)\fP and \fIvoid(const HttpRequestPtr &)\fP, the previous one is exactly the same as the call signature of the filter’s \fIdoFilter\fP method. In fact, they all run in the same way (please refer to [05\-Filter]), users can intercept the client request or let it pass through this joinpoint. The advice with second call signature has no interception capability, but the overhead of it is lower, if the user does not intend to intercept requests, please select this kind of advices. The registration interface is \fIregisterPreRoutingAdvice\fP;
.IP \(bu 2
Post\-Routing: Advices registered to this joinpoint are called immediately after the request matchs a handler path, The call signatures of Advices are the same as the above joinpoint’s. The registration interface is \fIregisterPostRoutingAdvice\fP;
.IP \(bu 2
Pre\-Handling: Advices registered to this joinpoint are called immediately after the request is approved by all filters and before it is handled, The call signatures of Advices are the same as the above joinpoint’s. The registration interface is \fIregisterPostRoutingAdvice\fP;
.IP \(bu 2
Post\-Handling: Advices registered to this joinpoint are called immediately after the request is handled and a response object is created by the handler, The call signature of Advices is \fIvoid(const HttpRequestPtr &, const HttpResponsePtr &)\fP, The registration interface is \fIregisterPostHandlingAdvice\fP;
.UNINDENT
.UNINDENT
.UNINDENT
.SS AOP schematic
.sp
The following figure shows the location of the above four joinpoints in the HTTP Requests processing flow, where the red dots represent the joinpoints and the green arrows represent the asynchronous calls.
.SS Benchmarks
.sp
As a C++ Http application framework, performance should be one of the focus of attention. This section introduces Drogon’s simple tests and achievements;
.SS Test environment
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
The system is Linux CentOS 7.4;
.IP \(bu 2
The device is a Dell server, the CPU is two Intel(R) Xeon(R) CPUs E5\-2670 @ 2.60GHz, 16 cores and 32 threads;
.IP \(bu 2
Memory 64GB;
.IP \(bu 2
gcc version 7.3.0;
.UNINDENT
.UNINDENT
.UNINDENT
.SS Test plan and results
.sp
We just want to test the performance of the drogon framework, so we want to simplify the controller’s processing as much as possible. We only do an HttpSimpleController and register it on the \fI/benchmark\fP path. The controller returns \fI<p>Hello, world!</p>\fP for any request. Set the number of drogon threads to 16. The processing function is as follows and you can find the source code at the \fIdrogon/examples/benchmark\fP path:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void BenchmarkCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req, std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
    auto resp = HttpResponse::newHttpResponse();
    resp\->setBody("<p>Hello, world!</p>");
    resp\->setExpiredTime(0);
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
For comparison, I chose nginx for comparison testing, wrote a \fIhello_world_module\fP, and compiled it with the nginx source. The nginx worker_processes parameter is set to 16.
.sp
The test tool is \fIhttpress\fP, a good performance HTTP stress test tool.
.sp
We adjust the parameters of httpress, test each set of parameters five times, and record the maximum and minimum values ​of the number of requests processed per second. The test results are as follows:
.TS
center;
|l|l|l|l|.
_
T{
Command line
T}	T{
Description
T}	T{
T}	T{
Drogon(kQPS)   nginx(kQPS)
T}
_
T{
httpress \-c 100 \-n 1000000 \-t 16 \-k \-q URL
T}	T{
100 connections, 1 million requests, 16 threads,Keep\-Alive
T}	T{
561/552
T}	T{
330/329
T}
_
T{
httpress \-c 100 \-n 1000000 \-t 12 \-q URL
T}	T{
100 connections, 1 million requests, 12 threads, no Keep\-Alive
T}	T{
140/135
T}	T{
31/49
T}
_
T{
httpress \-c 1000 \-n 1000000 \-t 16 \-k \-q URL
T}	T{
1000 connections, 1 million requests, 16 threads,Keep\-Alive
T}	T{
573/565
T}	T{
333/327
T}
_
T{
httpress \-c 1000 \-n 1000000 \-t 16 \-q URL
T}	T{
1000 connections, 1 million requests, 16 threads,no Keep\-Alive
T}	T{
155/143
T}	T{
52/50
T}
_
T{
httpress \-c 10000 \-n 4000000 \-t 16 \-k \-q URL
T}	T{
10000 connections, 4 million requests, 16 threads,Keep\-Alive
T}	T{
512/508
T}	T{
316/314
T}
_
T{
httpress \-c 10000 \-n 1000000 \-t 16 \-q URL
T}	T{
10000 connections, 1 million requests, 16 threads,no Keep\-Alive
T}	T{
143/141
T}	T{
43/40
T}
_
.TE
.sp
As you can see, using the Keep\-Alive option on the client side, drogon can process more than 500,000 requests per second in the case where a connection can send multiple requests. This score is quite good. In the case that each request initiates a connection, CPU time will be spent on TCP connection establishment and disconnection, and the throughput will drop to 140,000 requests per second, which is reasonable.
.sp
It’s easy to see that drogon has a clear advantage over nginx in the above test. If someone does a more accurate test, please correct me.
.sp
The image below is a screenshot of a test:
.sp
Test Result
.SS Coz
.SS Causal profiling with coz
.sp
With coz you can profile two things:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
throughput
.IP \(bu 2
latency
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If you want to profile throughput of your application, you should switch on the \fICOZ_PROFILING\fP cmake option and include debug information in your exectuable with \fIDebug\fP or \fIRelWithDebInfo\fP release modes in cmake. Doing so will include coz progress points when serving a request. Profiling latency is currently not supported in whole application scope, but can still be done in user code.
.sp
When you’re done compiling you application with progress points included. You need to run the executable with the coz profiler, for example \fIcoz run — [path to your executable]\fP\&.
.sp
Lastly, the application needs to be stressed, for best results you need to stress all code paths and run the profile for a good amount of time, 15+ min.
.sp
The final profile will be a \fIprofile.coz\fP file created in the current working directory. To view results, open the profile in the official \fI\%viewer\fP , or you could run a local copy from the official \fI\%git repo\fP .
.sp
Coz also supports scoping source files included for the profile with –source\-scope <pattern> or \-s <pattern> among other things, that should prove useful.
.sp
For more information checkout:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
coz run –help
.IP \(bu 2
\fI\%Git repo\fP
.IP \(bu 2
\fI\%Coz whitepaper\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SH 中文文档
.SS Drogon 中文文档索引
.SS Overview
.sp

.nf
*
.fi
Drogon*是一个基于C++14/17的Http应用框架，使用Drogon可以方便的使用C++构建各种类型的Web应用服务端程序。
.sp

.nf
*
.fi
Drogon*的主要应用平台是Linux，也支持Mac OS、FreeBSD和Windows。
.sp
它的主要特点如下：
.INDENT 0.0
.IP \(bu 2
网络层使用基于epoll(macOS/FreeBSD下是kqueue)的非阻塞IO框架，提供高并发、高性能的网络IO。详细请见TFB Tests Results；
.IP \(bu 2
全异步编程模式；
.IP \(bu 2
支持Http1.0/1.1(server端和client端)；
.IP \(bu 2
基于template实现了简单的反射机制，使主程序框架、控制器(controller)和视图(view)完全解耦；
.IP \(bu 2
支持cookies和内建的session；
.IP \(bu 2
支持后端渲染，把控制器生成的数据交给视图生成Html页面，视图由CSP模板文件描述，通过CSP标签把C++代码嵌入到Html页面，由drogon的命令行工具在编译阶段自动生成C++代码并编译；
.IP \(bu 2
支持运行期的视图页面动态加载(动态编译和加载so文件)；
.IP \(bu 2
非常方便灵活的路径(path)到控制器处理函数(handler)的映射方案；
.IP \(bu 2
支持过滤器(filter)链，方便在控制器之前执行统一的逻辑(如登录验证、Http Method约束验证等)；
.IP \(bu 2
支持https(基于OpenSSL实现);
.IP \(bu 2
支持websocket(server端和client端);
.IP \(bu 2
支持Json格式请求和应答, 对Restful API应用开发非常友好;
.IP \(bu 2
支持文件下载和上传,支持sendfile系统调用；
.IP \(bu 2
支持gzip/brotli压缩传输；
.IP \(bu 2
支持pipelining；
.IP \(bu 2
提供一个轻量的命令行工具drogon_ctl，帮助简化各种类的创建和视图代码的生成过程；
.IP \(bu 2
基于非阻塞IO实现的异步数据库读写，目前支持PostgreSQL和MySQL(MariaDB)数据库；
.IP \(bu 2
基于线程池实现sqlite3数据库的异步读写，提供与上文数据库相同的接口；
.IP \(bu 2
支持ARM架构；
.IP \(bu 2
方便的轻量级ORM实现，支持常规的对象到数据库的双向映射操作；
.IP \(bu 2
支持插件，可通过配置文件在加载期动态拆装；
.IP \(bu 2
支持内建插入点的AOP
.UNINDENT
.SS Installation
.sp
本节以Linux为例，简介安装过程，其它系统，大同小异
.SS 系统要求
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Linux内核应不低于2.6.9，64位版本；
.IP \(bu 2
gcc版本不低于5.4.0；
.IP \(bu 2
构建工具是cmake,cmake版本应不低于3.5；
.IP \(bu 2
git版本管理工具；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 依赖库
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
trantor，non\-blocking I/O C++网络库，也是作者开发，已作为git仓库submodule，无需提前安装；
.IP \(bu 2
jsoncpp，json的c++库，版本不低于1.7；
.IP \(bu 2
libuuid，生成uuid的c库；
.IP \(bu 2
zlib，用于支持压缩传输；
.IP \(bu 2
OpenSSL，并非必须，如果安装了OpenSSL库，drogon将支持HTTPS，否则drogon只支持HTTP；
.IP \(bu 2
c\-ares, 并非必须，如果安装了ares库，drogon对DNS的支持会具有更好的性能；
.IP \(bu 2
libbrotli，并非必须，如果安装了brotli库，drogon的HTTP响应会支持brotli压缩；
.IP \(bu 2
boost，版本不低于1.61，只在C++编译器不支持c++17时才需要安装；
.IP \(bu 2
postgreSQL, mariadb, sqlite3的客户端开发库，并非必须，安装后drogon会提供对响应的库的访问能力；
.IP \(bu 2
gtest, 并非必须，如果安装了gtest库，drogon的单元测试代码可以被编译；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 系统准备范例
.SS Ubuntu 18.04
.sp
环境
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install git
sudo apt install gcc
sudo apt install g++
sudo apt install cmake
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
jsoncpp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install libjsoncpp\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
uuid
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install uuid\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
OpenSSL
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install openssl
sudo apt install libssl\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
zlib
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sudo apt install zlib1g\-dev
.ft P
.fi
.UNINDENT
.UNINDENT
.SS CentOS 7.5
.sp
环境
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install git
yum install gcc
yum install gcc\-c++
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
默认安装的cmake版本太低，使用源码安装
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/Kitware/CMake
cd CMake/
\&./bootstrap && make && make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
升级gcc
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install centos\-release\-scl
yum install devtoolset\-8
scl enable devtoolset\-8 bash
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: \fIscl enable devtoolset\-8\fP bash命令仅是临时性的使新的gcc生效，直到会话结束。如果想永久使用新版gcc,可以使用命令*echo “scl enable devtoolset\-8 bash” >> ~/.bash_profile*, 系统重新启动后将自动使用新版gcc。
.UNINDENT
.UNINDENT
.sp
jsoncpp
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/open\-source\-parsers/jsoncpp
cd jsoncpp/
mkdir build
cd build
cmake ..
make && make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
uuid
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install libuuid\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
OpenSSL
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install openssl\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
zlib
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
yum install zlib\-devel
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 数据库环境
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：下面的这些库都不是必须的, 用户可以根据实际需求选择安装一个或者多个数据库。
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：如果将来的开发需要用到数据库，请先安装好数据库环境，再安装drogon, 否则，会出现找不到数据库的问题。
.UNINDENT
.UNINDENT
.SS PostgreSQL
.sp
PostgreSQL的原生C库libpq是需要安装的，安装方法如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu 16: sudo apt\-get install postgresql\-server\-dev\-all
.IP \(bu 2
ubuntu 18: sudo apt\-get install postgresql\-all
.IP \(bu 2
centOS 7: yum install postgresql\-devel
.IP \(bu 2
MacOS: brew install postgresql
.UNINDENT
.UNINDENT
.UNINDENT
.SS MySQL
.sp
MySQL的原生库不支持异步读写，而通过同步接口+线程池的方式对上层提供异步接口并不是一个好的策略，幸好，MySQL还有一个原开发者社区维护的版本MariaDB，该版本和MySQL的对应版本兼容，并且它的开发库支持异步读写，因此，Drogon的MySQL支持采用MariaDB开发库，你的系统，Mysql和MariaDB最好不要混用，可以统一安装成MariaDB。
.sp
安装方法如下:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu: sudo apt install libmariadbclient\-dev
.IP \(bu 2
centOS 7: yum install mariadb\-devel
.IP \(bu 2
MacOS: brew install mariadb
.UNINDENT
.UNINDENT
.UNINDENT
.SS Sqlite3
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
ubuntu: sudo apt\-get install libsqlite3\-dev
.IP \(bu 2
centOS: yum install sqlite\-devel
.IP \(bu 2
MacOS: brew install sqlite3
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 上述有些命令只安装了开发库，如果还要安装server端，请自行google。
.UNINDENT
.UNINDENT
.SS 安装drogon
.sp
假设上述系统环境和库依赖都已经准备好，安装过程是非常简单的；
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd $WORK_PATH
git clone https://github.com/an\-tao/drogon
cd drogon
git submodule update \-\-init
mkdir build
cd build
cmake ..
make && sudo make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
默认是编译debug版本，如果想编译release版本，cmake命令要带如下参数：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cmake \-DCMAKE_BUILD_TYPE=Release ..
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
安装结束后，将有如下文件被安装在系统中(CMAKE_INSTALL_PREFIX可以改变安装位置)：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
drogon的头文件被安装到/usr/local/include/drogon中；
.IP \(bu 2
drogon的库文件libdrogon.a被安装到/usr/local/lib中；
.IP \(bu 2
drogon的命令行工具drogon_ctl被安装到/usr/local/bin中；
.IP \(bu 2
trantor的头文件被安装到/usr/local/include/trantor中；
.IP \(bu 2
trantor的库文件libtrantor.a被安装到/usr/local/lib中；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 直接使用drogon源码
.sp
当然，你也可以在你的项目中包含drogon源码，比如将drogon放置在你的项目目录的third_party下，那么，你只需要在你项目的cmake文件里添加如下两行：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
add_subdirectory(third_party/drogon)
target_link_libraries(${PROJECT_NAME} PRIVATE drogon)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 使用vcpkg安装
.sp
The easiest way to install drogon on windows is to use vcpkg
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vcpkg.exe install drogon
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
或者
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vcpkg.exe install drogon:x64\-windows
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 使用docker镜像
.sp
我们也在 \fI\%docker hub\fP . 上提供了构建好的docker镜像. 在这个docker里Drogon和它所有的依赖都已经安装完毕，用户可以在上面直接开发Drogon应用程序。
.SS 快速开始
.SS 静态网站
.sp
我们从一个最简单的例子开始，介绍drogon的使用，在这个例子中我们使用命令行工具*drogon_ctl*创建一个工程：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create project your_project_name
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
进入工程目录，可以看到如下文件:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
├── build                         构建文件夹
├── CMakeLists.txt                工程的cmake配置文件
├── config.json                   drogon应用的配置文件
├── controllers                   存放控制器文件的目录
├── filters                       存放过滤器文件的目录
├── main.cc                       主程序
├── models                        数据库模型文件的目录
│   └── model.json
└── views                         存放视图csp文件的目录
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
文件夹的名字就反应了它的用途，用户可以把各类文件(如控制器、过滤器、视图等等)分别放入对应的文件夹，方便项目管理，请读者自行实验。关于drogon_ctl的详细使用，可参见 drogon_ctl。
.sp
让我们看一下main.cc文件，内容如下：
\fImain.cpp\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <drogon/HttpAppFramework.h>
int main() {
    //Set HTTP listener address and port
    drogon::app().addListener("0.0.0.0",80);
    //Load config file
    //drogon::app().loadConfigFile("../config.json");
    //Run HTTP framework,the method will block in the internal event loop
    drogon::app().run();
    return 0;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
然后构建项目:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd build
cmake ..
make
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
编译完成后，运行目标程序 \fI\&./your_project_name\fP\&.
.sp
现在，我们在Http根目录添加一个最简单的静态文件index.html:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
echo \(aq<h1>Hello Drogon!</h1>\(aq >>index.html
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Http根目录默认值是*”./”
.nf
*
.fi
， 也就是webapp程序运行的当前路径， Http根目录也可在config.json配置文件中进行更改，可参见配置文件， 然后在地址栏输入*http://localhost*或*http://localhost/index.html*(或者你的webapp所在服务器的ip)可以访问到这个页面
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
Hello Drogon!
.UNINDENT
.UNINDENT
.sp
If server cannot find the the page you have requested, it return 404 page: 404 page
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：请确认服务器的防火墙已经打开80端口，否则你看不到这些页面。
.UNINDENT
.UNINDENT
.sp
我们可以把一个静态网站的目录和文件复制到这个webapp的运行目录，然后通过浏览器就可以访问到它们，drogon默认支持的文件类型有”html”,”js”,”css”,”xml”,”xsl”,”txt”,”svg”,”ttf”,”otf”,”woff2”,”woff”,”eot”,”png”,”jpg”,”jpeg”,”gif”,”bmp”,”ico”,”icns”等等，drogon也提供接口更改这些文件类型，具体请参考HttpAppFramework的API。
.SS 动态网站
.sp
下面我们看看怎么给这个应用添加控制器（controller）,并使用控制器（controller）输出内容。
.sp
在controller目录下运行drogon_ctl命令行工具生成控制器（controller）源文件:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller TestCtrl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可以看到，目录下新增加了两个文件，TestCtrl.h和TestCtrl.cc:
.sp
TestCtrl.h如下：
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
TestCtrl.cc如下：
\fITestCtrl.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
我们编辑一下这两个文件，让这个控制器处理函数回应一个简单的“Hello World!”。
.sp
TestCtrl.h如下：
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_ADD("/",Get,Post);
    PATH_ADD("/test",Get);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
使用PATH_ADD添加路径到处理函数的映射，这里映射了两个路径’/’和’/test’,并在路径后面添加了对这个路径的约束。
.sp
TestCtrl.cc如下：
\fITestCtrl.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
    auto resp=HttpResponse::newHttpResponse();
    resp\->setStatusCode(k200OK);
    resp\->setContentTypeCode(CT_TEXT_HTML);
    resp\->setBody("Hello World!");
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
重新用cmake编译这个工程，然后运行目标程序./your_project_name：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd ../build
cmake ..
make
\&./your_project_name
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
在浏览器地址栏输入*http://localhost/\fI或者*http://localhost/test\fP，你就可以在浏览器看到Hello World!了。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 同时存在静态和动态资源的情况下，框架优先使用控制器响应请求，此例中*http://localhost/* 响应的是TestCtrl控制器的输出Hello Word！而不是静态网页index.html的Hello Drogon！
.UNINDENT
.UNINDENT
.sp
我们看到，在应用中添加controller非常简单，只需要添加对应的源文件即可，甚至main文件不用做任何修改，这种低耦合度的设计对web应用开发是非常有效的。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: Drogon没有限制控制器（controller）源文件的位置，也可以放在工程目录下，甚至可以在CMakeLists.txt中指定到新的目录中，为了方便管理，建议将控制器源文件放在controllers目录。
.UNINDENT
.UNINDENT
.SS 控制器 简介
.SS 简介
.sp
控制器(controller)在web应用开发中处于相当重要的地位，它处理浏览器发来的请求，然后生成响应发送给浏览器；drogon框架已经帮我们处理好网络传输、Http协议的解析等等细节，我们只需要关注控制器的逻辑即可；每一个控制器对象可以有一个或者多个处理函数(一般称为handler)，函数的接口，一般定义成如下形式：
.INDENT 0.0
.TP
.B Void handlerName(const HttpRequestPtr &\fIreq\fP, std::function<void(const HttpResponsePtr&)> &&\fIcallback\fP, \&...) 
.UNINDENT
.sp
其中，
.nf
*
.fi
req*是Http请求的对象(被智能指针包裹)，
.nf
*
.fi
callback*是框架传给控制器的回调函数对象，控制器生成应答对象(也通过智能指针包裹)后，通过callback把该对象传给drogon，然后框架会帮你把响应内容发送给浏览器，最后面的是若干参数列表…，由drogon根据映射规则把Http请求中的参数映射到对应的handler的形参上，这是对应用开发是非常方便的。
.sp
很明显，这是个异步接口，用户可以在其它线程完成耗时操作后再调用callback；
.sp
drogon的控制器分为三种类型，\fIHttpSimpleController\fP,*HttpController*和*WebSocketController*，用户使用时，需要继承相应的类模板，比如，一个HttpSimpleController的自定义类”MyClass”声明如下：
\fIMyClass.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class MyClass:public drogon::HttpSimpleController<MyClass>
{
public:
    //TestController(){}
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback) override;

    PATH_LIST_BEGIN
    PATH_ADD("/json");
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 控制器的生命周期
.sp
注册到drogon框架的控制器最多只会有一个实例，在整个应用运行期间都不会销毁，所以，用户可以在控制器类中声明和使用成员变量。注意，控制器的handler被调用时，是在多线程环境下的（当框架的IO线程数配置成大于1的值时），如果需要访问非临时变量，请做好并发保护工作。
.SS 控制器 HttpSimpleController
.sp
可以由*drogon_ctl*命令行工具快速生成基于*HttpSimpleController*的自定义类的源文件，命令格式如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
我们创建一个名称为*TestCtrl*的控制器：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller TestCtrl
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可以看到，目录下新增加了两个文件，TestCtrl.h和TestCtrl.cc，下面阐述一下这两个文件。
\fBTestCtrl.h：\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpSimpleController.h>
using namespace drogon;
class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
{
public:
    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
    PATH_LIST_BEGIN
    //list path definitions here;
    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
    PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fBTestCtrl.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TestCtrl.h"
void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                    std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
每个HttpSimpleController类只能定义一个Http请求处理函数(handler)，而且通过虚函数重载定义。
.sp
从URL路径到处理函数的路由(或称映射)由宏完成，可以用*PATH_ADD*宏添加多重路径映射，所有*PATH_ADD*语句应夹在*PATH_LIST_BEGIN*和*PATH_LIST_END*宏语句之间。
.sp
第一个参数是映射的路径,路径后面的参数是对这个路径的约束，目前支持两种约束，一种是HttpMethod类型，表示该路径允许使用的Http方法，可以配置零个或多个，一种是HttpFilter类的名字，这种对象执行特定的过滤操作，也可以配置0个或多个，两种类型没有顺序要求，框架会处理好类型的匹配。关于Filter，请参阅过滤器Filter.
.sp
用户可以把同一个Simple Controller注册到多个路径上，也可以在同一个路径上注册多个Simple Controller（通过HTTP method区分）。
.sp
你可以定义一个HttpResponse类的变量，然后使用callback()返回这个变量即可:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//write your application logic here
auto resp=HttpResponse::newHttpResponse();
resp\->setStatusCode(k200OK);
resp\->setContentTypeCode(CT_TEXT_HTML);
resp\->setBody("Your Page Contents");
callback(resp);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fB上述路径到处理函数的映射是在编译期完成的，事实上，drogon框架也提供了运行期完成映射的接口，运行期映射可以让用户通过配置文件或其它用户接口完成映射或修改映射关系而无需重新编译这个程序(出于性能的考虑，禁止在运行app().run()之后再注册任何映射)。\fP
.SS HttpController 控制器
.SS 生成
.sp
可以由drogon_ctl命令行工具快速生成基于HttpController的自定义类的源文件，命令格式如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-h <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
我们创建一个位于demo v1名称空间内且名称为User的控制器：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-h demo::v1::User
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可以看到，目录下新增加了两个文件，demo_v1_User.h和demo_v1_User.cc:
\fIdemo_v1_User.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpController.h>
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController<User>
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
        };
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
demo_v1_User.cc is as follows:
\fIdemo_v1_User.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 使用
.sp
我们编辑一下这两个文件，然后再阐述它们。
\fIdemo_v1_User.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/HttpController.h>
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController<User>
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
                METHOD_ADD(User::login,"/token?userId={1}&passwd={2}",Post);
                METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get);
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
            void login(const HttpRequestPtr &req,
                    std::function<void (const HttpResponsePtr &)> &&callback,
                    std::string &&userId,
                    const std::string &password);
            void getInfo(const HttpRequestPtr &req,
                        std::function<void (const HttpResponsePtr &)> &&callback,
                        std::string userId,
                        const std::string &token) const;
        };
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
\fIdemo_v1_User.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here

void User::login(const HttpRequestPtr &req,
        std::function<void (const HttpResponsePtr &)> &&callback,
        std::string &&userId,
        const std::string &password)
{
    LOG_DEBUG<<"User "<<userId<<" login";
    //Authentication algorithm, read database, verify identity, etc...
    //...
    Json::Value ret;
    ret["result"]="ok";
    ret["token"]=drogon::utils::getUuid();
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}
void User::getInfo(const HttpRequestPtr &req,
            std::function<void (const HttpResponsePtr &)> &&callback,
            std::string userId,
            const std::string &token) const
{
    LOG_DEBUG<<"User "<<userId<<" get his information";

    //Verify the validity of the token, etc.
    //Read the database or cache to get user information
    Json::Value ret;
    ret["result"]="ok";
    ret["user_name"]="Jack";
    ret["user_id"]=userId;
    ret["gender"]=1;
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
每个*HttpController*类可以定义多个Http请求处理函数(handler)，由于函数数目可以任意多，所以通过虚函数重载是不现实的，我们需要把处理函数本身(而不是类)注册到框架里去。
.sp
从URL路径到处理函数的映射由宏完成，可以用*METHOD_ADD*宏或*ADD_METHOD_TO*宏添加多重路径映射，所有*METHOD_ADD*和*ADD_METHOD_TO*语句应夹在*METHOD_LIST_BEGIN*和*METHOD_LIST_END*宏语句之间。
.sp
\fIMETHOD_ADD*宏会在路径映射中自动把**名字空间和类名**作为路径的前缀，所以，本例子中，login函数，被注册到了\fP/demo/v1/user/token*路径上，getInfo函数被注册到了*/demo/v1/user/xxx/info*路径上。后面的约束跟HttpSimpleController的PATH_ADD宏类似，不再赘述。
.sp
如果使用了自动的前缀，访问地址要包含命名空间和类名，此例中要使用*http://localhost/demo/v1/user/token?userid=xxx&passwd=xxx*或者*http://localhost/demo/v1/user/xxxxx/info?token=xxxx*来访问。
.sp

.nf
*
.fi
ADD_METHOD_TO*宏的作用与前者几乎一样，除了它不会自动添加任何前缀，即这个宏注册的路径是一个绝对路径。
.sp
我们看到，
.nf
*
.fi
HttpController*提供了更为灵活的路径映射功能，并且可以注册多个处理函数，我们可以把一类功能放在一个类里。
.sp
另外可以看到，
.nf
*
.fi
METHOD_ADD*宏提供了参数映射的方法，我们可以把路径上的参数映射到函数的参数表里，由参数的数码对应形参的位置，非常方便，常见的可以由字符串类型转换的类型都可以作为参数(如std::string,int,float,double等等)，框架基于模板的类型推断会自动帮你转换类型，非常方便。注意左值引用必须是const类型。
.sp
同一个路径还可以注册多次，相互之间通过Http Method区分，这是合法的，并且是Restful API的通常做法，比如:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
METHOD_LIST_BEGIN
    METHOD_ADD(Book::getInfo,"/{1}?detail={2}",Get);
    METHOD_ADD(Book::newBook,"/{1}",Post);
    METHOD_ADD(Book::deleteOne,"/{1}",Delete);
METHOD_LIST_END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
路径参数的占位符有多种写法:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
{}: 表示这个路径参数映射到处理函数的对应位置上，路径上的位置就是函数参数的位置。
.IP \(bu 2
{1},{2}: 中间有个数字的，表示映射到数字指定的处理函数参数上。
.IP \(bu 2
{anystring}: 中间的字符串没有实际作用，但可以提高程序的可读性，与{}等价。
.IP \(bu 2
{1:anystring},{2:xxx}: 冒号前的数字表示位置，后面的字符串没有实际作用，但可以提高程序的可读性，与{1},{2}等价
.UNINDENT
.UNINDENT
.UNINDENT
.sp
推荐使用后两种写法，如果路径参数和函数参数顺序一直，使用第三种写法即可。容易知道，以下几种写法是等价的：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
“/users/{}/books/{}”
.IP \(bu 2
“/users/{}/books/{2}”
.IP \(bu 2
“/users/{user_id}/books/{book_id}”
.IP \(bu 2
“/users/{1:user_id}/books/{2}”
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：路径匹配大小写不敏感，参数名字大小写敏感，参数值大小写保持原貌
.UNINDENT
.UNINDENT
.SS 参数映射
.sp
通过前面的叙述我们知道，路径上的参数和问号后面的请求参数都可以映射到处理函数的参数列表里，目标参数的类型需要满足如下条件：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
必须是值类型、常左值引用或非const右值引用中的一种，不能是非const的左值引用，推荐使用右值引用，这样用户可以随意处置它；
.IP \(bu 2
int, long, long long, unsigned long, unsigned long long, float, double, long double等基础类型都可以作为参数类型；
.IP \(bu 2
std::string类型；
.IP \(bu 2
任何可以使用*stringstream >>*操作符赋值的类型；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fI另外，drogon框架还提供了从HttpRequestPtr对象到任意类型的参数的映射机制\fP，当你的handler参数列表中映射参数的数量多于路径上的参数时，后面多余的参数将由HttpRequestPtr对象转换得到，用户可以定义任意类型的转换，定义这种转换的方式是特化drogon命名空间的fromRequest模板(定义于HttpRequest.h头文件))，比如我们需要做一个创建新用户的RESTful的接口，我们定义用户的结构体如下:
\fImyapp_User_drogon.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
namespace myapp{
struct User{
    std::string userName;
    std::string email;
    std::string address;
};
}
namespace drogon
{
template <>
inline myapp::User fromRequest(const HttpRequest &req)
{
    auto json = req.getJsonObject();
    myapp::User user;
    if(json)
    {
        user.userName = (*json)["name"].asString();
        user.email = (*json)["email"].asString();
        user.address = (*json)["address"].asString();
    }
    return user;
}

}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
有了上面的定义和模板特化，我们就可以向下面这样定义路径和handler:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
\&.. code\-block:: cpp
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B caption
\fBUserController.cc\fP
.UNINDENT
.sp
class UserController:public drogon::HttpController<UserController>
{
public:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B METHOD_LIST_BEGIN
//use METHOD_ADD to add your custom processing function here;
ADD_METHOD_TO(UserController::newUser,”/users”,Post);
.UNINDENT
.sp
METHOD_LIST_END
//your declaration of processing function maybe like this:
void newUser(const HttpRequestPtr &req,
.INDENT 0.0
.INDENT 3.5
std::function<void (const HttpResponsePtr &)> &&callback,
myapp::User &&pNewUser) const;
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
};
.UNINDENT
.UNINDENT
.sp
可以看到，第三个*myapp::User*类型的参数在映射路径上没有对应的占位符，框架会将它视为由*req*对象转换的参数，通过用户特化的函数模板得到这个参数，这都是drogon通过模板推导自动在编译期完成的，为用户的开发提供了极大便利。
.sp
更进一步，有些用户除了他们自定义类型的数据外，并不需要访问HttpRequestPtr对象，那么他可以把这个自定义的对象放在第一个参数的位置，框架也能正确完成映射，比如上面的例子也可以写成下面这样:
\fIUserController.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class UserController:public drogon::HttpController<UserController>
{
public:
    METHOD_LIST_BEGIN
        //use METHOD_ADD to add your custom processing function here;
        ADD_METHOD_TO(UserController::newUser,"/users",Post);
    METHOD_LIST_END
    //your declaration of processing function maybe like this:
    void newUser(myapp::User &&pNewUser,
                std::function<void (const HttpResponsePtr &)> &&callback) const;
};
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 多路径映射
.sp
drogon支持在路径映射中使用正则表达式，在{}花括号以外的部分可以有限制的使用，比如:
.sp
ADD_METHOD_TO(UserController::handler1,”/users/.*”,Post); /// Match any path prefixed with \fI/users/\fP
ADD_METHOD_TO(UserController::handler2,”/{name}/[0\-9]+”,Post); ///Match any path composed with a name string and a number.
.sp
这种方法不支持子表达式，负向匹配等正则表达式，如果想使用他们，请用如下的方案。
.SS 正则表达式
.sp
上面的方法对正则表达式的支持比较有限，如果用户想自由使用正则表达式，drogon提供了ADD_METHOD_VIA_REGEX宏来实现这一点，比如:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
ADD_METHOD_VIA_REGEX(UserController::handler1,"/users/(.*)",Post); /// Match any path prefixed with \(ga/users/\(ga and map the rest of the path to a parameter of the handler1.
ADD_METHOD_VIA_REGEX(UserController::handler2,"/.*([0\-9]*)",Post); /// Matche any path that ends in a number and map that number to a parameter of the handler2.
ADD_METHOD_VIA_REGEX(UserController::handler3,"/(?!data).*",Post); /// Matches any path that does not start with \(aq/data\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可以看到，使用正则表达式也可以完成参数映射，所有子表达式匹配的字符串都会按顺序映射到handler的参数上。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
需要注意的是，使用正则表达式要注意匹配冲突（多个不同的handler都匹配），当冲突发生在同一个controller内部时，drogon只会执行第一个handler（先注册进框架的那个handler），当冲突发生在不同controller之间时，执行哪个handler是不确定的，因此用户需要避免这种冲突发生。
.UNINDENT
.UNINDENT
.SS 控制器 WebSocketController
.SS WebSocketController
.sp
顾名思义，
.nf
*
.fi
WebSocketController*用于处理websocket逻辑。websocket是基于HTTP的一种长连接方案，在websocket建立之初，有一次HTTP格式的请求和应答交换，建立完成后，所有的消息在websocket上传输，消息由固定的格式包装，但消息的内容和收发次序没有任何要求，完全由用户定义。
.sp
可以由*drogon_ctl*工具快速生成*WebSocketController*的源文件，命令格式如下：:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-w <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
假设我们要通过websocket实现一个简单的回声功能，即服务端只是简单的把客户端发来的消息再发回去，通过drogon_ctl创建WebSocketController的实现类EchoWebsock，如下:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create controller \-w EchoWebsock
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
该命令会生成EchoWebsock.h和EchoWebsock.cc两个文件，
\fIEchoWebsock.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/WebSocketController.h>
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                std::string &&)override;
    virtual void handleNewConnection(const HttpRequestPtr &,
                                    const WebSocketConnectionPtr&)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fIEchoWebsock.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
{
    //write your application logic here
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
编辑后内容如下：
\fIEchoWebsock.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#pragma once
#include <drogon/WebSocketController.h>
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                std::string &&)override;
    virtual void handleNewConnection(const HttpRequestPtr &,
                                    const WebSocketConnectionPtr&)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_ADD("/echo");
    WS_PATH_LIST_END
};
.ft P
.fi
.UNINDENT
.UNINDENT
\fIEchoWebsock.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
{
    //write your application logic here
    wsConnPtr\->send(message);
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
{
    //write your application logic here
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
首先，在这个例子中，通过*WS_PATH_ADD*宏把这个控制器注册到了*/echo*路径上，
.nf
*
.fi
WS_PATH_ADD*宏的用法跟之前介绍的其他控制器的宏类似，也可以注册路径并且附带若干过滤器Filter。由于websocket在框架中单独处理，所以它可以和前两种控制器的路径重复而不会相互影响。
.sp
其次，本例中三个虚函数的实现，只有handleNewMessage有实质内容，只是简单的把收到的消息通过send接口发回客户端。把这个控制器编译进框架，就可以看到效果，请各位自己试验吧。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：和通常的HTTP协议一样，http的websocket可以被旁路还原，如果需要安全保障，应由https提供加密功能，当然，用户自己在服务端和客户端完成加密和解密也是可以的，只是https更方便，底层都由drogon处理，用户只需关心业务逻辑。
.UNINDENT
.UNINDENT
.sp
用户自定义的WebSocketController类继承自drogon::WebSocketController类模板，模板参数是子类类型，用户需自己实现如下三个虚函数来对websocket的建立、关闭和消息进行处理：
.sp
容易知道:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
handleNewConnection is called after the websocket is established. req is the setup request sent by the client. At this time, the framework has returned the response. What users can do is to get some additional information through req, such as token. wsConn is a smart pointer to this websocket object, and the commonly used interface will be discussed later.
.IP \(bu 2
handleNewMessage is called after the websocket receives the new message. The message is stored in the message variable. Note that the message is the message payload. The framework has finished the decapsulation and decoding of the message. The user can directly process the message itself.
.IP \(bu 2
handleConnectionClosed is called after the websocket connection is closed, and the user can do some finishing work.
.UNINDENT
.UNINDENT
.UNINDENT
.SS WebSocketConnection
.sp
WebSocketConnection对象常用接口如下：
\fIWebSocketConnection.h\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
//发送websocket消息，消息的编码和封包都由框架负责，这里直接发送消息的净荷
//of the message are the responsibility of the framework
void send(const char *msg,uint64_t len);
void send(const std::string &msg);

//本websocket的本端和远端地址
const trantor::InetAddress &localAddr() const;
const trantor::InetAddress &peerAddr() const;

//本weosocket的连接状态
bool connected() const;
bool disconnected() const;

//关闭本websocket
void shutdown();//close write
void forceClose();//close

//设置和获取本websocket的上下文，由用户存入一些业务数据，
//any类型意味着可以存取任意类型的对象。
void setContext(const any &context);
const any &getContext() const;
any *getMutableContext();
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 过滤器
.sp
过滤器(filter)可以帮助用户提高编程效率，在HttpController的例子中，getInfo方法在返回用户信息之前应该先校验用户是否登录，我们把这个逻辑写在getInfo方法里当然是可以的，但是，很显然，校验用户登录属于通用逻辑，很多接口都将用到，应该把它单独提取出来，再配置到调用handler之前，这就是filter的作用。
.sp
drogon框架做完URL路径匹配后，会先依次调用注册到该路径上的过滤器，只有当所有过滤器都允许”通过”时，对应的handler才会被调用;
.SS 内置过滤器
.sp
drogon内置了如下常用过滤器:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIdrogon::IntranetIpFilter\fP: 只放行内网ip发来的http请求，否则返回404页面；
.IP \(bu 2
\fIdrogon::LocalHostFilter\fP: 只放行本机127.0.0.1或者::1发来的http请求，否则返回404页面；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 自定义过滤器
.sp
当然，用户可以自定义过滤器，需要继承HttpFilter类模板，模板类型就是子类类型，比如我们想做一个LoginFilter，就可以定义如下:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class LoginFilter:public drogon::HttpFilter<LoginFilter>
{
public:
    virtual void doFilter(const HttpRequestPtr &req,
                        FilterCallback &&fcb,
                        FilterChainCallback &&fccb) override ;
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
你可以通过 drogon_ctl 命令创建过滤器, 见 drogon_ctl.
.sp
我们需要重载父类的doFilter虚函数实现过滤器逻辑；
.sp
这个虚函数有三个参数，分别是：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIreq\fP: http请求；
.IP \(bu 2
\fIfcb\fP: 过滤器回调函数，函数类型是void (HttpResponsePtr)，当过滤器判定请求不合法时，通过这个回调把特定的响应返回给浏览器；
.IP \(bu 2
\fIfccb\fP: 过滤器链回调函数，函数类型是void ()，当过滤器判定请求合法时，通过这个回调告诉drogon调用下一个过滤器或者最终的handler
.UNINDENT
.UNINDENT
.UNINDENT
.sp
具体的实现可以参考drogon内置过滤器的实现。
.SS 过滤器的注册
.sp
过滤器总是伴随controller的注册进行，前面提到的注册handler的宏(PATH_ADD,METHOD_ADD等)都可以在最后添加一个或多个过滤器名字；比如，我们把前面getInfo方法的注册行改为如下形式：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get,"LoginFilter");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
则在路径匹配成功后，必须满足如下条件，getInfo方法才会被调用：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
请求必须是http get请求；
.IP 2. 3
请求方必须已经登录；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
可以看到，过滤器的配置和注册是非常简单的，注册过滤器的controller文件并不需要引用过滤器的头文件，过滤器和控制器也是充分解耦的。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 如果过滤器定义在命名空间里，注册过滤器时必须把命名空间写全
.UNINDENT
.UNINDENT
.SS 视图
.SS 视图介绍
.sp
虽然目前前端渲染技术大行其道，使后端应用服务只需要返回相应数据给前端即可，不过，一个好的web框架还是应该提供后端渲染技术，使服务端程序可以动态生成HTML页面。视图（View）可以帮助使用者生成这些页面，顾名思义，它只负责做跟展示相关的工作，而复杂的业务逻辑都应该交给控制器完成。
.sp
最早的web应用程序都是把HTML嵌入到程序编码里，达到动态生成HTML页面的目的，不过这样做有效率低、不直观等诸多缺点，于是出现了诸如JSP等语言，反其道而行之，把程序代码嵌入到HTML页面里。drogon采用的当然是后一种方案，不过，很明显，由于C++是编译执行的，我们需要把这种嵌入了C++代码的页面转换成C++源程序，才能编译进应用程序。所以，drogon定义了自己专门的CSP(C++ Server Pages)描述语言，使用命令行工具drogon_ctl可以把csp文件转换成C++源文件以供编译。
.SS Drogon的csp
.sp
drogon的csp方案很简单，我们用特殊的标记符号把C++代码嵌入到HTML页面里就可以了。其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
夹在标签*<%inc*和*%>*之间的内容被视为需要引用的头文件部分，这里只能写入*#include*语句，如*<%inc#include “xx.h” %>*,不过很多常见的头文件drogon都自动包含了，用户基本上用不到这个标签；
.IP \(bu 2
夹在标签*<%c++*和*%>*之间的所有内容都被视为C++的代码,如*<c++ std:string name=”drogon”; %>*；
.IP \(bu 2
.INDENT 2.0
.TP
.B C++的代码一般都会原封不动的转移到目标源文件中，除了下面两种特殊标记：
.INDENT 7.0
.IP \(bu 2
\fI@@*代表控制器传过来的data变量，类型是*HttpViewData\fP，可以从中获取需要的内容；
.IP \(bu 2

.nf
*
.fi
$$*代表表示页面内容的流对象，可以把需要显示的内容通过<<操作符显示在页面上；
.UNINDENT
.UNINDENT
.IP \(bu 2
夹在标签*[[\fI和\fP]]*之间的内容被认为是变量名字，view会以这个名字为keyword从控制器传过来的数据里找到对应的变量，并把它输出到页面的对应位置，变量名字前后的空格会被省略，\fI[[*和\fP]]*不要分行写，同时，出于性能考虑，只支持三种字符串数据类型*(const char *,std::string和const std::string*，因为输出时涉及数据类型判断，过多类型会导致过多的条件语句)，其他数据类型请用上面提到的方式输出(或者将需要输出的变量以string类型存入data中);
.IP \(bu 2
夹在标签*{%*和*%}*之间的内容被认为是C++程序里变量的名字或表达式（而不是控制器传过来的数据的keyword），view会把该变量的内容或表达式的值输出到页面的对应位置。容易知道*{%val.xx%}*等效于*<%c++$$<<val.xx;%>*,只是前者更为简单直观。同样的，两个标签不要分行写；
.IP \(bu 2
夹在标签*<%view*和*%>*之间的内容被认为是子视图的名字，框架会找到相应的子视图并把它的内容填充到该标签所在位置；视图名字前后的空格会被忽略，同时*<%view*和*%>*不要分行写，子视图和父视图共用控制器的数据, 可以多级嵌套但不要循环嵌套。
.IP \(bu 2
夹在标签*<%layout*和*%>*之间的内容被认为是布局的名字，框架会找到相应的布局并把本视图的内容填充到该布局的某个位置（在布局中由占位符*[[]]*标定该位置）；布局名字前后的空格会被忽略，同时*<%layout*和*%>*不要分行写，可以多级嵌套但不要循环嵌套。
.UNINDENT
.UNINDENT
.UNINDENT
.SS 视图的使用
.sp
drogon应用程序的http响应都是由控制器handler生成的，所以，由视图渲染的响应也由handler生成，通过调用如下接口生成:
.sp
这个接口是HttpResponse类的静态方法，它有两个参数：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
viewName: 视图的名字，传入的csp文件名(\fB扩展名可省略\fP);
.IP \(bu 2
data: 控制器的handler传给视图的数据，类型是*HttpViewData*，这是个特殊的map，可以存入和取出任意类型的对象，具体使用请参考HttpViewData API说明；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
可以看到，控制器不需要引用视图的头文件，控制器和视图实现了很好的解耦；他们唯一的联系是data变量，对data的内容，控制器和视图要有一致的约定；
.SS 一个简单的例子
.sp
现在我们做一个例子，把浏览器发来的HTTP请求的参数显示在返回的html页面里。
.sp
我们这里直接用HttpAppFramework的接口定义handler，在main文件中，调用run()方法之前加入如下代码：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance()
        .registerHttpMethod("/list_para",
                           [=](const HttpRequestPtr &req,
                               std::function<void (const HttpResponsePtr &)> &&callback)
                           {
                                auto para=req\->getParameters();
                                HttpViewData data;
                                data.insert("title","ListParameters");
                                data.insert("parameters",para);
                                auto resp=HttpResponse::newHttpViewResponse("ListParameters.csp",data);
                                callback(resp);
                           });
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
上面这段代码把一个lambda表达式handler注册到*/list_para*路径上，获取请求的参数传递给视图显示。 然后进入views文件夹，创建一个视图文件ListParameters.csp，内容如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<!DOCTYPE html>
<html>
<%c++
    auto para=@@.get<std::unordered_map<std::string,std::string>>("parameters");
%>
<head>
    <meta charset="UTF\-8">
    <title>[[ title ]]</title>
</head>
<body>
    <%c++ if(para.size()>0){%>
    <H1>Parameters</H1>
    <table border="1">
    <tr>
        <th>name</th>
        <th>value</th>
    </tr>
    <%c++ for(auto iter:para){%>
    <tr>
        <td>{%iter.first%}</td>
        <td><%c++ $$<<iter.second;%></td>
    </tr>
    <%c++}%>
    </table>
    <%c++ }else{%>
    <H1>no parameter</H1>
    <%c++}%>
</body>
</html>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
我们可以通过下面的命令将ListParameters.csp文件转换成c++源文件：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create view ListParameters.csp
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
运行完毕后，当前目录会出现ListParameters.h和ListParameters.cc两个源文件，就可以用来编译进web应用程序里了。
.sp
用cmake重新编译整个工程，运行目标程序webapp，就可以在浏览器里测试效果了，在地址栏输入http://localhost/list_para?p1=a&p2=b&p3=c，就可以看到如下页面：
.sp
view page
.sp
后端渲染的html页面就这样简单的加上了。虽然页面简陋点，但不影响我们说明视图的用法。
.SS csp文件的自动化处理
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：如果你的工程是使用drogon_ctl命令创建的，那么本节描述的内容已经由该命令自动帮你做了。
.UNINDENT
.UNINDENT
.sp
显然，每次修改csp文件都需要手动运行drogon_ctl命令显得太不方便了，我们可以把drogon_ctl的处理放进CMakeLists.txt文件里，仍以前面的例子为例，假设我们把所有的csp文件都放到views文件夹里，则CMakeLists.txt可以添加如下处理：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
FILE(GLOB SCP_LIST ${CMAKE_CURRENT_SOURCE_DIR}/views/*.csp)
foreach(cspFile ${SCP_LIST})
    message(STATUS "cspFile:" ${cspFile})
    EXEC_PROGRAM(basename ARGS "\-s .csp ${cspFile}" OUTPUT_VARIABLE classname)
    message(STATUS "view classname:" ${classname})
    add_custom_command(OUTPUT ${classname}.h ${classname}.cc
        COMMAND drogon_ctl
        ARGS create view ${cspFile}
        DEPENDS ${cspFile}
        VERBATIM )
set(VIEWSRC ${VIEWSRC} ${classname}.cc)
endforeach()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
然后在add_executable语句中添加新的源文件集合${VIEWSRC},如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Add_executable(webapp ${SRC_DIR} ${VIEWSRC})
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
上述措施在drogon_ctl create project命令生成的工程里已经写入CMakeLists.txt文件，用户在views文件夹创建的csp文件都会被自动转换并编译进应用程序。
.SS 视图的动态编译和加载
.sp
drogon提供了在应用运行期动态编译和加载csp文件的方法，使用如下接口设置：
.sp
该接口是*HttpAppFramework*的成员方法，参数是一个字符串数组，代表视图csp文件所在目录的列表。调用这个接口后，drogon将自动搜索这些目录，发现新的或者被修改的csp文件后，都将自动生成源文件、编译成动态库文件并加载到应用里，整个过程应用程序无需重启。用户可以自行实验，观察csp的修改带来的页面变化。
.sp
很显然，该功能依赖于开发环境，如果drogon和webapp都在这台服务器编译，则动态加载csp页面也应该没有问题；
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：动态加载的视图不能静态编译进程序，也就是说，如果一个视图已经静态编译进程序，那么它无法通过动态加载更新，你可以单独建一个动态视图路径，并在开发阶段把视图移动到这个路径进行调试（linux操作系统没有这个问题）。
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 该特性最好用于在开发阶段方便调整页面，生产环境部署还是建议直接编译成目标文件运行，这主要是出于安全性和稳定性考虑。
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 如果加载时遇到*symbol not found*错误，请使用*cmake .. \-DCMAKE_ENABLE_EXPORTS=on*或取消CMakeLists.txt最后一行对*set_property(TARGET ${PROJECT_NAME} PROPERTY ENABLE_EXPORTS ON)*的注释，并重新编译你的工程
.UNINDENT
.UNINDENT
.SS 会话
.sp

.nf
*
.fi
会话（Session）*是web应用的重要概念，用于在服务端保存客户端的状态，一般和浏览器的cookie配合，drogon提供了对会话的支持。drogon默认关闭会话选择，你也可以通过如下接口关闭或打开：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void disableSession();
void enableSession(const size_t timeout=0);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
都是通过*HttpAppFramework*单例调用，timeout参数代表了会话失效的时间，单位是秒，框架默认值是1200，即如果用户20分钟以上没有访问应用，则他对应的会话就失效了。timeout设置为0表示drogon将在整个生存期保留用户的会话；
.sp
打开会话特性前请确定你的客户端支持cookie，否则，drogon会为每次不含SessionID的请求创建新的会话，这会白白浪费内存和计算资源。
.SS 会话对象
.sp
drogon的会话对象类型是*drogon::Session*，它和*HttpViewData*非常类似，可以通过关键字存取任意类型的对象；支持并发读写；具体的使用请参考Session class的说明；
.sp
drogon框架会把会话对象放到HttpRequest对象里传递给用户，用户可以通过HttpRequest类的如下接口获取Session对象。
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
SessionPtr session() const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
获得的是Session对象的智能指针，通过它可以存取各种对象；
.SS 会话的例子
.sp
我们这次加一个需要会话支持的功能，比如，我们要限制用户的访问频度，某一次访问后，如果10秒以内再次访问，就返回错误，否则返回ok。我们需要在会话里记录上次访问的时间，然后和本次访问的时间做比较，就可以实现这个功能。
.sp
我们创建一个Filter来实现这个功能，假设类名是TimeFilter，实现如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "TimeFilter.h"
#include <trantor/utils/Date.h>
#include <trantor/utils/Logger.h>
#define VDate "visitDate"
void TimeFilter::doFilter(const HttpRequestPtr &req,
                        FilterCallback &&cb,
                        FilterChainCallback &&ccb)
{
    trantor::Date now=trantor::Date::date();
    LOG_TRACE<<"";
    if(req\->session()\->find(VDate))
    {
        auto lastDate=req\->session()\->get<trantor::Date>(VDate);
        LOG_TRACE<<"last:"<<lastDate.toFormattedString(false);
        req\->session()\->insert(VDate,now);
        LOG_TRACE<<"update visitDate";
        if(now>lastDate.after(10))
        {
            //10 sec later can visit again;
            ccb();
            return;
        }
        else
        {
            Json::Value json;
            json["result"]="error";
            json["message"]="Access interval should be at least 10 seconds";
            auto res=HttpResponse::newHttpJsonResponse(json);
            cb(res);
            return;
        }
    }
    LOG_TRACE<<"first access,insert visitDate";
    req\->session()\->insert(VDate,now);
    ccb();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
我们再注册一个lambda表达式到/slow路径上，同时附加上TimeFilter，代码如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance()
            .registerHttpMethod("/slow",
                               [=](const HttpRequestPtr &req,
                                   std::function<void (const HttpResponsePtr &)> &&callback)
                               {
                                   Json::Value json;
                                   json["result"]="ok";
                                   auto resp=HttpResponse::newHttpJsonResponse(json);
                                   callback(resp);
                               },
                               {Get,"TimeFilter"});
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
调用框架接口打开会话
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon::HttpAppFramework::instance().enableSession(1200);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
用cmake重新编译整个工程，运行目标程序webapp，就可以通过浏览器看到效果了。
.SS 数据库 概述
.SS 概述
.sp

.nf
*
.fi
Drogon*内置了数据库读写引擎，对数据库连接的操作基于non\-blocking I/O技术实现，因此，从底层到上层接口，都是高效率的非阻塞异步方式，保证了Drogon对高并发性能的追求。目前，Drogon支持PostgreSQL和MySQL数据库，如果要使用数据库，开发系统必须先安装相应数据库的开发环境，Drogon会自动探测这些库的头文件和库文件，编译相应的部分。数据库开发环境的准备，参见安装数据库环境。
.sp
Drogon为了支持轻量级应用，也支持sqlite3数据库，通过线程池实现异步接口，与前述数据库的接口是统一的。
.SS DbClient 客户端
.sp
Drogon的数据库基本操作对象是*DbClient*(这是一个抽象类，用户可以持有的是*DbClient*类型的智能指针，具体类型取决于构造它的接口)，区别于一般的数据库接口，这个对象并不代表单一的数据库连接，它内部可以包含一个或多个数据库连接，你可以把它看作一个**连接池对象**。
.sp

.nf
*
.fi
DbClient*同时提供了同步和异步接口，异步接口也同时支持阻塞和非阻塞的模式，当然，出于和Drogon异步框架配合的需要，建议大家多使用异步接口的非阻塞模式，这也是对提高并发性最有效的接口。
.sp
通常，一个异步接口调用时，DbClient会在它管理的空闲连接中随机选取一个，执行相关的查询操作，待有结果返回时，DbClient会处理数据，通过回调函数对象返回给调用方；如果调用时没有空闲连接，执行内容会被缓存，一旦有连接执行完自己的sql请求，就会从缓存中依次取出待执行的命令去执行。
.sp
DbClient的详细内容，见DbClient。
.SS 事务
.sp
由*DbClient*可以产生事务对象，用以支持事务操作，事务对象除了多出一个*rollback()*接口，其余基本和*DbClient*一致，事务对象的类是*Transaction*，关于事务的详细内容，参见事务。
.SS ORM
.sp
Drogon也提供了对ORM的支持，用户可以通过drogon_ctl读取数据库中的表，并生成对应的model对象类源码，然后，通过*Mapper<MODEL>*类模板完成这些对象的数据库操作，为标准的数据操作提供了简单便捷的接口，使用户可以不用自己写sql语句就可以完成对表的增删改查。关于*ORM*，请参阅ORM。
.SS 数据库 Dbclient
.SS 构建DbClient
.sp
构造DbClient对象有两种途径，一个是通过DbClient类的静态方法，在DbClient.h头文件可以看到定义，如下:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#if USE_POSTGRESQL
    static std::shared_ptr<DbClient> newPgClient(const std::string &connInfo, const size_t connNum);
#endif
#if USE_MYSQL
    static std::shared_ptr<DbClient> newMysqlClient(const std::string &connInfo, const size_t connNum);
#endif
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
得到DbClient实现对象的智能指针，参数connInfo是个连接字符串，采用key=value的形式设置一系列连接参数，具体说明见头文件的注释。参数connNum是DbClient的连接数，即该对象管理的数据库连接个数，对并发有关键影响，请根据实际情况设置。
.sp
通过这种方法得到的对象，用户要想办法**持久化**，比如放在某些全局容器内，\fB创建临时对象，使用完再释放是非常不推荐的方案\fP，理由如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
白白的浪费创建连接和断开连接的时间，增加了系统时延；
.IP \(bu 2
该接口也是非阻塞接口，也就是说，用户拿到DbClient对象时，它管理的连接还没建立起来，框架没有（故意的）提供连接建立成功的回调接口，难道还要sleep一下再开始查询么？这和异步框架的初衷相违背。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
所以，应该在程序开始之初就构建这些对象，并在整个生存周期持有并使用它。显然，这个工作完全可以由框架来做，因此，框架提供了第二种构建方式，就是通过配置文件构建或使用createDbClient接口创建，配置方法见配置文件。
.sp
需要使用时，通过框架的接口获得DbClient的智能指针，接口如下（注意该接口必须在app.run()调用后才能得到正确的对象）：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
orm::DbClientPtr getDbClient(const std::string &name = "default");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
参数name就是配置文件中的name配置项的值，用以区分同一个应用的多个不同的DbClient对象。DbClient管理的连接总是断线重连的，所以用户不用关心连接状态，他们几乎总是正常连接的状态。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Note: This method cannot be called before running app.run(), otherwise the user will get an empty shared_ptr.
.UNINDENT
.UNINDENT
.SS 执行接口
.sp
DbClient对外提供了几种不同的接口，列举如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// 异步接口
template <
        typename FUNCTION1,
        typename FUNCTION2,
        typename... Arguments>
void execSqlAsync(const std::string &sql,
                FUNCTION1 &&rCallback,
                FUNCTION2 &&exceptCallback,
                Arguments &&... args) noexcept;

/// 异步future接口
template <typename... Arguments>
std::future<const Result> execSqlAsyncFuture(const std::string &sql,
                                            Arguments &&... args) noexcept;

/// 同步接口
template <typename... Arguments>
const Result execSqlSync(const std::string &sql,
                        Arguments &&... args) noexcept(false);

/// 流式接口
internal::SqlBinder operator<<(const std::string &sql);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
因为涉及任意数量和类型的绑定参数，因此这些接口都是函数模板。
.sp
这些接口的性质如下表所示：
.TS
center;
|l|l|l|l|.
_
T{
接口
T}	T{
同步/异步
T}	T{
阻塞/非阻塞
T}	T{
异常
T}
_
T{
void execSqlAsync
T}	T{
异步
T}	T{
非阻塞
T}	T{
不抛异常
T}
_
T{
std::future execSqlAsyncFuture
T}	T{
异步
T}	T{
调用future的get方法时阻塞
T}	T{
调用future的get方法时可能抛异常
T}
_
T{
const Result execSqlSync
T}	T{
同步
T}	T{
阻塞
T}	T{
可能抛异常
T}
_
T{
internal::SqlBinder operator<<
T}	T{
异步
T}	T{
默认非阻塞，也可以阻塞
T}	T{
不抛异常
T}
_
.TE
.sp
你可能对异步和阻塞的组合有点困惑，一般而言，同步接口涉及网络IO都是阻塞的，异步接口则是非阻塞的，不过，异步接口也可以工作于阻塞模式，意思是说，这个接口会阻塞一直等到回调函数执行完毕才会退出。DbClient的异步接口工作于阻塞模式时，回调函数会在同一个线程被执行，然后该接口才执行完毕。
.sp
如果你的应用涉及高并发场景，请选择异步非阻塞接口，如果是低并发场景，比如一个网络设备的管理页面，则可以出于直观方便的考虑，选择同步接口。
.SS execSqlAsync
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename FUNCTION1,
        typename FUNCTION2,
        typename... Arguments>
void execSqlAsync(const std::string &sql,
                FUNCTION1 &&rCallback,
                FUNCTION2 &&exceptCallback,
                Arguments &&... args) noexcept;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这是最常使用的异步接口，工作于非阻塞模式；
.sp
参数*sql*是sql语句的字符串，如果有需要绑定参数的占位符，使用相应数据库的占位符规则，比如PostgreSQL的占位符是$1,$2..，而MySQL的占位符是*?*。
.sp
不定参数*args*代表绑定的参数，可以是零个或多个，具体数据和sql语句的占位符个数一致，类型可以是以下几类：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
整数类型：可以是各种字长的整数，应和数据库字段类型相匹配；
.IP \(bu 2
浮点类型：可以是*float*或者*double*，应和数据库字段类型相匹配；
.IP \(bu 2
字符串类型：可以是*std::string*或者*const char[]*，对应数据库的字符串类型或者其他可以用字符串表示的类型；
.IP \(bu 2
日期类型：
.nf
*
.fi
trantor::Date*类型，对应数据库的date，datetime，timestamp等字段类型。
.IP \(bu 2
二进制类型：
.nf
*
.fi
std::vector<char>*类型，对应PostgreSQL的bytea类型或者Mysql的blob类型；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
这些参数可以是左值，也可以是右值，可以是变量，也可以是字面常量，用户可以自由掌握。
.sp
参数rCallback和exceptCallback分别表示结果回调函数和异常回调函数，它们有固定的定义，如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
结果回调函数：调用类型为void (const Result &)，符合这个调用类型的各种可调用对象，std::function,lambda等等都可以作为参数传入；
.IP \(bu 2
异常回调函数：调用类型为void (const DrogonDbException &)，可传入和这个调用类型一致的各种可调用对象；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
sql执行成功后，执行结果由Result类包装并通过结果回调函数传递给用户；如果sql执行有任何异常，异常回调函数被执行，用户可以从DrogonDbException对象获得异常信息。
.sp
我们举个例子：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto clientPtr = drogon::app().getDbClient();
clientPtr\->execSqlAsync("select * from users where org_name=$1",
                            [](const Result &r) {
                                std::cout << r.size() << " rows selected!" << std::endl;
                                int i = 0;
                                for (auto row : r)
                                {
                                    std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
                                }
                            },
                            [](const DrogonDbException &e) {
                                std::cerr << "error:" << e.base().what() << std::endl;
                            },
                            "default");
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
从例子中我们可以看出，Result对象是个std标准兼容的容器，支持迭代器，它封装的结果集可以通过范围循环取到每一行的对象，Result，Row和Field对象的各种接口，请参考源码；
.sp
DrogonDbException类是所有数据库异常的基类，具体的定义和它子类的说明，请参考源码中的注释。
.SS execSqlAsyncFuture
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename... Arguments>
std::future<const Result> execSqlAsyncFuture(const std::string &sql,
                                            Arguments &&... args) noexcept;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
异步futrue接口省略了前一个接口的中间两个参数（使用future对象代替回调函数），调用这个接口会立即返回一个future对象，用户必须调用future的get()方法，得到返回的结果，异常要通过try/catch机制得到，如果调用get()方法时没有try/catch，并且整个调用堆栈中也没有try/catch，则程序会在sql执行发生异常的时候退出。
.sp
例如:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto f = clientPtr\->execSqlAsyncFuture("select * from users where org_name=$1",
                                    "default");
try
{
    auto result = f.get(); // Block until we get the result or catch the exception;
    std::cout << r.size() << " rows selected!" << std::endl;
    int i = 0;
    for (auto row : r)
    {
        std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
    }
}
catch (const DrogonDbException &e)
{
    std::cerr << "error:" << e.base().what() << std::endl;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS execSqlSync
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename... Arguments>
const Result execSqlSync(const std::string &sql,
                        Arguments &&... args) noexcept(false);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
同步接口是最简单直观的，输入参数是sql字符串和绑定的参数，返回一个Result对象，调用会阻塞当前线程，并且在出现错误时抛异常，所以也要注意*try/catch*捕获异常。
.sp
例如:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
try
{
    auto result = clientPtr\->execSqlSync("update users set user_name=$1 where user_id=$2",
                                        "test",
                                        1); // Block until we get the result or catch the exception;
    std::cout << r.affectedRows() << " rows updated!" << std::endl;
}
catch (const DrogonDbException &e)
{
    std::cerr << "error:" << e.base().what() << std::endl;
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS operator<<
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
internal::SqlBinder operator<<(const std::string &sql);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
流式接口比较特殊，它把sql语句和参数依次通过*<<\fI操作符输入，而通过\fP>>*操作符指定结果回调函数和异常回调函数，比如前面select的例子，使用流式接口是如下的样子：:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
*clientPtr  << "select * from users where org_name=$1"
            << "default"
            >> [](const Result &r)
                {
                    std::cout << r.size() << " rows selected!" << std::endl;
                    int i = 0;
                    for (auto row : r)
                    {
                        std::cout << i++ << ": user name is " << row["user_name"].as<std::string>() << std::endl;
                    }
                }
            >> [](const DrogonDbException &e)
                {
                    std::cerr << "error:" << e.base().what() << std::endl;
                };
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这种写法和第一种异步非阻塞接口是完全等效的，采用哪种接口取决于用户的使用习惯。如果想让它工作于阻塞模式，可以使用*<<
.nf
*
.fi
输入一个*Mode::Blocking*参数，这里不再赘述。
.sp
另外，流式接口还有一个特殊的用法，使用一种特殊的结果回调，可以让框架逐行的把结果传递给用户，这种回调的调用类型如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void (bool,Arguments...);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
第一个bool参数为true时，表示这次回调是一个空行，也就是，所有结果都已经返回了，这是最后一次回调； 后面是一系列参数，对应一行记录的每一列的值，框架会做好类型转换，当然，用户也要注意类型的匹配。这些类型可以是const型的左值引用，也可以是右值引用，当然也可以是值类型。
.sp
我们再把上一个例子用这种回调重写一下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int i = 0;
*clientPtr  << "select user_name, user_id from users where org_name=$1"
            << "default"
            >> [&i](bool isNull, const std::string &name, int64_t id)
                    {
                    if (!isNull)
                        std::cout << i++ << ": user name is " << name << ", user id is " << id << std::endl;
                    else
                        std::cout << i << " rows selected!" << std::endl;
                    }
            >> [](const DrogonDbException &e)
                {
                    std::cerr << "error:" << e.base().what() << std::endl;
                };
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可以看到，select语句中的user_name和user_id字段的值，被分别赋给了回调函数中的name和id变量，用户无需自己处理这些转换，这显然提供了一定的便利性，用户可以在实践中灵活运用。
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 借着这个例子，要强调一点异步编程必须注意的地方，就是上面例子中的变量i，用户必须保证在回调发生时，变量i还是有效的，因为它是被引用捕获的，它的有效性并不是理所当然的，回调会在别的线程被调用，而回调发生时，当前的上下文环境很可能已经失效了。类似的场景常常使用智能指针持有临时创建的变量，再被回调捕获，从而保证变量的有效性。
.UNINDENT
.UNINDENT
.SS 总结
.sp
每个DbClient对象有且仅有一个自己的EventLoop线程，这个线程负责控制数据库连接IO，通过异步或同步接口接受请求，再通过回调函数返回结果。
.sp
它虽然也提供阻塞的接口，这种接口只是阻塞调用者线程，只要调用者线程不是EventLoop线程，就不会影响EventLoop线程的正常运转。回调函数被调用时，回调内的程序是运行在EventLoop线程的，所以，不要在回调内部进行任何阻塞操作，否则会影响数据库的并发，熟悉non\-blocking I/O编程的人都应该明白这个约束。
.SS 数据库 事务
.sp

.nf
**
.fi
事务**是关系型数据库的重要特性，Drogon通过*Transaction*类提供了对事务的支持。
.sp

.nf
*
.fi
Transaction*类的对象由*DbClient*创建，事务有关的操作很多是自动进行的：
.INDENT 0.0
.INDENT 3.5

.nf
*
.fi
Transaction*对象创建之初，自动执行了*begin*语句开始事务；

.nf
*
.fi
Transaction*对象析构时，自动执行*commit*语句结束事务；
如果中间出现导致事务失败的异常，自动执行*rollback*语句回滚事务；
如果事务已经回滚，则之后的sql语句都会返回异常（抛异常或者执行异常回调）；
.UNINDENT
.UNINDENT
.SS 事务的创建
.sp
事务创建接口由DbClient提供，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
std::shared_ptr<Transaction> newTransaction(const std::function<void(bool)> &commitCallback = std::function<void(bool)>())
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这个接口很简单，它返回一个*Transaction*对象的智能指针，显然，这个智能指针失去所有持有者而析构事务对象时，事务也就结束了。参数*commitCallback*用于返回事务提交是否成功，需要注意的是，这个回调只用来指示*commit*命令是否成功，如果，事务在执行过程中自动或手动回滚了，这个回调就不会执行了。通常，
.nf
*
.fi
commit*命令都会成功，这个回调的bool类型参数为true，只有某些特殊情况，比如*commit*执行过程中连接断了，才会导致*commitCallback*通知用户*commit*失败，这时，事务在服务端的状态是不确定的，用户需特殊处理，当然，考虑到这种情况极少发生，非关键业务也可以选择忽略这种事件，那么用户只需要在创建事务时忽略这个参数即可（默认的空回调会传入这个接口）。
.sp
事务要独占一个数据库连接，因此事务创建过程中，
.nf
*
.fi
DbClient*要从自己的连接池中选一个空闲连接交给事务对象管理，这就有一个问题，如果DbClient的所有连接都在执行sql或者其他事务，那么，这个接口会阻塞直到有空闲连接为止。
.sp
框架同时提供了一个异步接口创建事务，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void newTransactionAsync(const std::function<void(const std::shared_ptr<Transaction> &)> &callback);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这个接口通过回调函数返回事务对象，不会阻塞当前线程，保证了应用的高并发，缺点是多了一次回调函数的嵌套。用户可根据实际情况自行选用。
.SS 事务的接口
.sp

.nf
*
.fi
Transaction*的接口和*DbClient*几乎完全一致，除了下面这两点区别：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2

.nf
*
.fi
Transaction*提供了*rollback()*接口，使用户可以在任何情况下回滚事务，比如并未有任何错误发生，只是业务逻辑要求回滚事务的情况，有时候事务已经自动回滚了，这时候再次调用rollback()接口，没有任何负作用，因此，显示的使用*rollback()*接口是个不错的策略，至少可以保证不会错误提交。
.IP \(bu 2
用户不能调用事务的*newTransaction()*接口，这是容易理解的，虽然数据库有子事务的概念，但目前框架并不支持。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
事实上，
.nf
*
.fi
Transaction*被设计成*DbClient*的子类，也是为了保持这些接口的一致性，同时，也为后文*ORM*的使用创造了方便条件。
.sp
框架目前没有提供控制事务隔离等级的接口，也就是说，隔离等级就是当前数据库服务的默认等级。
.SS 事务的生命周期
.sp
事务对象的智能指针除了被用户持有外，当它有未执行的sql时，框架也会持有，所以不用担心在还有未执行sql的情况下事务对象被析构。另外，事务对象智能指针常常在它的某个接口的结果回调里被捕获并使用，这也是正常的使用方式，不要担心由此引发循环引用导致事务对象永远不会析构，框架会通过回调完毕后清空事务内部的回调函数对象来打破循环引用；
.SS 一个例子
.sp
举个最简单的例子，假设有一个任务表，用户从中选取一个未处理状态的任务，把它改成正在处理中的状态，为了防止并发的竞态条件，我们使用Transaction，程序如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    auto transPtr = clientPtr\->newTransaction();
    transPtr\->execSqlAsync( "select * from tasks where status=$1 for update order by time",
                            "none",
                            [=](const Result &r) {
                                if (r.size() > 0)
                                {
                                    std::cout << "Got a task!" << std::endl;
                                    *transPtr << "update tasks set status=$1 where task_id=$2"
                                            << "handling"
                                            << r[0]["task_id"].as<int64_t>()
                                            >> [](const Result &r)
                                                {
                                                    std::cout << "Updated!";
                                                    ... do something about the task;
                                                }
                                            >> [](const DrogonDbException &e)
                                                {
                                                    std::cerr << "err:" << e.base().what() << std::end;
                                                };
                                }
                                else
                                {
                                    std::cout << "No new tasks found!" << std::endl;
                                }
                            },
                            [](const DrogonDbException &e) {
                                std::cerr << "err:" << e.base().what() << std::end;
                            });
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
本例中使用select for update避免并发修改，update语句在select语句的结果回调中完成，进行了一次嵌套，最外层的大括号是为了限定transPtr的作用范围，使之在执行完sql后及时的销毁从而结束事务。
.SS 数据库 ORM
.SS Model
.sp
使用Drogon的ORM支持，首先要创建Model类，Drogon的命令行程序*drogon_ctl*提供了生成Model类的功能，它从用户指定的数据库读取表信息，根据这些信息自动生成多个Model类的源文件。用户使用Model时include对应的头文件即可。
.sp
显而易见，每一个Model类，对应一个特定的数据库表，每个Model类的实例，对应表的一行记录。
.sp
model类的创建命令如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create model <model_path>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
最后一个参数是model存放的路径，该路径内必须有一个配置文件model.json，用以配置drogon_ctl到数据库的连接参数。它是JSON格式的文件，支持注释，例子如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "rdbms":"postgresql",
    "host":"127.0.0.1",
    "port":5432,
    "dbname":"test",
    "user":"test",
    "passwd":"",
    "tables":[]
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
配置的参数和应用的配置文件一致，请参考配置文件。
.sp

.nf
*
.fi
tables*配置项是它特有的，是一个字符串数组，每个字符串表示要转化成Model的表名，如果该项为空，则所有的表都会生成对应的Model类。
.sp
用drogon_ctl create project命令创建的工程目录下已经预先创建了models目录和对应的model.json文件，用户可以编辑配置文件后用drogon_ctl命令创建Model类。
.SS Model类的接口
.sp
用户直接使用的主要有两类接口，getter接口和setter接口。
.sp
getter接口又有两类：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
形如getColumnName的接口，取得该字段的智能指针，取得指针而不是值，主要是为了包含NULL数据的情况，用户可以通过判断该指针是否为空来确定该字段是否是NULL字段。
.IP \(bu 2
形如getValueOfColumnName的接口，故名思议，该接口是取得值的，出于效率的考虑，该接口返回的是常引用。如果对应字段为NULL，该接口返回第二个参数给定的默认值。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
另外，二进制块类型(blob，bytea)有个特殊点的接口，形如getValueOfColumnNameAsString，把二进制数据装进std::string对象返给用户。
.sp
setter接口用于设置对应字段的值，形如setColumnName，参数类型和字段类型对应。自动生成的字段比如自增主键是没有setter接口的。
.sp
toJson()接口用于把model对象转换成JSON对象，二进制块类型采用base64编码，请用户自行实验。
.sp
Model类的静态成员都表示表的信息，比如可以通过Cols静态成员获得每个字段的名字，在支持自动提示的编辑器中使用很方便。
.SS Mapper类模板
.sp
Model对象和数据库表的映射都是通过Mapper类模板进行，Mapper类模板封装了常见的增删改查操作，使用户可以不必撰写sql语句即可执行上述操作。
.sp
Mapper构造时很简单，模板参数就是你要存取的Model的类型，构造函数只有一个参数，就是前文提到的DbClient智能指针。前文说过，Transaction类是DbClient的子类，所以，你也可以用一个事务的智能指针构造Mapper对象，也就是说Mapper映射也是支持事务的。
.sp
像DbClient一样，Mapper也同时提供异步和同步接口。同步接口都阻塞并可能抛异常，返回的future对象在get()时阻塞并可能抛异常，一般的异步接口不会抛异常，而是通过两个回调（结果回调和异常回调）返回结果，其中，异常回调的类型和DbClient接口里的一致，结果回调根据接口功能的不同也分成几类。列表如下（T是模板参数，也就是Model的类型）：
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意: 使用事务时，异常不必然导致回滚，下面的情况是不会回滚的，当findByPrimaryKey接口未找到符合条件的行时，当findOne接口找到少于或多于一行记录时，会抛异常或进入异常回调，异常类型是UnexpectedRows。如果业务逻辑需要在这种情况下回滚，请显式调用rollback()接口。
.UNINDENT
.UNINDENT
.SS 条件对象
.sp
上一节中，很多接口都需要输入条件对象参数，条件对象是Criteria类的实例，表示某种where条件，比如某个字段大于、等于、小于某个给定值，或者isNull之类的条件。
.sp
条件对象的构造函数很简单，一般第一个参数是字段名，第二个参数是表示比较类型的枚举值，第三个字段是被比较的值。如果比较类型是IsNull或IsNotNull，不需要第三个参数。
.sp
比如：
.. code\-block:: cpp
.INDENT 0.0
.INDENT 3.5
Criteria(“user_id”,CompareOperator::EQ,1);
.UNINDENT
.UNINDENT
.sp
表示，字段user_id等于1作为条件。实践中，我们更愿意写成下面这样：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Criteria(Users::Cols::_user_id,CompareOperator::EQ,1);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
跟前面的写法等效，但是这个写法可以有助于编辑器的自动提示，效率更高并且不易出错；
.sp
条件对象支持与和或的运算，两个条件对象的与和或会构造出新的条件对象，这样可以方便的构造嵌套的where条件。比如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Mapper<Users> mp(dbClientPtr);
auto users = mp.findBy(
(Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Smith")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,0))
||(Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Johnson")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,1))
));
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
上面这段程序是从users表里查询所有姓李的男士或者姓王的女士。
.SS Mapper的链式接口
.sp
有些常见的sql约束，比如limit，offset等等，Mapper类模板也提供了支持，以链式接口的形式提供，意味着用户可以把多个约束串起来写。执行完任何一个接口，这些约束会被清空，也就是说，这些约束是在一次操作中有效的，比如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Mapper<Users> mp(dbClientPtr);
auto users = mp.orderBy(Users::Cols::_join_time).limit(25).offset(0).findAll();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这段程序是从users表中选择用户列表，每页25行的第一页。
.sp
链式接口基本可以望文生义，这里不再一一赘述，请参考Mapper.h头文件。
.SS 关系
.sp
数据库的表与表之间的关系，可以通过model.json配置文件中的relationships选项进行配置，我们采用了手动配置的方式而不是自动探测表的外键是因为现实工程中不使用外键的情况也非常常见。
.sp

.nf
*
.fi
enable*选项为true，则生成的model会按照relationships的配置增加相应的接口。
.sp
关系共分为三种类型，’has one’, ‘has many’和’many to many’。
.SS has one
.sp
\fIhas one\fP 代表了1对1的关系，原始表中的一条记录可以关联到目标表中的一条记录，反过来也一样。举个例子，产品表和库存单位表是1对1的关系，我们可以定义如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "has one",
    "original_table_name": "products",
    "original_table_alias": "product",
    "original_key": "id",
    "target_table_name": "skus",
    "target_table_alias": "SKU",
    "target_key": "product_id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
“type”: 表示这个关系是1对1；
.IP \(bu 2
“original_table_name”: 原始表名字（这个表对应的model中将添加对应的方法）；
.IP \(bu 2
“original_table_alias”: 别名（方法中的名字，因为1对1的关系中都是单数，所以设置为product），如果这个选项为空，则使用表名生成方法名；
.IP \(bu 2
“original_key”: 原始表的关联键；
.IP \(bu 2
“target_table_name”: 目标表的名字；
.IP \(bu 2
“target_table_alias”: 目标表的别名，如果这个选项为空，则使用表名生成方法名；
.IP \(bu 2
“target_key”: 目标表的关联键；
.IP \(bu 2
“enable_reverse”: 指明是不是自动生成反向的关系，即在目标表对应的model类中添加获取原始表的记录的方法。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
按照这个设置，在products表对应的model类中，将添加如下的方法：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// Relationship interfaces
void getSKU(const DbClientPtr &clientPtr,
            const std::function<void(Skus)> &rcb,
            const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这是一个异步接口，在回调中返回与当前product相关联的SKU对象。
.sp
同时，由于enable_reverse选项设置为真，那么在skus表对应的model类中，将添加如下方法：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/// Relationship interfaces
void getProduct(const DbClientPtr &clientPtr,
                const std::function<void(Products)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS has many
.sp
\fIhas many\fP 代表了一对多的关系，这样的关系中，代表了*多*的那个的那个表一般会有个字段和另一个表的主键相关联。比如产品和评价通常是一对多的关系，我们可以定义如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "has many",
    "original_table_name": "products",
    "original_table_alias": "product",
    "original_key": "id",
    "target_table_name": "reviews",
    "target_table_alias": "",
    "target_key": "product_id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
上面各个配置的含义跟前一个例子一样，这里不再赘述，因为评价有多个，是复数，所以不用另起一个别名了。按照该设置，drogon_ctl create model之后，products表对应的model中，会增加下面的接口：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getReviews(const DbClientPtr &clientPtr,
                const std::function<void(std::vector<Reviews>)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
reviews表对应的model中，会增加下面的接口：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getProduct(const DbClientPtr &clientPtr,
                const std::function<void(Products)> &rcb,
                const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS many to many
.sp
顾名思义，many to many代表了多对多的关系，通常，多对多的关系要增加一个中间表，中间表中的每一项对应原始表和目标表中的各1条记录。比如产品和购物车就是多对多的关系，我们可以定义如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "type": "many to many",
    "original_table_name": "products",
    "original_table_alias": "",
    "original_key": "id",
    "pivot_table": {
        "table_name": "carts_products",
        "original_key": "product_id",
        "target_key": "cart_id"
    },
    "target_table_name": "carts",
    "target_table_alias": "",
    "target_key": "id",
    "enable_reverse": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
上面的配置介绍过的选项含义和前面一样，只是对于中间表，多了一项pivot_table的配置，里面的选项可以望文生义，这里省略。
.sp
按这个配置生成的products的model会添加如下方法：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getCarts(const DbClientPtr &clientPtr,
              const std::function<void(std::vector<std::pair<Carts,CartsProducts>>)> &rcb,
              const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
carts表的model类会添加如下方法：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void getProducts(const DbClientPtr &clientPtr,
                 const std::function<void(std::vector<std::pair<Products,CartsProducts>>)> &rcb,
                 const ExceptionCallback &ecb) const;
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Restful API 控制器
.sp
drogon_ctl还可以在创建model的同时，为每个model（或者说表）生成restful风格的controller，使用户在零编码的情况下，就生成了可以对表进行增删改查的API。这些API支持按主键查询、按条件查询、按特定字段排序、值返回指定字段、为每个字段指定别名以隐藏表结构等功能。它由model.json中的restful_api_controllers选项控制，相关的自选项在json文件中有相应的注释，用户可以自行尝试。
.sp
需要注意的是，每个表的controller都被设计成由一个基类和一个子类组成，其中，基类和表密切相关，子类用于提供给用户实现特殊的业务逻辑，或者修饰接口格式。这样设计的好处是，当表结构发生变化的时候，用户可以控制只更新基类而不覆盖子类，保证了开发的连续性。
.sp
鉴于这个功能不是那么被普遍需要，这里不做详细介绍了。
.SS 数据库 FastDbclient
.sp
顾名思义，FastDbClient会提供比普通的DbClient更高的性能。与DbClient拥有自己的EventLoop不同，它和Web应用的网络IO线程和主线程共用EventLoop，这使得FastDbClient的内部实现可以采用无锁的方式进行，因而会更高效。
.sp
经测试，极限高负载条件下，FastDbClient比DbClient有10%到20%的性能提升。
.SS 创建和获取
.sp
FastDbClient必须由框架使用框架的接口或通过配置文件创建，使用框架的createDbClient接口，当最后一个参数为true时，即可创建一个FastDbClient对象。
.sp
配置文件中的每个db_client配置项下有个is_fast子选项，该选项为true时，表明该对象是FastDbClient。
.sp
框架会针对每个IO事件循环和主事件循环创建单独的FastDbClient，每个FastDbClient内部管理数个数据库连接。IO事件循环数由框架的”threads_num”选择控制，一般设为主机的CPU核心数，每个事件循环管理的数据库连接数由数据库客户端的”connection_number”选项控制，所以一项FastDbClient的总连接数为*(threads_num+1) * connection_number*，参考配置文件。
.sp
FastDbClient的获取接口和普通DbClient的类似，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
orm::DbClientPtr getFastDbClient(const std::string &name = "default");
/// Use drogon::app().getFastDbCLient("clientName") to get a FastDbClient object.
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
需要指出的是，由于FastDbClient的特殊性，用户必须在IO事件循环线程或主线程内调用上述接口才能得到正确的智能指针，在其它线程只能获得空指针，无法使用。
.SS 使用
.sp
FastDbClient的使用与普通的DbClient几乎完全一致，除了下面这些限制（高性能的代价是使用上有约束，这是可以理解的）。
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
获取和使用都必须在框架的IO事件循环线程或主线程内，在其它线程获取FastDbClient只能得到空指针，在其它线程使用它，会有无法预料的错误（因为无锁的条件遭到破坏），好在用户在应用编程的多数地方都是在IO线程内，比如各种控制器的处理函数内，过滤器的过滤函数内。容易知道，FastDbClient接口的各种回调函数内也是在当前IO线程，可以放心嵌套使用。
.IP \(bu 2
永远不要使用FastDbClient的阻塞接口，因为这种接口会阻塞当前线程，而当前线程也是处理这个对象的数据库IO的线程，这会造成永久的阻塞，用户没有机会拿到结果。
.IP \(bu 2
同步的事务创建接口是有可能阻塞的（所有连接都忙的时候），所以FastDbClient的同步事务创建接口直接返回空指针，如果要在FastDbClient上使用事务，请使用异步的事务创建接口。
.IP \(bu 2
使用FastDbClient创建Orm的Mapper对象后，使用时也要注意只能使用异步非阻塞接口。
.UNINDENT
.UNINDENT
.UNINDENT
.SS 插件
.sp
插件可以帮助用户构建复杂的应用，在Drogon中，所有的插件都由框架根据配置文件统一构建并安装到应用程序中。Drogon中的插件都是单实例的，用户可以用插件实现任何他们想要的功能。
.sp
Drogon在运行run()接口的时候，会根据配置文件，逐一实例化每个插件，并调用其*initAndStart()*接口。
.SS 配置
.sp
插件配置都在配置文件中完成，例如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"plugins": [
    {
    //name: The class name of the plugin
    "name": "DataDictionary",
    //dependencies: Plugins that the plugin depends on. It can be commented out
    "dependencies": [],
    //config: The configuration of the plugin. This json object is the parameter to initialize the plugin.
    //It can be commented out
    "config": {
    }
    }],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
可见，每个插件的配置共有三项：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
name: 是该插件的类名称(包含命名空间)，框架会根据这个类名称创建插件的实例，这种反射机制在控制器、过滤器的实例创建中也用到过；注释掉该项，则该插件变成禁用状态；
.IP \(bu 2
dependencies: 是该插件所依赖的其他插件的名称列表，框架会按照顺序创建和初始化它们，被依赖的插件首先被创建并初始化；程序结束时，按相反的顺序关闭并销毁它们；需要注意，不要在插件中产生循环依赖，Drogon会检查循环依赖，如果发现，会报错并退出程序；注释掉该项，则依赖列表为空；
.IP \(bu 2
config: 用于初始化该插件的json对象，用户可以在其中自定义任何配置，该对象将被作为入参传入到该插件的*initAndStart()*接口中。注释掉该项，则传入initAndStart接口的json对象为空对象；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 定义
.sp
用户定义的插件必须继承自drogon::Plugin类模板，模板参数就是该插件类型，比如下面的定义：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
class DataDictionary : public drogon::Plugin<DataDictionary>
{
public:
    virtual void initAndStart(const Json::Value &config) override;
    virtual void shutdown() override;
    ...
};
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
当然，命令行程序drogon_ctl提供了创建插件的命令，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
drogon_ctl create plugin <[namespace::]class_name>
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
用户可以用上述命令创建插件的源文件，然后再进一步编辑它们；
.SS 获取实例
.sp
插件的实例由drogon创建，用户可以通过drogon的如下接口获取插件实例：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
template <typename T> T *getPlugin();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
或者
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PluginBase *getPlugin(const std::string &name);
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
显然，第一个方法更方便，例如，前文提到的DataDictionary插件可以这样获取：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
auto *pluginPtr=app().getPlugin<DataDictionary>();
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
注意，获取插件最好在框架的run()接口调用之后，否则会得到未初始化的插件实例(这并不一定必然导致错误，只要在使用它时初始化已经完成即可)。当然，由于插件是按照依赖顺序初始化的，所以，只要依赖关系设置正确，在initAndStart()接口中获取其他插件的实例是没有问题的。
.SS 生命周期
.sp
所有插件在run()接口内初始化完毕，在应用程序退出时才销毁，因此，插件的生命周期几乎和应用程序等同，这也是getPlugin()接口不需要返回智能指针的原因。
.SS 配置文件
.sp
你可以通过DrogonAppFramework实例的多个接口配置各种参数来控制Http服务端的某些行为。不过，使用配置文件是更好的方式，原因如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
使用配置文件而不是源码，可以在运行期而不是编译期决定应用的行为，这无疑是更方便和灵活的方式；
.IP \(bu 2
可以保持main文件的简洁；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
所有的配置接口都有对应的配置文件选项支持，基于上面这些额外的好处，建议应用开发者使用配置文件配置应用的各种参数。
.sp
配置文件的加载很简单，在DrogonAppFramework实例调用run接口之前，调用loadConfigFile接口即可，参数是配置文件的路径和文件名，比如：
\fBmain.cc\fP.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
int main()
{
    drogon::app().loadConfigFile("config.json");
    drogon::app().run();
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
这段程序，加载配置文件*config.json*，然后运行。具体的监听端口、日志输出、数据库配置等等行为都可以由配置文件配置，事实上，这段程序基本就可以是整个webapp应用的主函数的全部代码了。
.SS 文件说明
.sp
配置文件的例子在源码目录的顶层*config.example.json*，如果你使用drogon_ctl create project命令创建工程，那么，在工程目录里也可以找到内容一致的文件*config.json*。所以，你基本上不需要重写，而是对这个文件进行适当的修改，就可以完成对webapp的配置。
.sp
文件是json格式，支持注释，你可以用c++的注释符号/**/和//把不需要的配置项注释掉。
.sp
注释掉配置项后，框架会使用默认值初始化，对应项的默认值在配置文件中都有说明，下面分项详述。
.SS SSL
.sp
ssl项是为了配置https服务的加密配置文件，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"ssl": {
  "cert": "../../trantor/trantor/tests/server.pem",
  "key": "../../trantor/trantor/tests/server.pem"
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中，cert是证书文件路径，key是私钥文件路径，如果一个文件既包含证书也包含私钥，则两个路径可以配制成相同的。
.sp
文件的编码格式PEM。
.SS listeners监听器
.sp
顾名思义，listeners项是为了配置webapp的监听器，它是一个JSON数组类型，每一个JSON对象都表示一个监听，具体的配置如下：
.sp
如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"listeners": [
    {
    "address": "0.0.0.0",
    "port": 80,
    "https": false
    },
    {
    "address": "0.0.0.0",
    "port": 443,
    "https": true,
    "cert": "",
    "key": ""
    }
]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIaddress\fP: 字符串类型，表示监听的IP地址，如果没有该项，则采用默认值”0.0.0.0”
.IP \(bu 2
\fIport\fP: 整数类型，表示监听的端口，必须是合法的端口号，没有默认值，必填项。
.IP \(bu 2
\fIhttps\fP: 布尔类型，表示是否采用https，默认值是false，表示使用http。
.IP \(bu 2
\fIcert\fP and \fIkey\fP: 字符串类型，在https为true时有效，表示https的证书和私钥，默认值是空字符串，表示采用全局的ssl配置的证书和私钥文件；
.UNINDENT
.UNINDENT
.UNINDENT
.SS db_clients
.sp
用于配置数据库客户端，它是一个JSON数组类型，每一个JSON对象都表示一个单独的数据库客户端，具体的配置如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"db_clients":[
  {
    "name":"",
    "rdbms": "postgresql",
    "host": "127.0.0.1",
    "port": 5432,
    "dbname": "test",
    "user": "",
    "passwd": "",
    "is_fast": false,
    "connection_number": 1,
    "file_name": ""
  }
]
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIname\fP: 字符串，客户端名字，默认是”default”，name是应用开发者从框架获取数据库客户端的标记，如果有多项客户端，name字段必须不同，否则，框架不会正常工作；
.IP \(bu 2
\fIrdbms\fP：字符串，表示数据库服务端类型，目前支持”postgresql”和”mysql”，大小写不敏感。
.IP \(bu 2
\fIhost\fP：字符串，数据库服务端地址，localhost是默认值；
.IP \(bu 2
\fIport\fP：整数，数据库服务端的端口号；
.IP \(bu 2
\fIdbname\fP：字符串，数据库名字；
.IP \(bu 2
\fIuser\fP：字符串，用户名；
.IP \(bu 2
\fIpasswd\fP：字符串，密码；
.IP \(bu 2
\fIis_fast\fP：bool，默认false，表明该客户端是否是FastDbClient；
.IP \(bu 2
\fIconnection_number\fP：到数据库服务端的连接数，至少是1，默认值也是1，影响数据读写的并发量；如果is_fast为真，该数值表示每个事件循环的连接数，否则表示总的连接数；
.IP \(bu 2
\fIfilename\fP: sqlite3数据库的文件名；
.UNINDENT
.UNINDENT
.UNINDENT
.SS threads num线程数
.sp
属于app选项的子项，整数，默认值是1，表示框架IO线程数，对网络并发有明确的影响，这个数字并不是越大越好，了解non\-blocking I/O原理的应该知道，这个数值应该和你期望网络IO占用的CPU核心数一致。如果这个参数设为0，那么IO线程数将设置为全部CPU核心数。比如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"threads_num": 16,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
表示，网络IO占用16个线程，在高负荷情况下，最多可以跑满16个CPU核心(线程核心)。
.SS session会话
.sp
会话相关的选项也是app的子项，控制是否采用session和session的超时时间。如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"enable_session": true,
"session_timeout": 1200,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIenable_session\fP：布尔值，表示是否采用会话，默认值是false，如果客户端不支持cookie，请设为false，因为框架会为每个不带会话cookie的请求创建新的会话，如果客户端不支持cookie而又有大量请求，则服务端会生成大量的无用session对象，这是完全没必要的资源和性能损失；
.IP \(bu 2
\fIsession_timeout\fP：整数值，表示会话的超时时间，单位是秒，默认值是0，只有enable_session为true时才发挥作用。0表示永久有效。
.UNINDENT
.UNINDENT
.UNINDENT
.SS document_root 根目录
.sp

.nf
*
.fi
app*项的子项，字符串，表示Http根目录对应的文档路径，是静态文件下载的根路径，默认值是”./”，表示程序运行的当前路径。比如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"document_root": "./",
.ft P
.fi
.UNINDENT
.UNINDENT
.SS upload_path上传文件路径
.sp
app项的子项，字符串，表示上传文件的默认路径，默认值是”uploads”，如果这个值不是*/,./\fI或\fP\&../\fI开始的，并且这个值也不是\fP\&.*或*..*，则这个路径是前面document_root项的相对路径，否则就是一个绝对路径或者当前目录的相对路径。如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"upload_path":"uploads",
.ft P
.fi
.UNINDENT
.UNINDENT
.SS file_types文件类型
.sp
app项的子项，字符串数组，默认值如下，表示框架支持的静态文件下载类型，如果请求的静态文件扩展名在这些类型之外的，框架将返回404错误。
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"file_types": [
    "gif",
    "png",
    "jpg",
    "js",
    "css",
    "html",
    "ico",
    "swf",
    "xap",
    "apk",
    "cur",
    "xml"
    ],
.ft P
.fi
.UNINDENT
.UNINDENT
.SS connections连接数控制
.sp
app项的子项，有两个选项，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"max_connections": 100000,
"max_connections_per_ip": 0,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fImax_connections\fP：整数，默认值是100000，表示同时并发的最大连接数；当服务端维持的连接达到这个数量时，新的TCP连接请求将被直接拒绝。
.IP \(bu 2
\fImax_connections_per_ip\fP：整数，默认值是0，表示单个IP的最大连接数，0表示没有限制。
.UNINDENT
.UNINDENT
.UNINDENT
.SS log日志选项
.sp
app项的子项，同时也是个JSON对象，控制日志输出的行为，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"log": {
    "log_path": "./",
    "logfile_base_name": "",
    "log_size_limit": 100000000,
    "log_level": "TRACE"
    },
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIlog_path\fP：字符串，默认值是空串，表示文件存放的路径，如果是空串，则所有日志输出到标准输出；
.IP \(bu 2
\fIlogfile_base_name\fP：字符串，表示日志文件的*basename*，默认值是空串，这时basename将为drogon；
.IP \(bu 2
\fIlog_size_limit\fP：整数，单位是字节，默认值是100000000(100M)，当日志文件的大小达到这个数值时，日志文件会切换。
.IP \(bu 2
\fIlog_level\fP：字符串，默认值是”DEBUG”，表示日志输出的最低级别，可选值从低到高为：”TRACE”,”DEBUG”,”INFO”,”WARN”，其中的TRACE级别只有在DEBUG编译的情况下才有效。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意： Drogon的文件日志采用了非阻塞输出结构，大概可以达到每秒百万行的日志输出能力，可以放心使用。
.UNINDENT
.UNINDENT
.SS 应用控制
.sp
也是app子项，有两个控制项，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"run_as_daemon": false,
"relaunch_on_error": false,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
run_as_daemon：布尔值，默认值是false，当为true时，应用程序将以daemon的形式变成1号进程的子进程运行于系统后台。
.IP \(bu 2
relaunch_on_error：布尔值，默认值时false，当为true时，应用程序将fork一次，子进程执行真正的工作，父进程什么都不干，只负责在子进程崩溃或因其它原因退出时重启子进程，这是一种简单的服务保护机制。
.UNINDENT
.UNINDENT
.UNINDENT
.SS use_sendfile发送文件
.sp
app子选项，布尔值，表示在发送文件时是否采用linux系统调用sendfile，默认值时true，使用sendfile可以提高发送效率，减少大文件的内存占用。如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"use_sendfile": true,
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意：即使该项为true，sendfile系统调用也不一定会采用，因为小文件使用sendfile并不一定划算，框架会根据自己的优化策略决定是否采用。
.UNINDENT
.UNINDENT
.SS use_gzip压缩传输
.sp

.nf
*
.fi
app*子选项，布尔值，默认值是true，表示Http响应的Body是否采用压缩传输。当该项为true时，下面的情况采用压缩传输：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
客户端支持gzip压缩；
.IP \(bu 2
body是文本类型；
.IP \(bu 2
body的长度大于一定值；
.UNINDENT
.UNINDENT
.UNINDENT
.sp
配置例子如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"use_gzip": true,
.ft P
.fi
.UNINDENT
.UNINDENT
.SS files_cache_time文件缓存时间
.sp

.nf
*
.fi
app*子选项，JSON对象数组，每一项表示一个从Http路径到HttpSimpleController的映射，这种配置只是一个可选途径，并不是必须配置在这里，请参阅HttpSimpleController。 具体的配置如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"static_files_cache_time": 5,
.ft P
.fi
.UNINDENT
.UNINDENT
.SS simple_controllers_map
.sp

.nf
*
.fi
app*子选项，JSON对象数组，每一项表示一个从Http路径到HttpSimpleController的映射，这种配置只是一个可选途径，并不是必须配置在这里，请参阅HttpSimpleController。 具体的配置如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"simple_controllers_map": [
    {
        "path": "/path/name",
        "controller": "controllerClassName",
        "http_methods": ["get","post"],
        "filters": ["FilterClassName"]
    }
    ],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIpath\fP：字符串，Http路径；
.IP \(bu 2
\fIcontroller\fP：字符串，HttpSimpleController的名字；
.IP \(bu 2
\fIhttp_methods\fP：字符串数组，支持的Http方法，这个列表之外的会被过滤掉，返回405错误；
.IP \(bu 2
\fIfilters\fP：字符串数组，路径上的filter列表，参见过滤器；
.UNINDENT
.UNINDENT
.UNINDENT
.SS idle_connection_timeout空闲连接超时控制
.sp
app子选项，整数值，单位秒，默认值是60，当一个连接超过这个数值的时间没有任何读写的时候，该连接将会被强制断开。
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"idle_connection_timeout":60
.ft P
.fi
.UNINDENT
.UNINDENT
.SS dynamic_views动态视图加载
.sp
app的子选项，控制动态视图的使能和路径，有两个选项，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"load_dynamic_views":true,
"dynamic_views_path":["./views"],
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
其中：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIdynamic_views_path\fP：布尔值，默认值是false，当为true时，框架会在视图路径中搜索视图文件，并动态编译成so文件，然后加载进应用，当任何视图文件发生变化时，也会引起自动编译和重新加载；
.IP \(bu 2
\fIdynamic_views_path\fP：字符串数组，每一项表示动态视图的搜索路径，如果路径值不是*/,./\fI或\fP\&../\fI开始的，并且这个值也不是\fP\&.*或*..*，则这个路径是前面document_root项的相对路径，否则就是一个绝对路径或者当前目录的相对路径。
.UNINDENT
.UNINDENT
.UNINDENT
.sp
参见视图。
.SS server_header_field头字段
.sp
app的子选项，配置由框架发送的所有response的Server头字段，默认值是空串，当该选项为空时，框架会自动生成形如*Server: drogon/version string*的头字段。如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"server_header_field": ""
.ft P
.fi
.UNINDENT
.UNINDENT
.SS keepalive_requests长连接请求数
.sp
\fIkeepalive_requests\fP 选项设置客户端在一个keepalive长连接上可以发送的最大请求数。当达到这个请求数时，长连接将被关闭。默认值0代表没有限制。如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"keepalive_requests": 0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Pipelining请求数
.sp
\fIpipelining_requests*选项用于设置长连接上已接收但未必处理的最大的请求数。当这个数字达到时，长连接将被关闭。默认值0代表没有限制。关于pipelining的详细描述，请参阅标准文档*rfc2616\-8.1.1.2\fP。配置如下所示：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
"pipelining_requests": 0
.ft P
.fi
.UNINDENT
.UNINDENT
.SS drogon_ctl命令
.sp
Drogon框架编译安装后，一个命令行程序*drogon_ctl*也同时被安装于系统，为了方便，还安装了一个完全一样的副本dg_ctl。用户可以按喜好自行选用。
.sp
该程序目前的主要功能是为了方便用户创建各种drogon工程文件，使用*dg_ctl help*命令可以看到它支持的功能，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl help
usage: drogon_ctl <command> [<args>]
commands list:
create                  create some source files(Use \(aqdrogon_ctl help create\(aq for more information)
help                    display this message
version                 display version of this tool
press                   Do stress testing(Use \(aqdrogon_ctl help press\(aq for more information)
.ft P
.fi
.UNINDENT
.UNINDENT
.SS version子命令
.sp

.nf
*
.fi
version*子命令用于打印目前安装于系统的drogon版本，如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
     _
  __| |_ __ ___   __ _  ___  _ __
 / _\(ga | \(aq__/ _ \e / _\(ga |/ _ \e| \(aq_ \e
| (_| | | | (_) | (_| | (_) | | | |
 \e__,_|_|  \e___/ \e__, |\e___/|_| |_|
                  |___/
drogon ctl tools
version:0.9.30.771
git commit:d4710d3da7ca9e73b881cbae3149c3a570da8de4
compile config:\-O3 \-DNDEBUG \-Wall \-std=c++17 \-I/root/drogon/trantor \-I/root/drogon/lib/inc \-I/root/drogon/orm_lib/inc \-I/usr/local/include \-I/usr/include/uuid \-I/usr/include \-I/usr/include/mysql
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS create子命令
.sp

.nf
*
.fi
create*子命令用于创建各种对象，目前是drogon_ctl的主要功能，使用*dg_ctl help create*命令可以打印该命令的详细帮助，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl help create

Use create command to create some source files of drogon webapp

Usage:drogon_ctl create <view|controller|filter|project|model> [\-options] <object name>

drogon_ctl create view <csp file name> //create HttpView source files from csp file

drogon_ctl create controller [\-s] <[namespace::]class_name> //create HttpSimpleController source files

drogon_ctl create controller \-h <[namespace::]class_name> //create HttpController source files

drogon_ctl create controller \-w <[namespace::]class_name> //create WebSocketController source files

drogon_ctl create filter <[namespace::]class_name> //create a filter named class_name

drogon_ctl create project <project_name> //create a project named project_name

drogon_ctl create model <model_path> //create model classes in model_path
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 视图创建
.sp

.nf
*
.fi
dg_ctl create controller*命令用于帮助用户创建控制器的源文件，drogon目前支持的三种控制器都可以由该命令创建，只是参数稍有差别。
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create view UsersList.csp
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 控制器创建
.sp

.nf
*
.fi
dg_ctl create controller*命令用于帮助用户创建控制器的源文件，drogon目前支持的三种控制器都可以由该命令创建，只是参数稍有差别。
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
创建HttpSimpleController的命令如下：
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller SimpleControllerTest
dg_ctl create controller webapp::v1::SimpleControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
最后一个参数是控制器的类名，可以在前面附加命名空间。
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
创建HttpController的命令如下：
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller \-h ControllerTest
dg_ctl create controller \-h api::v1::ControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.IP \(bu 2
创建WebSocketController的命令如下：
.INDENT 2.0
.INDENT 3.5
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create controller \-w WsControllerTest
dg_ctl create controller \-w api::v1::WsControllerTest
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
参考wiki的控制器各个章节。
.SS 过滤器创建
.sp

.nf
*
.fi
dg_ctl create filter*命令用于帮助用户创建过滤器的源文件，参见过滤器一节。
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create filter LoginFilter
dg_ctl create filter webapp::v1::LoginFilter
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 创建工程
.sp
用户创建一个新的Drogon应用工程的方法是通过drogon_ctl命令实现，如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create project ProjectName
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
该命令执行完后，在当前目录会创建完整的工程目录，目录名是ProjectName,用户可以直接进build目录编译这个工程，当然他没有任何业务逻辑。
.sp
工程的目录结构如下：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
├── build                         构建文件夹
├── CMakeLists.txt                工程的cmake配置文件
├── cmake_modules                 第三方库查找的cmake脚本
│   ├── FindJsoncpp.cmake
│   ├── FindMySQL.cmake
│   ├── FindSQLite3.cmake
│   └── FindUUID.cmake
├── config.json                   drogon应用的配置文件，请参考配置文件介绍章节
├── controllers                   存放控制器源文件的目录
├── filters                       存放过滤器文件的目录
├── main.cc                       主程序
├── models                        数据库模型文件的目录，模型源文件创建见11.2.5
│   └── model.json
└── views                         存放视图csp文件的目录，源文件无需用户手动创建，工程编译时会自动预处理csp文件得到视图的源文件
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 创建模型
.sp
使用*dg_ctl create model*命令创建数据库模型源文件，最后一个参数是模型存放的目录，该目录里必须包含一个名为model.json的模型配置文件，用于告诉dg_ctl如何连接数据库以及映射哪些表。
.sp
比如，如果要在上面提到的工程目录里创建模型，请在工程目录下执行如下命令：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl create model models
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
该命令会提示用户目录下已有的文件将被直接覆盖，用户输入y确认后就会生成所有模型文件。其他文件要引用模型类需要include模型的头文件，比如：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include "models/User.h"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
注意要包含models目录名，这是为了区分同一个工程中多个数据源的情况。参见ORM。
.UNINDENT
.UNINDENT
.SS 压力测试
.sp
用户可以使用dg_ctl press命令进行压力测试，该命令有几个选项
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fI\-n num\fP 设置请求的总数(默认是1)
.IP \(bu 2
\fI\-t num\fP 设置线程总数(默认是1), 设置成CPU数目可以达到最大性能
.IP \(bu 2
\fI\-c num\fP  设置并发连接数(默认是1)
.IP \(bu 2
\fI\-q\fP 表示没有中间过程的信息输出(默认输出信息)
.UNINDENT
.UNINDENT
.UNINDENT
.sp
例子:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
dg_ctl press \-n1000000 \-t4 \-c1000 \-q http://localhost:8080/
dg_ctl press \-n 1000000 \-t 4 \-c 1000 https://www.domain.com/path/to/be/tested
.ft P
.fi
.UNINDENT
.UNINDENT
.SS AOP面向切面编程
.sp
AOP(面向切面编程)是实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
.sp
限于C++语言的特性，Drogon没有提供像Spring那样灵活的AOP方案，而是一种简单的AOP，所有插入点都是内建于框架中的，用户可以通过框架的AOP系列接口注册特定的处理程序到插入点上。
.SS 内建插入点
.sp
Drogon提供了7个插入点供用户使用，当应用程序运行至插入点的时候，会依次调用用户注册的处理程序（Advice）。关于插入点的说明如下：
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Beginning: 顾名思义，该插入点在程序开始时到达，具体地说，所有注册在这个插入点上的处理程序会在app().run()方法运行完毕后立即执行。在这个插入点上，所有的controller，filter，plugin，database client都构建完毕了，用户可以在这里得到想要的对象引用或进行一些其他初始化工作，该插入点上的advice只运行一次，调用类型是*void()*，注册接口是*registerBeginningAdvice*;
.IP \(bu 2
NewConnection: 注册到这个插入点上的处理程序会在每个新TCP连接建立时运行，Advice的调用类型是*bool(const trantor::InetAddress &, const trantor::InetAddress &)*，其中第一个参数是TCP连接的远端地址，第二个参数是本地地址，注意返回类型是bool，如果用户返回false，相应的连接将被断开。注册的接口是*registerNewConnectionAdvice*;
.IP \(bu 2
HttpResponseCreation: 注册到这个插入点上的处理程序会在每个HTTP Response对象创建时运行，Advice的调用类型是*void(const HttpResponsePtr &)*，其中的参数就是新创建的对象，用户可以在这个处理程序中对所有Response进行一些统一的操作，比如添加某个特殊的header等，这个插入点会影响所有的Response，包括404或任何drogon内部产生的错误响应，也包括应用产生的所有响应。注册的接口是*registerHttpResponseCreationAdvice*;
.IP \(bu 2
Sync: 这个插入点的位置在Http请求处理的最前端，用户可以在这里通过返回一个非空的Response对象来拦截这个请求，Advice调用类型是*HttpRequestPtr(const HttpRequestPtr &)*，注册接口是*registerSyncAdvice*;
.IP \(bu 2
Pre\-Routing: 这个插入点的位置在框架为客户端的请求寻找相应的处理器之前，Advice的调用类型有两个，\fIvoid(const HttpRequestPtr &,AdviceCallback &&,AdviceChainCallback &&)*和*void(const HttpRequestPtr &)\fP, 前一个和Filter的doFilter方法的调用类型完全一致，实际上，它们的运行方式也是一样的（请参考过滤器），用户可以通过这种Advice拦截客户端请求或者让它通过，后一种调用类型没有拦截能力，不过消耗更低，如果用户不打算拦截，请选择这种Advice注册。注册的接口是*registerPreRoutingAdvice*;
.IP \(bu 2
Post\-Routing: 这个插入点的位置在找到处理器之后和HTTP方法检测及过滤器处理之前，Advice的调用类型和上个插入点一致，注册接口是*registerPostRoutingAdvice*;
.IP \(bu 2
Pre\-Handling: 这个插入点的位置在通过了所有过滤器之后和处理器处理之前，Advice的调用类型和上个插入点一致，注册接口是*registerPreHandlingAdvice*;
.IP \(bu 2
Post\-Handling: 这个插入点的位置在处理器处理完成生成Response之后和发送给客户端之前，Advice的调用类型是*void(const HttpRequestPtr &, const HttpResponsePtr &)*，注册接口是*registerPostHandlingAdvice*;
.UNINDENT
.UNINDENT
.UNINDENT
.SS AOP示意图
.sp
下图展示了上述的后面四个插入点在HTTP Request处理流程中的位置，其中的红色圆点代表插入点，绿色的箭头路径都代表异步调用。
.SS 性能测试
.sp
作为C++的Http应用框架，性能应该是关注的重点之一，本节介绍Drogon的简单测试和成绩；
.SS 测试环境
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
系统是Linux CentOS 7.4；
.IP \(bu 2
设备是Dell服务器，CPU是两颗Intel(R) Xeon(R) CPU E5\-2670 @ 2.60GHz，16核32线程；
.IP \(bu 2
内存64GB；
.IP \(bu 2
gcc版本7.3.0；
.UNINDENT
.UNINDENT
.UNINDENT
.SS 测试方案和结果
.sp
我们只是为了测试drogon框架的性能，因而要尽量简化controller的处理，我们只做了一个HttpSimpleController，注册到*/benchmark*路径上。controller对任何请求都返回*<p>Hello, world!</p>*。设置drogon线程数为16。handler函数的代码如下, 你可以在*drogon/examples/benchmark*目录找到这些源码：
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
void BenchmarkCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req, std::function<void (const HttpResponsePtr &)> &&callback)
{
    //write your application logic here
    auto resp = HttpResponse::newHttpResponse();
    resp\->setBody("<p>Hello, world!</p>");
    resp\->setExpiredTime(0);
    callback(resp);
}
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
作为对比，我选取了nginx来做对比测试，使用nginx+module源码编译的方式，写了一个hello_world_module，测试时nginx的worker_processes参数设为16。
.sp
测试工具是一个性能不错的HTTP压力测试工具*httpress*。
.sp
我们调整httpress的参数，每组参数测试五次，记录每秒处理请求数的最大值和最小值。测试结果如下表：
.TS
center;
|l|l|l|l|.
_
T{
命令行
T}	T{
说明
T}	T{
Drogon(千QPS)
T}	T{
nginx(千QPS)
T}
_
T{
httpress \-c 100 \-n 1000000 \-t 16 \-k \-q URL
T}	T{
100连接，100万请求，16线程，Keep\-Alive
T}	T{
561/552
T}	T{
330/329
T}
_
T{
httpress \-c 100 \-n 1000000 \-t 12 \-q URL
T}	T{
100连接，100万请求，12线程，一次请求一次连接
T}	T{
140/135
T}	T{
31/49
T}
_
T{
httpress \-c 1000 \-n 1000000 \-t 16 \-k \-q URL
T}	T{
1000连接，100万请求，16线程，Keep\-Alive
T}	T{
573/565
T}	T{
333/327
T}
_
T{
httpress \-c 1000 \-n 1000000 \-t 16 \-q URL
T}	T{
1000连接，100万请求，16线程，一次请求一次连接
T}	T{
155/143
T}	T{
52/50
T}
_
T{
httpress \-c 10000 \-n 4000000 \-t 16 \-k \-q URL
T}	T{
10000连接，400万请求，16线程，Keep\-Alive
T}	T{
512/508
T}	T{
316/314
T}
_
T{
httpress \-c 10000 \-n 1000000 \-t 16 \-q URL
T}	T{
10000连接，100万请求，16线程，一次请求一次连接
T}	T{
143/141
T}	T{
43/40
T}
_
.TE
.sp
可以看到，在客户端使用Keep\-Alive选项，在一个连接可以发送多个请求的情况下，drogon每秒可以处理50多万次请求，这个成绩是相当不错的。每次请求都发起一次连接的情况下，CPU会消耗在TCP建立和断开等环节，吞吐量会下降至每秒14万次请求，这也是正常的。drogon对比nginx的成绩处于明显优势，也许是由于nginx配置不当未能发挥它的最大吞吐量，如果哪位高手做了更好的测试，欢迎指正。
.sp
下图是某一次测试的截图：
.sp
测试截图
.SS Coz
.SS Causal profiling with coz
.sp
With coz you can profile two things:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
throughput
.IP \(bu 2
latency
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If you want to profile throughput of your application, you should switch on the \fICOZ_PROFILING\fP cmake option and include debug information in your exectuable with \fIDebug\fP or \fIRelWithDebInfo\fP release modes in cmake. Doing so will include coz progress points when serving a request. Profiling latency is currently not supported in whole application scope, but can still be done in user code.
.sp
When you’re done compiling you application with progress points included. You need to run the executable with the coz profiler, for example \fIcoz run — [path to your executable]\fP\&.
.sp
Lastly, the application needs to be stressed, for best results you need to stress all code paths and run the profile for a good amount of time, 15+ min.
.sp
The final profile will be a \fIprofile.coz\fP file created in the current working directory. To view results, open the profile in the official \fI\%viewer\fP , or you could run a local copy from the official \fI\%git repo\fP .
.sp
Coz also supports scoping source files included for the profile with –source\-scope <pattern> or \-s <pattern> among other things, that should prove useful.
.sp
For more information checkout:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
coz run –help
.IP \(bu 2
\fI\%Git repo\fP
.IP \(bu 2
\fI\%Coz whitepaper\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
an-tao
.SH COPYRIGHT
2020, an-tao
.\" Generated by docutils manpage writer.
.
