# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, an-tao
# This file is distributed under the same license as the drogon package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: drogon \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-19 19:28+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/DataBase-DbClient-zh.rstd:3
msgid "数据库 Dbclient"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:7
msgid "构建DbClient"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:9
msgid "构造DbClient对象有两种途径，一个是通过DbClient类的静态方法，在DbClient.h头文件可以看到定义，如下:"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:20
msgid "得到DbClient实现对象的智能指针，参数connInfo是个连接字符串，采用key=value的形式设置一系列连接参数，具体说明见头文件的注释。参数connNum是DbClient的连接数，即该对象管理的数据库连接个数，对并发有关键影响，请根据实际情况设置。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:22
msgid "通过这种方法得到的对象，用户要想办法**持久化**，比如放在某些全局容器内，**创建临时对象，使用完再释放是非常不推荐的方案**，理由如下："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:24
msgid "白白的浪费创建连接和断开连接的时间，增加了系统时延；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:25
msgid "该接口也是非阻塞接口，也就是说，用户拿到DbClient对象时，它管理的连接还没建立起来，框架没有（故意的）提供连接建立成功的回调接口，难道还要sleep一下再开始查询么？这和异步框架的初衷相违背。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:27
msgid "所以，应该在程序开始之初就构建这些对象，并在整个生存周期持有并使用它。显然，这个工作完全可以由框架来做，因此，框架提供了第二种构建方式，就是通过配置文件构建或使用createDbClient接口创建，配置方法见配置文件。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:29
msgid "需要使用时，通过框架的接口获得DbClient的智能指针，接口如下（注意该接口必须在app.run()调用后才能得到正确的对象）："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:35
msgid "参数name就是配置文件中的name配置项的值，用以区分同一个应用的多个不同的DbClient对象。DbClient管理的连接总是断线重连的，所以用户不用关心连接状态，他们几乎总是正常连接的状态。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:38
msgid "Note: This method cannot be called before running app.run(), otherwise the user will get an empty shared_ptr."
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:42
msgid "执行接口"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:44
msgid "DbClient对外提供了几种不同的接口，列举如下："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:71
msgid "因为涉及任意数量和类型的绑定参数，因此这些接口都是函数模板。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:73
msgid "这些接口的性质如下表所示："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:76
msgid "接口"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:76
msgid "同步/异步"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:76
msgid "阻塞/非阻塞"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:76
msgid "异常"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:78
msgid "void execSqlAsync"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:78
#: ../../source/DataBase-DbClient-zh.rstd:79
#: ../../source/DataBase-DbClient-zh.rstd:81
msgid "异步"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:78
msgid "非阻塞"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:78
#: ../../source/DataBase-DbClient-zh.rstd:81
msgid "不抛异常"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:79
msgid "std::future execSqlAsyncFuture"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:79
msgid "调用future的get方法时阻塞"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:79
msgid "调用future的get方法时可能抛异常"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:80
msgid "const Result execSqlSync"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:80
msgid "同步"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:80
msgid "阻塞"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:80
msgid "可能抛异常"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:81
msgid "internal::SqlBinder operator<<"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:81
msgid "默认非阻塞，也可以阻塞"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:84
msgid "你可能对异步和阻塞的组合有点困惑，一般而言，同步接口涉及网络IO都是阻塞的，异步接口则是非阻塞的，不过，异步接口也可以工作于阻塞模式，意思是说，这个接口会阻塞一直等到回调函数执行完毕才会退出。DbClient的异步接口工作于阻塞模式时，回调函数会在同一个线程被执行，然后该接口才执行完毕。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:86
msgid "如果你的应用涉及高并发场景，请选择异步非阻塞接口，如果是低并发场景，比如一个网络设备的管理页面，则可以出于直观方便的考虑，选择同步接口。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:89
msgid "execSqlAsync"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:101
msgid "这是最常使用的异步接口，工作于非阻塞模式；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:103
msgid "参数*sql*是sql语句的字符串，如果有需要绑定参数的占位符，使用相应数据库的占位符规则，比如PostgreSQL的占位符是$1,$2..，而MySQL的占位符是*?*。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:105
msgid "不定参数*args*代表绑定的参数，可以是零个或多个，具体数据和sql语句的占位符个数一致，类型可以是以下几类："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:107
msgid "整数类型：可以是各种字长的整数，应和数据库字段类型相匹配；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:108
msgid "浮点类型：可以是*float*或者*double*，应和数据库字段类型相匹配；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:109
msgid "字符串类型：可以是*std::string*或者*const char[]*，对应数据库的字符串类型或者其他可以用字符串表示的类型；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:110
msgid "日期类型：*trantor::Date*类型，对应数据库的date，datetime，timestamp等字段类型。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:111
msgid "二进制类型：*std::vector<char>*类型，对应PostgreSQL的bytea类型或者Mysql的blob类型；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:113
msgid "这些参数可以是左值，也可以是右值，可以是变量，也可以是字面常量，用户可以自由掌握。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:115
msgid "参数rCallback和exceptCallback分别表示结果回调函数和异常回调函数，它们有固定的定义，如下："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:117
msgid "结果回调函数：调用类型为void (const Result &)，符合这个调用类型的各种可调用对象，std::function,lambda等等都可以作为参数传入；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:118
msgid "异常回调函数：调用类型为void (const DrogonDbException &)，可传入和这个调用类型一致的各种可调用对象；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:120
msgid "sql执行成功后，执行结果由Result类包装并通过结果回调函数传递给用户；如果sql执行有任何异常，异常回调函数被执行，用户可以从DrogonDbException对象获得异常信息。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:122
msgid "我们举个例子："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:141
msgid "从例子中我们可以看出，Result对象是个std标准兼容的容器，支持迭代器，它封装的结果集可以通过范围循环取到每一行的对象，Result，Row和Field对象的各种接口，请参考源码；"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:143
msgid "DrogonDbException类是所有数据库异常的基类，具体的定义和它子类的说明，请参考源码中的注释。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:146
msgid "execSqlAsyncFuture"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:154
msgid "异步futrue接口省略了前一个接口的中间两个参数（使用future对象代替回调函数），调用这个接口会立即返回一个future对象，用户必须调用future的get()方法，得到返回的结果，异常要通过try/catch机制得到，如果调用get()方法时没有try/catch，并且整个调用堆栈中也没有try/catch，则程序会在sql执行发生异常的时候退出。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:156
#: ../../source/DataBase-DbClient-zh.rstd:188
msgid "例如:"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:178
msgid "execSqlSync"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:186
msgid "同步接口是最简单直观的，输入参数是sql字符串和绑定的参数，返回一个Result对象，调用会阻塞当前线程，并且在出现错误时抛异常，所以也要注意*try/catch*捕获异常。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:205
msgid "operator<<"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:211
msgid "流式接口比较特殊，它把sql语句和参数依次通过*<<*操作符输入，而通过*>>*操作符指定结果回调函数和异常回调函数，比如前面select的例子，使用流式接口是如下的样子：:"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:231
msgid "这种写法和第一种异步非阻塞接口是完全等效的，采用哪种接口取决于用户的使用习惯。如果想让它工作于阻塞模式，可以使用*<<*输入一个*Mode::Blocking*参数，这里不再赘述。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:233
msgid "另外，流式接口还有一个特殊的用法，使用一种特殊的结果回调，可以让框架逐行的把结果传递给用户，这种回调的调用类型如下："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:239
msgid "第一个bool参数为true时，表示这次回调是一个空行，也就是，所有结果都已经返回了，这是最后一次回调； 后面是一系列参数，对应一行记录的每一列的值，框架会做好类型转换，当然，用户也要注意类型的匹配。这些类型可以是const型的左值引用，也可以是右值引用，当然也可以是值类型。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:241
msgid "我们再把上一个例子用这种回调重写一下："
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:260
msgid "可以看到，select语句中的user_name和user_id字段的值，被分别赋给了回调函数中的name和id变量，用户无需自己处理这些转换，这显然提供了一定的便利性，用户可以在实践中灵活运用。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:263
msgid "注意: 借着这个例子，要强调一点异步编程必须注意的地方，就是上面例子中的变量i，用户必须保证在回调发生时，变量i还是有效的，因为它是被引用捕获的，它的有效性并不是理所当然的，回调会在别的线程被调用，而回调发生时，当前的上下文环境很可能已经失效了。类似的场景常常使用智能指针持有临时创建的变量，再被回调捕获，从而保证变量的有效性。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:267
msgid "总结"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:269
msgid "每个DbClient对象有且仅有一个自己的EventLoop线程，这个线程负责控制数据库连接IO，通过异步或同步接口接受请求，再通过回调函数返回结果。"
msgstr ""

#: ../../source/DataBase-DbClient-zh.rstd:271
msgid "它虽然也提供阻塞的接口，这种接口只是阻塞调用者线程，只要调用者线程不是EventLoop线程，就不会影响EventLoop线程的正常运转。回调函数被调用时，回调内的程序是运行在EventLoop线程的，所以，不要在回调内部进行任何阻塞操作，否则会影响数据库的并发，熟悉non-blocking I/O编程的人都应该明白这个约束。"
msgstr ""

