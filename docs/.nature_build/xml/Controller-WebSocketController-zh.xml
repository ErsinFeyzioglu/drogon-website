<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Controller-WebSocketController-zh.rstd">
    <section ids="websocketcontroller" names="控制器\ websocketcontroller">
        <title>控制器 WebSocketController</title>
        <section ids="id1" names="websocketcontroller">
            <title>WebSocketController</title>
            <paragraph>顾名思义，<problematic ids="id3" refid="id2">*</problematic>WebSocketController*用于处理websocket逻辑。websocket是基于HTTP的一种长连接方案，在websocket建立之初，有一次HTTP格式的请求和应答交换，建立完成后，所有的消息在websocket上传输，消息由固定的格式包装，但消息的内容和收发次序没有任何要求，完全由用户定义。</paragraph>
            <paragraph>可以由*drogon_ctl*工具快速生成*WebSocketController*的源文件，命令格式如下：:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -w &lt;[namespace::]class_name&gt;</literal_block>
            <paragraph>假设我们要通过websocket实现一个简单的回声功能，即服务端只是简单的把客户端发来的消息再发回去，通过drogon_ctl创建WebSocketController的实现类EchoWebsock，如下:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -w EchoWebsock</literal_block>
            <paragraph>该命令会生成EchoWebsock.h和EchoWebsock.cc两个文件，</paragraph>
            <container classes="literal-block-wrapper" ids="id6" literal_block="True">
                <caption><emphasis>EchoWebsock.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/WebSocketController.h&gt;
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController&lt;EchoWebsock&gt;
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&amp;,
                                std::string &amp;&amp;)override;
    virtual void handleNewConnection(const HttpRequestPtr &amp;,
                                    const WebSocketConnectionPtr&amp;)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&amp;)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_LIST_END
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id7" literal_block="True">
                <caption><emphasis>EchoWebsock.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &amp;wsConnPtr,std::string &amp;&amp;message)
{
    //write your application logic here
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}</literal_block>
            </container>
            <paragraph>编辑后内容如下：</paragraph>
            <container classes="literal-block-wrapper" ids="id8" literal_block="True">
                <caption><emphasis>EchoWebsock.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/WebSocketController.h&gt;
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController&lt;EchoWebsock&gt;
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&amp;,
                                std::string &amp;&amp;)override;
    virtual void handleNewConnection(const HttpRequestPtr &amp;,
                                    const WebSocketConnectionPtr&amp;)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&amp;)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_ADD("/echo");
    WS_PATH_LIST_END
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id9" literal_block="True">
                <caption><emphasis>EchoWebsock.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &amp;wsConnPtr,std::string &amp;&amp;message)
{
    //write your application logic here
    wsConnPtr-&gt;send(message);
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}</literal_block>
            </container>
            <paragraph>首先，在这个例子中，通过*WS_PATH_ADD*宏把这个控制器注册到了*/echo*路径上，<problematic ids="id5" refid="id4">*</problematic>WS_PATH_ADD*宏的用法跟之前介绍的其他控制器的宏类似，也可以注册路径并且附带若干过滤器Filter。由于websocket在框架中单独处理，所以它可以和前两种控制器的路径重复而不会相互影响。</paragraph>
            <paragraph>其次，本例中三个虚函数的实现，只有handleNewMessage有实质内容，只是简单的把收到的消息通过send接口发回客户端。把这个控制器编译进框架，就可以看到效果，请各位自己试验吧。</paragraph>
            <note>
                <paragraph>注意：和通常的HTTP协议一样，http的websocket可以被旁路还原，如果需要安全保障，应由https提供加密功能，当然，用户自己在服务端和客户端完成加密和解密也是可以的，只是https更方便，底层都由drogon处理，用户只需关心业务逻辑。</paragraph>
            </note>
            <paragraph>用户自定义的WebSocketController类继承自drogon::WebSocketController类模板，模板参数是子类类型，用户需自己实现如下三个虚函数来对websocket的建立、关闭和消息进行处理：</paragraph>
            <comment xml:space="preserve">cpp::function:: virtual void handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConn)</comment>
            <comment xml:space="preserve">cpp::function:: virtual void handleNewMessage(const WebSocketConnectionPtr &amp;wsConn,std::string &amp;&amp;message);</comment>
            <comment xml:space="preserve">cpp::function:: virtual void handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConn);</comment>
            <paragraph>容易知道:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>handleNewConnection is called after the websocket is established. req is the setup request sent by the client. At this time, the framework has returned the response. What users can do is to get some additional information through req, such as token. wsConn is a smart pointer to this websocket object, and the commonly used interface will be discussed later.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>handleNewMessage is called after the websocket receives the new message. The message is stored in the message variable. Note that the message is the message payload. The framework has finished the decapsulation and decoding of the message. The user can directly process the message itself.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>handleConnectionClosed is called after the websocket connection is closed, and the user can do some finishing work.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="websocketconnection" names="websocketconnection">
            <title>WebSocketConnection</title>
            <paragraph>WebSocketConnection对象常用接口如下：</paragraph>
            <container classes="literal-block-wrapper" ids="id10" literal_block="True">
                <caption><emphasis>WebSocketConnection.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">//发送websocket消息，消息的编码和封包都由框架负责，这里直接发送消息的净荷
//of the message are the responsibility of the framework
void send(const char *msg,uint64_t len);
void send(const std::string &amp;msg);

//本websocket的本端和远端地址
const trantor::InetAddress &amp;localAddr() const;
const trantor::InetAddress &amp;peerAddr() const;

//本weosocket的连接状态
bool connected() const;
bool disconnected() const;

//关闭本websocket
void shutdown();//close write
void forceClose();//close

//设置和获取本websocket的上下文，由用户存入一些业务数据，
//any类型意味着可以存取任意类型的对象。
void setContext(const any &amp;context);
const any &amp;getContext() const;
any *getMutableContext();</literal_block>
            </container>
        </section>
    </section>
</document>
