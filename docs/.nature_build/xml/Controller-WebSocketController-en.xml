<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Controller-WebSocketController-en.rstd">
    <section ids="controller-websocketcontroller" names="controller\ websocketcontroller">
        <title>Controller WebSocketController</title>
        <section ids="websocketcontroller" names="websocketcontroller">
            <title>WebSocketController</title>
            <paragraph>As the name implies, <emphasis>WebSocketController</emphasis> is used to process websocket logic. Websocket is a persistent HTTP-based connection scheme. At the beginning of the websocket, there is an HTTP format request and response exchange. After the websocket connection is established, all messages are transmitted on the websocket. The message is wrapped in a fixed format. There is no limit to the message content and the order in which messages are transmitted.</paragraph>
            <paragraph>The source file of the <emphasis>WebSocketController</emphasis> can be generated by the <emphasis>drogon_ctl</emphasis> tool. The command format is as follows:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -w &lt;[namespace::]class_name&gt;</literal_block>
            <paragraph>Suppose we want to implement a simple echo function through websocket, that is, the server simply sends back the message sent by the client. We can create the implementation class EchoWebsock of <emphasis>WebSocketController</emphasis> through <emphasis>drogon_ctl</emphasis>, as follows:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -w EchoWebsock</literal_block>
            <paragraph>The command will generate two files of EchoWebsock.h and EchoWebsock.cc,as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id1" literal_block="True">
                <caption><emphasis>EchoWebsock.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/WebSocketController.h&gt;
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController&lt;EchoWebsock&gt;
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&amp;,
                                std::string &amp;&amp;)override;
    virtual void handleNewConnection(const HttpRequestPtr &amp;,
                                    const WebSocketConnectionPtr&amp;)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&amp;)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_LIST_END
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id2" literal_block="True">
                <caption><emphasis>EchoWebsock.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &amp;wsConnPtr,std::string &amp;&amp;message)
{
    //write your application logic here
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}</literal_block>
            </container>
            <paragraph>After edited:</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption><emphasis>EchoWebsock.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/WebSocketController.h&gt;
using namespace drogon;
class EchoWebsock:public drogon::WebSocketController&lt;EchoWebsock&gt;
{
public:
    virtual void handleNewMessage(const WebSocketConnectionPtr&amp;,
                                std::string &amp;&amp;)override;
    virtual void handleNewConnection(const HttpRequestPtr &amp;,
                                    const WebSocketConnectionPtr&amp;)override;
    virtual void handleConnectionClosed(const WebSocketConnectionPtr&amp;)override;
    WS_PATH_LIST_BEGIN
    //list path definitions here;
    WS_PATH_ADD("/echo");
    WS_PATH_LIST_END
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption><emphasis>EchoWebsock.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "EchoWebsock.h"
void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &amp;wsConnPtr,std::string &amp;&amp;message)
{
    //write your application logic here
    wsConnPtr-&gt;send(message);
}
void EchoWebsock::handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}
void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConnPtr)
{
    //write your application logic here
}</literal_block>
            </container>
            <paragraph>First, in this example, the controller is registered to the <emphasis>/echo</emphasis> path via the <emphasis>WS_PATH_ADD</emphasis> macro. The usage of the <emphasis>WS_PATH_ADD</emphasis> macro is similar to the macros of other controllers introduced earlier. One can also register the path with several Filters. Since websocket is handled separately in the framework, it can be repeated with the paths of the first two controllers（<emphasis>HttpSimpleController</emphasis> and <emphasis>HttpApiController</emphasis>） without affecting each other.</paragraph>
            <paragraph>Secondly, in the implementation of the three virtual functions in this example, only the handleNewMessage has the substance, but simply sends the received message back to the client through the send interface.Compile this controller into the framework, you can see the effect, please test it yourself.</paragraph>
            <note>
                <paragraph>Note: Like the usual HTTP protocol, http websocket can be sniffed. If security is required, encryption should be provided by HTTPS. Of course, it is also possible for users to complete encryption and decryption on the server and client side, but HTTPS is more convenient. The underlying layer is handled by drogon, and users only need to care about business logic.</paragraph>
            </note>
            <paragraph>The user-defined websocket controller class inherits from the drogon::WebSocketController class template. The template parameter is a subclass type. The user needs to implement the following three virtual functions to process the establishment, shutdown, and messages of the websocket:</paragraph>
            <comment xml:space="preserve">cpp::function:: virtual void handleNewConnection(const HttpRequestPtr &amp;req,const WebSocketConnectionPtr &amp;wsConn)</comment>
            <comment xml:space="preserve">cpp::function:: virtual void handleNewMessage(const WebSocketConnectionPtr &amp;wsConn,std::string &amp;&amp;message);</comment>
            <comment xml:space="preserve">cpp::function:: virtual void handleConnectionClosed(const WebSocketConnectionPtr &amp;wsConn);</comment>
            <paragraph>Easy to know:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>handleNewConnection is called after the websocket is established. req is the setup request sent by the client. At this time, the framework has returned the response. What users can do is to get some additional information through req, such as token. wsConn is a smart pointer to this websocket object, and the commonly used interface will be discussed later.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>handleNewMessage is called after the websocket receives the new message. The message is stored in the message variable. Note that the message is the message payload. The framework has finished the decapsulation and decoding of the message. The user can directly process the message itself.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>handleConnectionClosed is called after the websocket connection is closed, and the user can do some finishing work.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="websocketconnection" names="websocketconnection">
            <title>WebSocketConnection</title>
            <paragraph>The common interfaces of the WebSocketConnection object are as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id5" literal_block="True">
                <caption><emphasis>WebSocketConnection.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">//Send a websocket message, the encoding and encapsulation
//of the message are the responsibility of the framework
void send(const char *msg,uint64_t len);
void send(const std::string &amp;msg);

//Local and remote addresses of the websocket
const trantor::InetAddress &amp;localAddr() const;
const trantor::InetAddress &amp;peerAddr() const;

//The connection state of the weosocket
bool connected() const;
bool disconnected() const;

//close websocket
void shutdown();//close write
void forceClose();//close

//set up and get the context of the websocket, and store some business data from users.
//the any type means that you can store any type of object.
void setContext(const any &amp;context);
const any &amp;getContext() const;
any *getMutableContext();</literal_block>
            </container>
        </section>
    </section>
</document>
