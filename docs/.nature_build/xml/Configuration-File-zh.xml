<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Configuration-File-zh.rstd">
    <section ids="id1" names="配置文件">
        <title>配置文件</title>
        <paragraph>你可以通过DrogonAppFramework实例的多个接口配置各种参数来控制Http服务端的某些行为。不过，使用配置文件是更好的方式，原因如下：</paragraph>
        <block_quote>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>使用配置文件而不是源码，可以在运行期而不是编译期决定应用的行为，这无疑是更方便和灵活的方式；</paragraph>
                </list_item>
                <list_item>
                    <paragraph>可以保持main文件的简洁；</paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <paragraph>所有的配置接口都有对应的配置文件选项支持，基于上面这些额外的好处，建议应用开发者使用配置文件配置应用的各种参数。</paragraph>
        <paragraph>配置文件的加载很简单，在DrogonAppFramework实例调用run接口之前，调用loadConfigFile接口即可，参数是配置文件的路径和文件名，比如：</paragraph>
        <container classes="literal-block-wrapper" ids="id12" literal_block="True">
            <caption><strong>main.cc</strong></caption>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">int main()
{
    drogon::app().loadConfigFile("config.json");
    drogon::app().run();
}</literal_block>
        </container>
        <paragraph>这段程序，加载配置文件*config.json*，然后运行。具体的监听端口、日志输出、数据库配置等等行为都可以由配置文件配置，事实上，这段程序基本就可以是整个webapp应用的主函数的全部代码了。</paragraph>
        <section ids="id2" names="文件说明">
            <title>文件说明</title>
            <paragraph>配置文件的例子在源码目录的顶层*config.example.json*，如果你使用drogon_ctl create project命令创建工程，那么，在工程目录里也可以找到内容一致的文件*config.json*。所以，你基本上不需要重写，而是对这个文件进行适当的修改，就可以完成对webapp的配置。</paragraph>
            <paragraph>文件是json格式，支持注释，你可以用c++的注释符号/**/和//把不需要的配置项注释掉。</paragraph>
            <paragraph>注释掉配置项后，框架会使用默认值初始化，对应项的默认值在配置文件中都有说明，下面分项详述。</paragraph>
        </section>
        <section ids="ssl" names="ssl">
            <title>SSL</title>
            <paragraph>ssl项是为了配置https服务的加密配置文件，如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"ssl": {
  "cert": "../../trantor/trantor/tests/server.pem",
  "key": "../../trantor/trantor/tests/server.pem"
}</literal_block>
            <paragraph>其中，cert是证书文件路径，key是私钥文件路径，如果一个文件既包含证书也包含私钥，则两个路径可以配制成相同的。</paragraph>
            <paragraph>文件的编码格式PEM。</paragraph>
        </section>
        <section ids="listeners" names="listeners监听器">
            <title>listeners监听器</title>
            <paragraph>顾名思义，listeners项是为了配置webapp的监听器，它是一个JSON数组类型，每一个JSON对象都表示一个监听，具体的配置如下：</paragraph>
            <paragraph>如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"listeners": [
    {
    "address": "0.0.0.0",
    "port": 80,
    "https": false
    },
    {
    "address": "0.0.0.0",
    "port": 443,
    "https": true,
    "cert": "",
    "key": ""
    }
]</literal_block>
            <paragraph>其中：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>address</emphasis>: 字符串类型，表示监听的IP地址，如果没有该项，则采用默认值”0.0.0.0”</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>port</emphasis>: 整数类型，表示监听的端口，必须是合法的端口号，没有默认值，必填项。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>https</emphasis>: 布尔类型，表示是否采用https，默认值是false，表示使用http。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>cert</emphasis> and <emphasis>key</emphasis>: 字符串类型，在https为true时有效，表示https的证书和私钥，默认值是空字符串，表示采用全局的ssl配置的证书和私钥文件；</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="db-clients" names="db_clients">
            <title>db_clients</title>
            <paragraph>用于配置数据库客户端，它是一个JSON数组类型，每一个JSON对象都表示一个单独的数据库客户端，具体的配置如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"db_clients":[
  {
    "name":"",
    "rdbms": "postgresql",
    "host": "127.0.0.1",
    "port": 5432,
    "dbname": "test",
    "user": "",
    "passwd": "",
    "is_fast": false,
    "connection_number": 1,
    "file_name": ""
  }
]</literal_block>
            <paragraph>其中:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>name</emphasis>: 字符串，客户端名字，默认是”default”，name是应用开发者从框架获取数据库客户端的标记，如果有多项客户端，name字段必须不同，否则，框架不会正常工作；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>rdbms</emphasis>：字符串，表示数据库服务端类型，目前支持”postgresql”和”mysql”，大小写不敏感。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>host</emphasis>：字符串，数据库服务端地址，localhost是默认值；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>port</emphasis>：整数，数据库服务端的端口号；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>dbname</emphasis>：字符串，数据库名字；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>user</emphasis>：字符串，用户名；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>passwd</emphasis>：字符串，密码；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>is_fast</emphasis>：bool，默认false，表明该客户端是否是FastDbClient；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>connection_number</emphasis>：到数据库服务端的连接数，至少是1，默认值也是1，影响数据读写的并发量；如果is_fast为真，该数值表示每个事件循环的连接数，否则表示总的连接数；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>filename</emphasis>: sqlite3数据库的文件名；</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="threads-num" names="threads\ num线程数">
            <title>threads num线程数</title>
            <paragraph>属于app选项的子项，整数，默认值是1，表示框架IO线程数，对网络并发有明确的影响，这个数字并不是越大越好，了解non-blocking I/O原理的应该知道，这个数值应该和你期望网络IO占用的CPU核心数一致。如果这个参数设为0，那么IO线程数将设置为全部CPU核心数。比如：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"threads_num": 16,</literal_block>
            <paragraph>表示，网络IO占用16个线程，在高负荷情况下，最多可以跑满16个CPU核心(线程核心)。</paragraph>
        </section>
        <section ids="session" names="session会话">
            <title>session会话</title>
            <paragraph>会话相关的选项也是app的子项，控制是否采用session和session的超时时间。如：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"enable_session": true,
"session_timeout": 1200,</literal_block>
            <paragraph>其中:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>enable_session</emphasis>：布尔值，表示是否采用会话，默认值是false，如果客户端不支持cookie，请设为false，因为框架会为每个不带会话cookie的请求创建新的会话，如果客户端不支持cookie而又有大量请求，则服务端会生成大量的无用session对象，这是完全没必要的资源和性能损失；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>session_timeout</emphasis>：整数值，表示会话的超时时间，单位是秒，默认值是0，只有enable_session为true时才发挥作用。0表示永久有效。</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="document-root" names="document_root\ 根目录">
            <title>document_root 根目录</title>
            <paragraph><problematic ids="id4" refid="id3">*</problematic>app*项的子项，字符串，表示Http根目录对应的文档路径，是静态文件下载的根路径，默认值是”./”，表示程序运行的当前路径。比如：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"document_root": "./",</literal_block>
        </section>
        <section ids="upload-path" names="upload_path上传文件路径">
            <title>upload_path上传文件路径</title>
            <paragraph>app项的子项，字符串，表示上传文件的默认路径，默认值是”uploads”，如果这个值不是*/,./<emphasis>或</emphasis>../<emphasis>开始的，并且这个值也不是</emphasis>.*或*..*，则这个路径是前面document_root项的相对路径，否则就是一个绝对路径或者当前目录的相对路径。如：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"upload_path":"uploads",</literal_block>
        </section>
        <section ids="file-types" names="file_types文件类型">
            <title>file_types文件类型</title>
            <paragraph>app项的子项，字符串数组，默认值如下，表示框架支持的静态文件下载类型，如果请求的静态文件扩展名在这些类型之外的，框架将返回404错误。</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"file_types": [
    "gif",
    "png",
    "jpg",
    "js",
    "css",
    "html",
    "ico",
    "swf",
    "xap",
    "apk",
    "cur",
    "xml"
    ],</literal_block>
        </section>
        <section ids="connections" names="connections连接数控制">
            <title>connections连接数控制</title>
            <paragraph>app项的子项，有两个选项，如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"max_connections": 100000,
"max_connections_per_ip": 0,</literal_block>
            <paragraph>其中:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>max_connections</emphasis>：整数，默认值是100000，表示同时并发的最大连接数；当服务端维持的连接达到这个数量时，新的TCP连接请求将被直接拒绝。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>max_connections_per_ip</emphasis>：整数，默认值是0，表示单个IP的最大连接数，0表示没有限制。</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="log" names="log日志选项">
            <title>log日志选项</title>
            <paragraph>app项的子项，同时也是个JSON对象，控制日志输出的行为，如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"log": {
    "log_path": "./",
    "logfile_base_name": "",
    "log_size_limit": 100000000,
    "log_level": "TRACE"
    },</literal_block>
            <paragraph>其中：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>log_path</emphasis>：字符串，默认值是空串，表示文件存放的路径，如果是空串，则所有日志输出到标准输出；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>logfile_base_name</emphasis>：字符串，表示日志文件的*basename*，默认值是空串，这时basename将为drogon；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>log_size_limit</emphasis>：整数，单位是字节，默认值是100000000(100M)，当日志文件的大小达到这个数值时，日志文件会切换。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>log_level</emphasis>：字符串，默认值是”DEBUG”，表示日志输出的最低级别，可选值从低到高为：”TRACE”,”DEBUG”,”INFO”,”WARN”，其中的TRACE级别只有在DEBUG编译的情况下才有效。</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <note>
                <paragraph>注意： Drogon的文件日志采用了非阻塞输出结构，大概可以达到每秒百万行的日志输出能力，可以放心使用。</paragraph>
            </note>
        </section>
        <section ids="id5" names="应用控制">
            <title>应用控制</title>
            <paragraph>也是app子项，有两个控制项，如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"run_as_daemon": false,
"relaunch_on_error": false,</literal_block>
            <paragraph>其中：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>run_as_daemon：布尔值，默认值是false，当为true时，应用程序将以daemon的形式变成1号进程的子进程运行于系统后台。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>relaunch_on_error：布尔值，默认值时false，当为true时，应用程序将fork一次，子进程执行真正的工作，父进程什么都不干，只负责在子进程崩溃或因其它原因退出时重启子进程，这是一种简单的服务保护机制。</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="use-sendfile" names="use_sendfile发送文件">
            <title>use_sendfile发送文件</title>
            <paragraph>app子选项，布尔值，表示在发送文件时是否采用linux系统调用sendfile，默认值时true，使用sendfile可以提高发送效率，减少大文件的内存占用。如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"use_sendfile": true,</literal_block>
            <note>
                <paragraph>注意：即使该项为true，sendfile系统调用也不一定会采用，因为小文件使用sendfile并不一定划算，框架会根据自己的优化策略决定是否采用。</paragraph>
            </note>
        </section>
        <section ids="use-gzip" names="use_gzip压缩传输">
            <title>use_gzip压缩传输</title>
            <paragraph><problematic ids="id7" refid="id6">*</problematic>app*子选项，布尔值，默认值是true，表示Http响应的Body是否采用压缩传输。当该项为true时，下面的情况采用压缩传输：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>客户端支持gzip压缩；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>body是文本类型；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>body的长度大于一定值；</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>配置例子如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"use_gzip": true,</literal_block>
        </section>
        <section ids="files-cache-time" names="files_cache_time文件缓存时间">
            <title>files_cache_time文件缓存时间</title>
            <paragraph><problematic ids="id9" refid="id8">*</problematic>app*子选项，JSON对象数组，每一项表示一个从Http路径到HttpSimpleController的映射，这种配置只是一个可选途径，并不是必须配置在这里，请参阅HttpSimpleController。 具体的配置如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"static_files_cache_time": 5,</literal_block>
        </section>
        <section ids="simple-controllers-map" names="simple_controllers_map">
            <title>simple_controllers_map</title>
            <paragraph><problematic ids="id11" refid="id10">*</problematic>app*子选项，JSON对象数组，每一项表示一个从Http路径到HttpSimpleController的映射，这种配置只是一个可选途径，并不是必须配置在这里，请参阅HttpSimpleController。 具体的配置如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"simple_controllers_map": [
    {
        "path": "/path/name",
        "controller": "controllerClassName",
        "http_methods": ["get","post"],
        "filters": ["FilterClassName"]
    }
    ],</literal_block>
            <paragraph>其中：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>path</emphasis>：字符串，Http路径；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>controller</emphasis>：字符串，HttpSimpleController的名字；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>http_methods</emphasis>：字符串数组，支持的Http方法，这个列表之外的会被过滤掉，返回405错误；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>filters</emphasis>：字符串数组，路径上的filter列表，参见过滤器；</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="idle-connection-timeout" names="idle_connection_timeout空闲连接超时控制">
            <title>idle_connection_timeout空闲连接超时控制</title>
            <paragraph>app子选项，整数值，单位秒，默认值是60，当一个连接超过这个数值的时间没有任何读写的时候，该连接将会被强制断开。</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"idle_connection_timeout":60</literal_block>
        </section>
        <section ids="dynamic-views" names="dynamic_views动态视图加载">
            <title>dynamic_views动态视图加载</title>
            <paragraph>app的子选项，控制动态视图的使能和路径，有两个选项，如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"load_dynamic_views":true,
"dynamic_views_path":["./views"],</literal_block>
            <paragraph>其中：</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><emphasis>dynamic_views_path</emphasis>：布尔值，默认值是false，当为true时，框架会在视图路径中搜索视图文件，并动态编译成so文件，然后加载进应用，当任何视图文件发生变化时，也会引起自动编译和重新加载；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>dynamic_views_path</emphasis>：字符串数组，每一项表示动态视图的搜索路径，如果路径值不是*/,./<emphasis>或</emphasis>../<emphasis>开始的，并且这个值也不是</emphasis>.*或*..*，则这个路径是前面document_root项的相对路径，否则就是一个绝对路径或者当前目录的相对路径。</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>参见视图。</paragraph>
        </section>
        <section ids="server-header-field" names="server_header_field头字段">
            <title>server_header_field头字段</title>
            <paragraph>app的子选项，配置由框架发送的所有response的Server头字段，默认值是空串，当该选项为空时，框架会自动生成形如*Server: drogon/version string*的头字段。如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"server_header_field": ""</literal_block>
        </section>
        <section ids="keepalive-requests" names="keepalive_requests长连接请求数">
            <title>keepalive_requests长连接请求数</title>
            <paragraph><emphasis>keepalive_requests</emphasis> 选项设置客户端在一个keepalive长连接上可以发送的最大请求数。当达到这个请求数时，长连接将被关闭。默认值0代表没有限制。如下：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"keepalive_requests": 0</literal_block>
        </section>
        <section ids="pipelining" names="pipelining请求数">
            <title>Pipelining请求数</title>
            <paragraph><emphasis>pipelining_requests*选项用于设置长连接上已接收但未必处理的最大的请求数。当这个数字达到时，长连接将被关闭。默认值0代表没有限制。关于pipelining的详细描述，请参阅标准文档*rfc2616-8.1.1.2</emphasis>。配置如下所示：</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">"pipelining_requests": 0</literal_block>
        </section>
    </section>
</document>
