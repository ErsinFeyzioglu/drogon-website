<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Controller-HttpController-en.rstd">
    <section ids="controller-httpcontroller" names="controller\ httpcontroller">
        <title>Controller HttpController</title>
        <section ids="generation" names="generation">
            <title>Generation</title>
            <paragraph>You can use the <emphasis>drogon_ctl</emphasis> command line tool to quickly generate custum controller class source files based on <emphasis>HttpController</emphasis>, the command format is as bellow:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -h &lt;[namespace::]class_name&gt;</literal_block>
            <paragraph>We create one controller class named <emphasis>User</emphasis>, under namespace <emphasis>demo v1</emphasis>:</paragraph>
            <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">drogon_ctl create controller -h demo::v1::User</literal_block>
            <paragraph>As you can see, two files have been added to the current directory, demo_v1_User.h and demo_v1_User.cc.</paragraph>
            <paragraph>demo_v1_User.h is as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id1" literal_block="True">
                <caption><emphasis>demo_v1_User.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/HttpController.h&gt;
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController&lt;User&gt;
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
        };
    }
}</literal_block>
            </container>
            <paragraph>demo_v1_User.cc is as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id2" literal_block="True">
                <caption><emphasis>demo_v1_User.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here</literal_block>
            </container>
        </section>
        <section ids="usage" names="usage">
            <title>Usage</title>
            <paragraph>Let’s edit the two files:</paragraph>
            <paragraph>demo_v1_User.h is as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption><emphasis>demo_v1_User.h</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once
#include &lt;drogon/HttpController.h&gt;
using namespace drogon;
namespace demo
{
    namespace v1
    {
        class User:public drogon::HttpController&lt;User&gt;
        {
        public:
            METHOD_LIST_BEGIN
                //use METHOD_ADD to add your custom processing function here;
                METHOD_ADD(User::login,"/token?userId={1}&amp;passwd={2}",Post);
                METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get);
            METHOD_LIST_END
            //your declaration of processing function maybe like this:
            void login(const HttpRequestPtr &amp;req,
                    std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,
                    std::string &amp;&amp;userId,
                    const std::string &amp;password);
            void getInfo(const HttpRequestPtr &amp;req,
                        std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,
                        std::string userId,
                        const std::string &amp;token) const;
        };
    }
}</literal_block>
            </container>
            <paragraph>demo_v1_User.cc is as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption><emphasis>demo_v1_User.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "demo_v1_User.h"
using namespace demo::v1;
//add definition of your processing function here

void User::login(const HttpRequestPtr &amp;req,
        std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,
        std::string &amp;&amp;userId,
        const std::string &amp;password)
{
    LOG_DEBUG&lt;&lt;"User "&lt;&lt;userId&lt;&lt;" login";
    //Authentication algorithm, read database, verify identity, etc...
    //...
    Json::Value ret;
    ret["result"]="ok";
    ret["token"]=drogon::utils::getUuid();
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}
void User::getInfo(const HttpRequestPtr &amp;req,
            std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,
            std::string userId,
            const std::string &amp;token) const
{
    LOG_DEBUG&lt;&lt;"User "&lt;&lt;userId&lt;&lt;" get his information";

    //Verify the validity of the token, etc.
    //Read the database or cache to get user information
    Json::Value ret;
    ret["result"]="ok";
    ret["user_name"]="Jack";
    ret["user_id"]=userId;
    ret["gender"]=1;
    auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
}</literal_block>
            </container>
            <paragraph>Each <emphasis>HttpController</emphasis> class can define many Http request handlers. Since the number of functions can be arbitrarily large, it is unrealistic to overload them with virtual functions. We need to register the handler itself (not the class) in the framework.</paragraph>
            <paragraph>The mapping from the URL path to the handler is done by macros. You can add a multipath map with the <emphasis>METHOD_ADD</emphasis> macro or the <emphasis>ADD_METHOD_TO</emphasis> macro. All <emphasis>METHOD_ADD</emphasis> and <emphasis>ADD_METHOD_TO</emphasis> statements should be sandwiched between the <emphasis>METHOD_LIST_BEGIN</emphasis> and <emphasis>METHOD_LIST_END</emphasis> macro statements.</paragraph>
            <paragraph>The <emphasis>METHOD_ADD</emphasis> macro automatically prefixes the namespace and class name in the path map. Therefore, in this example, the login function is registered to the <emphasis>/demo/v1/user/token</emphasis> path, and the getInfo function is registered to the <emphasis>/demo/v1/user/xxx/info</emphasis> path. Constraints are similar to the <emphasis>PATH_ADD</emphasis> macro of HttpSimpleController and not be described here.</paragraph>
            <paragraph>The <emphasis>ADD_METHOD_TO</emphasis> macro acts almost as much as the former, except that it does not automatically add any prefixes, i.e. the path registered by the macro is an absolute path.</paragraph>
            <paragraph>We see that <emphasis>HttpController</emphasis> provides a more flexible path mapping mechanism, we can put a class of functions in a class.</paragraph>
            <paragraph>In addition, you can see that the macros provide a method for parameters mapping. We can map the parameters on the path to the parameter list of the function. The number of URL path parameter corresponds to the function parameter’s position, this is very convenient. The common types which can be converted by string type all can be used as function parameters (such as std::string, int, float, double, etc.), the drogon framework will automatically help you convert the type, this is very convenient for developing. Note that lvalue references must be of type const.</paragraph>
            <paragraph>The same path can be mapped multiple times, distinguished from each other by Http Method, which is legal and is a common practice of the Restful API, such as:</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">METHOD_LIST_BEGIN
    METHOD_ADD(Book::getInfo,"/{1}?detail={2}",Get);
    METHOD_ADD(Book::newBook,"/{1}",Post);
    METHOD_ADD(Book::deleteOne,"/{1}",Delete);
METHOD_LIST_END</literal_block>
            <paragraph>When you use the <emphasis>ADD_METHOD</emphasis> macro and the class belongs to some namespace, you should add namespace to the access url, in this example, use <emphasis>http://localhost/demo/v1/user/token?userid=xxx&amp;passwd=xxx</emphasis> or <emphasis>http://localhost/demo/v1/user/xxxxx/info?token=xxxx</emphasis> to access.</paragraph>
            <paragraph>The placeholders of path parameters can be written in several ways:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>{}: The position on the path is the position of the function parameter, which indicates that the path parameter maps to the corresponding position of the handler parameters.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>{1},{2}: The path parameters with a number in are mapped to the handler parameters specified by the number.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>{anystring}: Strings here have no practical effect, but can improve the readability of the program, equivalent to {}.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>{1:anystring},{2:xxx}: The number before the colon represents the position, and the string behind it does not actually work, but can improve the readability of the program, which is equivalent to the {1} and {2}.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>The latter two writes are recommended, and if the path parameters and function parameters are in the same order, the third is enough. It is easy to know that the following writes are equivalent:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>“/users/{}/books/{}”</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>“/users/{}/books/{2}”</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>“/users/{user_id}/books/{book_id}”</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>“/users/{1:user_id}/books/{2}”</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <note>
                <paragraph>Note: Path matching is not case sensitive, parameter names are case sensitive, (Parameter values ​​can be mixed in uppercase and lowercase and passed unchanged to the controller)</paragraph>
            </note>
        </section>
        <section ids="parameters-mapping" names="parameters\ mapping">
            <title>Parameters mapping</title>
            <paragraph>Through the previous description, we know that the parameters on the path and the query parameters after the question mark can be mapped to the parameter list of the handler function. The type of the target parameter needs to meet the following conditions:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Must be one of a value type, a constant left value reference, or a non-const right value reference. It cannot be a non-const lvalue reference. It is recommended to use an rvalue reference so that the user can dispose of it at will;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Basic types such as int, long, long long, unsigned long, unsigned long long, float, double, long double, etc can be used as parameter types;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>std::string；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Any type that can be assigned using the <emphasis>stringstream &gt;&gt;</emphasis> operator;</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph><emphasis>In addition, the drogon framework also provides a mapping mechanism from the HttpRequestPtr object to any type of parameter</emphasis>. When the number of mapping parameters in your handler parameter list is more than the parameters on the path, the extra parameters will be converted by the HttpRequestPtr object. The user can define any type of conversion, the way to define this conversion is to specialize the <emphasis>fromRequest</emphasis> template (which is defined in the HttpRequest.h header file) in the drogon namespace, for example, say we need to make a RESTful interface to create a new user, we define the user’s structure as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id5" literal_block="True">
                <caption><emphasis>myapp_User_drogon.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">namespace myapp{
struct User{
    std::string userName;
    std::string email;
    std::string address;
};
}
namespace drogon
{
template &lt;&gt;
inline myapp::User fromRequest(const HttpRequest &amp;req)
{
    auto json = req.getJsonObject();
    myapp::User user;
    if(json)
    {
        user.userName = (*json)["name"].asString();
        user.email = (*json)["email"].asString();
        user.address = (*json)["address"].asString();
    }
    return user;
}

}</literal_block>
            </container>
            <paragraph>With the above definition and template specialization, we can define the path map and handler as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id6" literal_block="True">
                <caption><emphasis>UserController.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class UserController:public drogon::HttpController&lt;UserController&gt;
{
public:
    METHOD_LIST_BEGIN
        //use METHOD_ADD to add your custom processing function here;
        ADD_METHOD_TO(UserController::newUser,"/users",Post);
    METHOD_LIST_END
    //your declaration of processing function maybe like this:
    void newUser(const HttpRequestPtr &amp;req,
                std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback,
                myapp::User &amp;&amp;pNewUser) const;
};</literal_block>
            </container>
            <paragraph>It can be seen that the third parameter of <emphasis>myapp::User</emphasis> type has no corresponding placeholder on the mapping path, and the framework regards it as a parameter converted from the <emphasis>req</emphasis> object, and obtains this parameter through the user-specialized function template. This is very convenient for users.</paragraph>
            <paragraph>Further, some users do not need to access the HttpRequestPtr object except for their custom type data, so he can put the custom object in the position of the first parameter, and the framework can also correctly complete the mapping, such as the above example. It can also be written as follows:</paragraph>
            <container classes="literal-block-wrapper" ids="id7" literal_block="True">
                <caption><emphasis>UserController.cc</emphasis></caption>
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class UserController:public drogon::HttpController&lt;UserController&gt;
{
public:
    METHOD_LIST_BEGIN
        //use METHOD_ADD to add your custom processing function here;
        ADD_METHOD_TO(UserController::newUser,"/users",Post);
    METHOD_LIST_END
    //your declaration of processing function maybe like this:
    void newUser(myapp::User &amp;&amp;pNewUser,
                std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback) const;
};</literal_block>
            </container>
        </section>
        <section ids="multiple-path-mapping" names="multiple\ path\ mapping">
            <title>multiple path mapping</title>
            <paragraph>Drogon supports the use of regular expressions in path mapping, which can be used outside the ‘{}’ curly brackets, for example:</paragraph>
            <paragraph>ADD_METHOD_TO(UserController::handler1,”/users/.*”,Post); /// Match any path prefixed with <title_reference>/users/</title_reference>
                ADD_METHOD_TO(UserController::handler2,”/{name}/[0-9]+”,Post); ///Match any path composed with a name string and a number.</paragraph>
        </section>
        <section ids="regular-expression" names="regular\ expression">
            <title>Regular expression</title>
            <paragraph>The above method has limited support for regular expressions. If users want to use regular expressions freely, drogon provides the <emphasis>ADD_METHOD_VIA_REGEX</emphasis> macro to achieve this, such as:</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ADD_METHOD_VIA_REGEX(UserController::handler1,"/users/(.*)",Post); /// Match any path prefixed with `/users/` and map the rest of the path to a parameter of the handler1.
ADD_METHOD_VIA_REGEX(UserController::handler2,"/.*([0-9]*)",Post); /// Matche any path that ends in a number and map that number to a parameter of the handler2.
ADD_METHOD_VIA_REGEX(UserController::handler3,"/(?!data).*",Post); /// Matches any path that does not start with '/data'</literal_block>
            <paragraph>As can be seen, parameter mapping can also be done using regular expressions, and all strings matched by subexpressions will be mapped to the parameters of the handler in order.</paragraph>
            <note>
                <paragraph>It should be noted that when using regular expressions, you should pay attention to matching conflicts (multiple different handlers are matched). When conflicts happen in the same controller, drogon will only execute the first handler (the one registered in the framework first). When conflicts happen between different controllers, which handler to be executed is uncertain. Therefore, users need to avoid this kind of conflicts.</paragraph>
            </note>
        </section>
    </section>
</document>
