<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.15.2 -->
<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Benchmarks-zh.rstd">
    <section ids="id1" names="性能测试">
        <title>性能测试</title>
        <paragraph>作为C++的Http应用框架，性能应该是关注的重点之一，本节介绍Drogon的简单测试和成绩；</paragraph>
        <section ids="id2" names="测试环境">
            <title>测试环境</title>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>系统是Linux CentOS 7.4；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>设备是Dell服务器，CPU是两颗Intel(R) Xeon(R) CPU E5-2670 @ 2.60GHz，16核32线程；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>内存64GB；</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>gcc版本7.3.0；</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="id3" names="测试方案和结果">
            <title>测试方案和结果</title>
            <paragraph>我们只是为了测试drogon框架的性能，因而要尽量简化controller的处理，我们只做了一个HttpSimpleController，注册到*/benchmark*路径上。controller对任何请求都返回*&lt;p&gt;Hello, world!&lt;/p&gt;*。设置drogon线程数为16。handler函数的代码如下, 你可以在*drogon/examples/benchmark*目录找到这些源码：</paragraph>
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void BenchmarkCtrl::asyncHandleHttpRequest(const HttpRequestPtr &amp;req, std::function&lt;void (const HttpResponsePtr &amp;)&gt; &amp;&amp;callback)
{
    //write your application logic here
    auto resp = HttpResponse::newHttpResponse();
    resp-&gt;setBody("&lt;p&gt;Hello, world!&lt;/p&gt;");
    resp-&gt;setExpiredTime(0);
    callback(resp);
}</literal_block>
            <paragraph>作为对比，我选取了nginx来做对比测试，使用nginx+module源码编译的方式，写了一个hello_world_module，测试时nginx的worker_processes参数设为16。</paragraph>
            <paragraph>测试工具是一个性能不错的HTTP压力测试工具*httpress*。</paragraph>
            <paragraph>我们调整httpress的参数，每组参数测试五次，记录每秒处理请求数的最大值和最小值。测试结果如下表：</paragraph>
            <table>
                <tgroup cols="4">
                    <colspec colwidth="45"></colspec>
                    <colspec colwidth="70"></colspec>
                    <colspec colwidth="16"></colspec>
                    <colspec colwidth="17"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>命令行</paragraph>
                            </entry>
                            <entry>
                                <paragraph>说明</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Drogon(千QPS)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>nginx(千QPS)</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>httpress -c 100 -n 1000000 -t 16 -k -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>100连接，100万请求，16线程，Keep-Alive</paragraph>
                            </entry>
                            <entry>
                                <paragraph>561/552</paragraph>
                            </entry>
                            <entry>
                                <paragraph>330/329</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>httpress -c 100 -n 1000000 -t 12 -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>100连接，100万请求，12线程，一次请求一次连接</paragraph>
                            </entry>
                            <entry>
                                <paragraph>140/135</paragraph>
                            </entry>
                            <entry>
                                <paragraph>31/49</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>httpress -c 1000 -n 1000000 -t 16 -k -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>1000连接，100万请求，16线程，Keep-Alive</paragraph>
                            </entry>
                            <entry>
                                <paragraph>573/565</paragraph>
                            </entry>
                            <entry>
                                <paragraph>333/327</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>httpress -c 1000 -n 1000000 -t 16 -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>1000连接，100万请求，16线程，一次请求一次连接</paragraph>
                            </entry>
                            <entry>
                                <paragraph>155/143</paragraph>
                            </entry>
                            <entry>
                                <paragraph>52/50</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>httpress -c 10000 -n 4000000 -t 16 -k -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>10000连接，400万请求，16线程，Keep-Alive</paragraph>
                            </entry>
                            <entry>
                                <paragraph>512/508</paragraph>
                            </entry>
                            <entry>
                                <paragraph>316/314</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>httpress -c 10000 -n 1000000 -t 16 -q URL</paragraph>
                            </entry>
                            <entry>
                                <paragraph>10000连接，100万请求，16线程，一次请求一次连接</paragraph>
                            </entry>
                            <entry>
                                <paragraph>143/141</paragraph>
                            </entry>
                            <entry>
                                <paragraph>43/40</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>可以看到，在客户端使用Keep-Alive选项，在一个连接可以发送多个请求的情况下，drogon每秒可以处理50多万次请求，这个成绩是相当不错的。每次请求都发起一次连接的情况下，CPU会消耗在TCP建立和断开等环节，吞吐量会下降至每秒14万次请求，这也是正常的。drogon对比nginx的成绩处于明显优势，也许是由于nginx配置不当未能发挥它的最大吞吐量，如果哪位高手做了更好的测试，欢迎指正。</paragraph>
            <paragraph>下图是某一次测试的截图：</paragraph>
            <paragraph>测试截图</paragraph>
        </section>
    </section>
</document>
