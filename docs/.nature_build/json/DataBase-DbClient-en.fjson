{"parents": [{"link": "../index-en/", "title": "English documentation"}], "prev": {"link": "../Database-General-en/", "title": "Database General"}, "next": {"link": "../DataBase-Transaction-en/", "title": "DataBase Transaction"}, "title": "DataBase DbClient", "meta": {}, "body": "<div class=\"section\" id=\"database-dbclient\">\n<h1>DataBase DbClient<a class=\"headerlink\" href=\"#database-dbclient\" title=\"Permalink to this headline\">\u00b6</a></h1>\n<div class=\"section\" id=\"dbclient-object-construction\">\n<h2>DbClient Object Construction<a class=\"headerlink\" href=\"#dbclient-object-construction\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>There are two ways to construct a DbClient object. One is through the static method of the DbClient class. You can see the definition in the DbClient.h header file, as follows:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"cp\">#if USE_POSTGRESQL</span>\n    <span class=\"k\">static</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">DbClient</span><span class=\"o\">&gt;</span> <span class=\"n\">newPgClient</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">connInfo</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">connNum</span><span class=\"p\">);</span>\n<span class=\"cp\">#endif</span>\n<span class=\"cp\">#if USE_MYSQL</span>\n    <span class=\"k\">static</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">shared_ptr</span><span class=\"o\">&lt;</span><span class=\"n\">DbClient</span><span class=\"o\">&gt;</span> <span class=\"n\">newMysqlClient</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">connInfo</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">connNum</span><span class=\"p\">);</span>\n<span class=\"cp\">#endif</span>\n</pre></div>\n</div>\n<p>Use the above interface to get the smart pointer of the DbClient implementation object. The parameter connInfo is a connection string. Set a series of connection parameters in the form of key=value. For details, please refer to the comments in the header file. The parameter connNum is the number of database connections of DbClient, which has a key impact on concurrency. Please set it according to the actual situation.</p>\n<p>The object obtained by the above method, the user has to find a way to <strong>persist</strong> it, such as putting it in some global container. <strong>Creating a temporary object and then releasing it after use is a very unrecommended solution</strong> for the following reasons:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>This will waste time creating connections and disconnections, increasing system latency;</li>\n<li>The interface is also a non-blocking interface. That is to say, when the user gets the DbClient object, the connection managed by the it has not been established yet. The framework does not (intentionally) provide a callback interface for successful connection establishment. Do you still have to sleep before starting the query?? This is contrary to the original intention of the asynchronous framework.</li>\n</ul>\n</div></blockquote>\n<p>Therefore, DbClient objects should be built at the beginning of the program and held and used throughout the life time. Obviously, this work can be done entirely by the framework. So the drogon framework provides the second build method, which is built by configuration file or the createDbClient() method. For the configuration method of the configuration file, see db_clients.</p>\n<p>When needed, the DbClient smart pointer is obtained through the interface of the framework. The interface is as follows:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">orm</span><span class=\"o\">::</span><span class=\"n\">DbClientPtr</span> <span class=\"n\">getDbClient</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">&quot;default&quot;</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>The parameter name is the value of the name configuration option in the configuration file to distinguish multiple different DbClient objects of the same application. The connections managed by DbClient are always reconnected, so users don\u2019t need to care about the connection status. They are almost always connected.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Note: This method cannot be called before running app.run(), otherwise the user will get an empty shared_ptr.</p>\n</div>\n</div>\n<div class=\"section\" id=\"execution-interface\">\n<h2>Execution Interface<a class=\"headerlink\" href=\"#execution-interface\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>DbClient provides several different interfaces to users, as listed below:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"c1\">/// Asynchronous mothod</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span>\n        <span class=\"k\">typename</span> <span class=\"nc\">FUNCTION1</span><span class=\"p\">,</span>\n        <span class=\"k\">typename</span> <span class=\"nc\">FUNCTION2</span><span class=\"p\">,</span>\n        <span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">execSqlAsync</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                <span class=\"n\">FUNCTION1</span> <span class=\"o\">&amp;&amp;</span><span class=\"n\">rCallback</span><span class=\"p\">,</span>\n                <span class=\"n\">FUNCTION2</span> <span class=\"o\">&amp;&amp;</span><span class=\"n\">exceptCallback</span><span class=\"p\">,</span>\n                <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">;</span>\n\n<span class=\"c1\">/// Asynchronous mothod by &#39;future&#39;</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"k\">const</span> <span class=\"n\">Result</span><span class=\"o\">&gt;</span> <span class=\"n\">execSqlAsyncFuture</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                                            <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">;</span>\n\n<span class=\"c1\">/// Synchronous method</span>\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"k\">const</span> <span class=\"n\">Result</span> <span class=\"n\">execSqlSync</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                        <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">);</span>\n\n<span class=\"c1\">/// Streaming-type method</span>\n<span class=\"n\">internal</span><span class=\"o\">::</span><span class=\"n\">SqlBinder</span> <span class=\"k\">operator</span><span class=\"o\">&lt;&lt;</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>Since the number and type of binding parameters cannot be predetermined, these methods are function templates.</p>\n<p>The properties of these methods are shown in the following table:</p>\n<table border=\"1\" class=\"docutils\">\n<colgroup>\n<col width=\"18%\" />\n<col width=\"15%\" />\n<col width=\"28%\" />\n<col width=\"39%\" />\n</colgroup>\n<thead valign=\"bottom\">\n<tr class=\"row-odd\"><th class=\"head\">Methods</th>\n<th class=\"head\">Synchronous/Asynchronous</th>\n<th class=\"head\">Blocking/Non-blocking</th>\n<th class=\"head\">Exception</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr class=\"row-even\"><td>void execSqlAsync</td>\n<td>Asynchronous</td>\n<td>Non-blocking</td>\n<td>Will not throw an exception</td>\n</tr>\n<tr class=\"row-odd\"><td>std::future execSqlAsyncFuture</td>\n<td>Asynchronous</td>\n<td>Block when calling the get method of the future</td>\n<td>May throw an exception when calling the get method of the future</td>\n</tr>\n<tr class=\"row-even\"><td>const Result execSqlSync</td>\n<td>Synchronous</td>\n<td>Blocking</td>\n<td>May throw an exception</td>\n</tr>\n<tr class=\"row-odd\"><td>internal::SqlBinder operator&lt;&lt;</td>\n<td>Asynchronous</td>\n<td>Default non-blocking</td>\n<td>Will not throw an exception</td>\n</tr>\n</tbody>\n</table>\n<p>You may be confused about the combination of asynchronous and blocking. In general, the synchronization method involving network IO is blocking, and the asynchronous method is non-blocking. However, the asynchronous method can also work in blocking mode, meaning that this method will Block until the callback function has finished executing. When the asynchronous method of DbClient works in blocking mode, the callback function will be executed in the thread of the caller, and then the method will return.</p>\n<p>If your application involves high-concurrency scenarios, please use asynchronous non-blocking methods. If it is in a low concurrent scene (such as a network device management page), you can choose synchronization methods for convenience and intuitiveness.</p>\n<div class=\"section\" id=\"execsqlasync\">\n<h3>execSqlAsync<a class=\"headerlink\" href=\"#execsqlasync\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"nc\">FUNCTION1</span><span class=\"p\">,</span>\n        <span class=\"k\">typename</span> <span class=\"nc\">FUNCTION2</span><span class=\"p\">,</span>\n        <span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">execSqlAsync</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                <span class=\"n\">FUNCTION1</span> <span class=\"o\">&amp;&amp;</span><span class=\"n\">rCallback</span><span class=\"p\">,</span>\n                <span class=\"n\">FUNCTION2</span> <span class=\"o\">&amp;&amp;</span><span class=\"n\">exceptCallback</span><span class=\"p\">,</span>\n                <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">;</span>\n</pre></div>\n</div>\n<p>This is the most commonly used asynchronous interface, working in non-blocking mode;</p>\n<p>The parameter <em>sql</em> is a string of sql statements. If there are placeholders for binding parameters, use the placeholder rules of the corresponding database. For example, PostgreSQL placeholders are $1, $2 \u2026, while MySQL placeholders are <em>?</em>.</p>\n<p>The indefinite parameter <em>args</em> represents the bound parameter, which can be zero or more. The number of parameters is the same as the number of placeholders in the sql statement. The types can be the following:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>Integer type: can be an integer of various word lengths, and should match the database field type;</li>\n<li>Floating point type: can be float or double, should match the database field type;</li>\n<li>String type: can be std::string or const char[], corresponding to the string type of the database or other types that can be represented by strings;</li>\n<li>Date type: trantor::Date type, corresponding to the database date, datetime, timestamp types.</li>\n<li>Binary type: std::vector&lt;char&gt; type, corresponding to PostgreSQL\u2019s bytea type or Mysql\u2019s blob type;</li>\n</ul>\n</div></blockquote>\n<p>These parameters can be left or right, can be variables or literal constants, and users are free to use them.</p>\n<p>The parameters rCallback and exceptCallback represent the result callback function and the exception callback function, respectively, which have a fixed definition, as follows:</p>\n<blockquote>\n<div><ul class=\"simple\">\n<li>The result callback function: the call type is void (const Result &amp;), various callable objects conforming to this call type, std::function, lambda, etc. can be passed as parameters;</li>\n<li>Exception callback function: the call type is void (const DrogonDbException &amp;), which can pass various callable objects that are consistent with this call type;</li>\n</ul>\n</div></blockquote>\n<p>After the execution of sql is successful, the execution result is wrapped by the Result class and passed to the user through the result callback function; if there is any exception in the sql execution, the exception callback function is executed, and the user can obtain the exception information from the DrogonDbException object.</p>\n<p>Let us give an example:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">clientPtr</span> <span class=\"o\">=</span> <span class=\"n\">drogon</span><span class=\"o\">::</span><span class=\"n\">app</span><span class=\"p\">().</span><span class=\"n\">getDbClient</span><span class=\"p\">();</span>\n<span class=\"n\">clientPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">execSqlAsync</span><span class=\"p\">(</span><span class=\"s\">&quot;select * from users where org_name=$1&quot;</span><span class=\"p\">,</span>\n                            <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">Result</span> <span class=\"o\">&amp;</span><span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                                <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot; rows selected!&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                                <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n                                <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"nl\">row</span> <span class=\"p\">:</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n                                <span class=\"p\">{</span>\n                                    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;: user name is &quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">row</span><span class=\"p\">[</span><span class=\"s\">&quot;user_name&quot;</span><span class=\"p\">].</span><span class=\"n\">as</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                                <span class=\"p\">}</span>\n                            <span class=\"p\">},</span>\n                            <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">DrogonDbException</span> <span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                                <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;error:&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">base</span><span class=\"p\">().</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                            <span class=\"p\">},</span>\n                            <span class=\"s\">&quot;default&quot;</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>From the example we can see that the Result object is a std standard compatible container, support iterators, you can get the object of each row through the range loop. the various interfaces of Result, Row and Field objects, please refer to the source code.</p>\n<p>The DrogonDbException class is the base class for all database exceptions. Please refer to the comments in the source code.</p>\n</div>\n<div class=\"section\" id=\"execsqlasyncfuture\">\n<h3>execSqlAsyncFuture<a class=\"headerlink\" href=\"#execsqlasyncfuture\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"k\">const</span> <span class=\"n\">Result</span><span class=\"o\">&gt;</span> <span class=\"n\">execSqlAsyncFuture</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                                            <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">;</span>\n</pre></div>\n</div>\n<p>The asynchronous future interface omits the two callback parameters of the previous interface. Calling this interface will immediately return a future object. The user must call the get() method of the future object to get the returned result. The exception is obtained through the try/catch mechanism. if the get() method isn\u2019t in the <em>try/catch</em>, and there is no <em>try/catch</em> in the entire call stack, the program will exit when the sql execution exception occurs.</p>\n<p>For example:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">auto</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">clientPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">execSqlAsyncFuture</span><span class=\"p\">(</span><span class=\"s\">&quot;select * from users where org_name=$1&quot;</span><span class=\"p\">,</span>\n                                    <span class=\"s\">&quot;default&quot;</span><span class=\"p\">);</span>\n<span class=\"k\">try</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span> <span class=\"c1\">// Block until we get the result or catch the exception;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot; rows selected!&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"nl\">row</span> <span class=\"p\">:</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;: user name is &quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">row</span><span class=\"p\">[</span><span class=\"s\">&quot;user_name&quot;</span><span class=\"p\">].</span><span class=\"n\">as</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">DrogonDbException</span> <span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;error:&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">base</span><span class=\"p\">().</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"execsqlsync\">\n<h3>execSqlSync<a class=\"headerlink\" href=\"#execsqlsync\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">...</span> <span class=\"n\">Arguments</span><span class=\"o\">&gt;</span>\n<span class=\"k\">const</span> <span class=\"n\">Result</span> <span class=\"n\">execSqlSync</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">,</span>\n                        <span class=\"n\">Arguments</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>Synchronous interface is the most simple and intuitive, the input parameters are sql string and bound parameters, return a Result object, the call will block the current thread, and throw an exception when an error occurs, so also pay attention to catch exception with <em>try/catch</em>.</p>\n<p>E.g:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">try</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">clientPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">execSqlSync</span><span class=\"p\">(</span><span class=\"s\">&quot;update users set user_name=$1 where user_id=$2&quot;</span><span class=\"p\">,</span>\n                                        <span class=\"s\">&quot;test&quot;</span><span class=\"p\">,</span>\n                                        <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// Block until we get the result or catch the exception;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">affectedRows</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot; rows updated!&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">DrogonDbException</span> <span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;error:&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">base</span><span class=\"p\">().</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"operator\">\n<h3>operator&lt;&lt;<a class=\"headerlink\" href=\"#operator\" title=\"Permalink to this headline\">\u00b6</a></h3>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">internal</span><span class=\"o\">::</span><span class=\"n\">SqlBinder</span> <span class=\"k\">operator</span><span class=\"o\">&lt;&lt;</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">sql</span><span class=\"p\">);</span>\n</pre></div>\n</div>\n<p>The streaming interface is special. It inputs the sql statement and parameters in turn through the &lt;&lt; operator, and specifies the result callback function and the exception callback function through the &gt;&gt; operator. For example, the previous example of selecting, using the streaming interface is Look like this:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"o\">*</span><span class=\"n\">clientPtr</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;select * from users where org_name=$1&quot;</span>\n            <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;default&quot;</span>\n            <span class=\"o\">&gt;&gt;</span> <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">Result</span> <span class=\"o\">&amp;</span><span class=\"n\">r</span><span class=\"p\">)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot; rows selected!&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n                    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"nl\">row</span> <span class=\"p\">:</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n                    <span class=\"p\">{</span>\n                        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;: user name is &quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">row</span><span class=\"p\">[</span><span class=\"s\">&quot;user_name&quot;</span><span class=\"p\">].</span><span class=\"n\">as</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                    <span class=\"p\">}</span>\n                <span class=\"p\">}</span>\n            <span class=\"o\">&gt;&gt;</span> <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">DrogonDbException</span> <span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;error:&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">base</span><span class=\"p\">().</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                <span class=\"p\">};</span>\n</pre></div>\n</div>\n<p>This usage is completely equivalent to the first asynchronous non-blocking interface, and which interface is used depends on the user\u2019s usage habits. If you want it to work in blocking mode, you can use &lt;&lt; to enter a Mode::Blocking parameter, which is not described here.</p>\n<p>In addition, the streaming interface has a special usage. Using a special result callback, the framework can pass the result to the user row by row. The call type of this callback is as follows:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"n\">Arguments</span><span class=\"p\">...);</span>\n</pre></div>\n</div>\n<p>When the first bool parameter is true, it means that the result is a empty row, that is, all the results have been returned, this is the last callback; Behind is a series of parameters, corresponding to the value of each column of a row of records, the framework will do type conversion, of course, the user should also pay attention to the type of matching. These types can be const-type lvalue references, or rvalue references, and of course value types.</p>\n<p>Let\u2019s rewrite the previous example with this callback:</p>\n<div class=\"highlight-cpp notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"o\">*</span><span class=\"n\">clientPtr</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;select user_name, user_id from users where org_name=$1&quot;</span>\n            <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;default&quot;</span>\n            <span class=\"o\">&gt;&gt;</span> <span class=\"p\">[</span><span class=\"o\">&amp;</span><span class=\"n\">i</span><span class=\"p\">](</span><span class=\"kt\">bool</span> <span class=\"n\">isNull</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"kt\">int64_t</span> <span class=\"n\">id</span><span class=\"p\">)</span>\n                    <span class=\"p\">{</span>\n                    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">isNull</span><span class=\"p\">)</span>\n                        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;: user name is &quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;, user id is &quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">id</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                    <span class=\"k\">else</span>\n                        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot; rows selected!&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                    <span class=\"p\">}</span>\n            <span class=\"o\">&gt;&gt;</span> <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">DrogonDbException</span> <span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">)</span>\n                <span class=\"p\">{</span>\n                    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;error:&quot;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">base</span><span class=\"p\">().</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n                <span class=\"p\">};</span>\n</pre></div>\n</div>\n<p>It can be seen that the values \u200b\u200bof the user_name and user_id fields in the select statement are respectively assigned to the name and id variables in the callback function, and the user does not need to handle these conversions by themselves, which obviously provides a certain convenience, and the user can use it flexibly.</p>\n<div class=\"admonition note\">\n<p class=\"first admonition-title\">Note</p>\n<p class=\"last\">Note: It is important to emphasize that in asynchronous programming the user must pay attention to the variable i in the above example. The user must ensure that the variable i is valid when the callback occurs because it is caught by the reference. The callback will be called in another thread, and the current context may have failed when the callback occurred. Programmers typically use smart pointers to hold temporarily created variables and then capture them through callbacks to ensure the validity of the variables.</p>\n</div>\n</div>\n</div>\n<div class=\"section\" id=\"summary\">\n<h2>Summary<a class=\"headerlink\" href=\"#summary\" title=\"Permalink to this headline\">\u00b6</a></h2>\n<p>Each DbClient object has one or multiple its own EventLoop threads controlling the database connection IO, accepting the request via an asynchronous or synchronous interface, and returning the result via a callback function.</p>\n<p>Blocking interfaces of DbClient only block the caller thread, as long as the caller thread is not the EventLoop thread, it will not affect the normal operation of the EventLoop thread. When the callback function is called, the program inside the callback is run on the EventLoop thread. Therefore, do not perform any blocking operations within the callback, otherwise it will affect the concurrency performance of database read and write. Anyone familiar with non-blocking I/O programming should understand this constraint.</p>\n</div>\n</div>\n", "metatags": "", "rellinks": [["genindex", "General Index", "I", "index"], ["DataBase-Transaction-en", "DataBase Transaction", "N", "next"], ["Database-General-en", "Database General", "P", "previous"]], "sourcename": "DataBase-DbClient-en.rstd.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">DataBase DbClient</a><ul>\n<li><a class=\"reference internal\" href=\"#dbclient-object-construction\">DbClient Object Construction</a></li>\n<li><a class=\"reference internal\" href=\"#execution-interface\">Execution Interface</a><ul>\n<li><a class=\"reference internal\" href=\"#execsqlasync\">execSqlAsync</a></li>\n<li><a class=\"reference internal\" href=\"#execsqlasyncfuture\">execSqlAsyncFuture</a></li>\n<li><a class=\"reference internal\" href=\"#execsqlsync\">execSqlSync</a></li>\n<li><a class=\"reference internal\" href=\"#operator\">operator&lt;&lt;</a></li>\n</ul>\n</li>\n<li><a class=\"reference internal\" href=\"#summary\">Summary</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rstd", "current_page_name": "DataBase-DbClient-en", "sidebars": ["localtoc.html", "relations.html", "sourcelink.html", "searchbox.html"], "customsidebar": null, "alabaster_version": "0.7.12"}