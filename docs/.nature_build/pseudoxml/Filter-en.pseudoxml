<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Filter-en.rstd">
    <section ids="filter" names="filter">
        <title>
            Filter
        <paragraph>
            In HttpController’s example, the getInfo method should check whether the user is logged in before returning the user’s information. We can write this logic in the getInfo method, but obviously, checking the user’s login membership is general logic which will be used by many interfaces, it should be extracted separately and configured before calling handler, which is what filters do. After the drogon framework completes the URL path matching, it first calls the filters registered on the path in turn, and only when all the filters allow “pass”, the corresponding handler will be called;
        <section ids="built-in-filter" names="built-in\ filter">
            <title>
                Built-in Filter
            <paragraph>
                Drogon contains the following common filters:
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>
                            <emphasis>
                                drogon::IntranetIpFilter
                            : allow HTTP requests from intranet IP only, or return the 404 page.
                    <list_item>
                        <paragraph>
                            <emphasis>
                                drogon::LocalHostFilter
                            : allow HTTP requests from 127.0.0.1 or ::1 only, or return the 404 page.
        <section ids="custom-filter" names="custom\ filter">
            <title>
                Custom Filter
            <paragraph>
                Of course, users can customize the filter, you need to inherit the HttpFilter class template, the template type is the subclass type, for example, if you want to create a LoginFilter, you could define it as follows:
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                class LoginFilter:public drogon::HttpFilter<LoginFilter>
                {
                public:
                    virtual void doFilter(const HttpRequestPtr &req,
                                        FilterCallback &&fcb,
                                        FilterChainCallback &&fccb) override ;
                };
            <paragraph>
                You could create filter by the 
                <emphasis>
                    drogon_ctl
                 command, see drogon_ctl.
            <paragraph>
                You need to override the doFilter virtual function of the parent class to implement the filter logic;
            <paragraph>
                This virtual function has three parameters, which are:
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>
                            <emphasis>
                                req
                            : http request;
                    <list_item>
                        <paragraph>
                            <emphasis>
                                fcb
                            : filter callback function, the function type is void (HttpResponsePtr), when the filter determines that the request is not valid, the specific response is returned to the browser through this callback;
                    <list_item>
                        <paragraph>
                            <emphasis>
                                fccb
                            : filter chain callback function, the function type is void (), when the filter determines that the request is legal, tells drogon to call the next filter or the final handler through this callback;
            <paragraph>
                The specific implementation can refer to the implementation of the drogon built-in filter.
        <section ids="filter-registration" names="filter\ registration">
            <title>
                Filter Registration
            <paragraph>
                The registration of filters is always accompanied by the registration of controllers.the macros (PATH_ADD, METHOD_ADD, etc.) mentioned earlier can add the name of one or more filters at the end; for example, we change the registration line of the previous 
                <emphasis>
                    getInfo
                 method to the following form:
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get,"LoginFilter");
            <paragraph>
                After the path is successfully matched, the 
                <emphasis>
                    getInfo
                 method will be called only when the following conditions were met:
            <block_quote>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>
                            The request must be an HTTP Get request;
                    <list_item>
                        <paragraph>
                            The requesting party must have logged in;
            <paragraph>
                As you can see, the configuration and registration of filters are very simple. The controller source file that registers filters does not need to include the filter’s header file. The filter and controller are fully decoupled.
            <note>
                <paragraph>
                    Note: If the filter is defined in the namespace, you must write the namespace completely when you register the filter.
