<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\DataBase-Transaction-en.rstd">
    <section ids="database-transaction" names="database\ transaction">
        <title>
            DataBase Transaction
        <paragraph>
            <emphasis>
                Transactions
             are an important feature of relational databases, and Drogon provides transaction support with the 
            <emphasis>
                Transaction
             class.
        <paragraph>
            Objects of the 
            <emphasis>
                Transaction
             class are created by 
            <emphasis>
                DbClient
            , and many transaction-related operations are performed automatically:
        <block_quote>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>
                        At the beginning of the Transaction object creation, the begin statement is automatically executed to start the transaction;
                <list_item>
                    <paragraph>
                        When the Transaction object is destructed, the commit statement is automatically executed to end the transaction;
                <list_item>
                    <paragraph>
                        If there is an exception that causes the transaction to fail, the rollback statement is automatically executed to 
                        <emphasis>
                            `roll back the transaction`
                        ;
                <list_item>
                    <paragraph>
                        If the transaction has been rolled back, then the sql statement will return an exception (throw an exception or perform an exception callback);
        <section ids="transaction-creation" names="transaction\ creation">
            <title>
                Transaction Creation
            <paragraph>
                The method of transaction creation is provided by 
                <emphasis>
                    DbClient
                 as follows:
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                std::shared_ptr<Transaction> newTransaction(const std::function<void(bool)> &commitCallback = std::function<void(bool)>())
            <paragraph>
                This interface is very simple, it returns a smart pointer to a 
                <emphasis>
                    Transaction
                 object. Obviously, when the smart pointer loses all the holders and destructs the transaction object, the transaction ends. The parameter 
                <emphasis>
                    commitCallback
                 is used to return whether the transaction commit is successful. It should be noted that this callback is only used to indicate whether the 
                <emphasis>
                    commit
                 command is successful. If the transaction is automatically or manually rolled back during execution, the 
                <emphasis>
                    callback
                 will not be executed. Generally, the commit command will succeed，the bool type parameter of this callback is true. Only some special cases, such as the connection disconnection during the commit process, will cause the 
                <emphasis>
                    commitCallback
                 to notify the user that the commit fails, at this time, the state of the transaction on the server is not certain, the user needs to deal with this situation specially. Of course, considering that this situation rarely occurs, with non-critical services the user can choose to ignore this event by ignoring the 
                <emphasis>
                    commitCallback
                 parameter when creating the transaction (The default empty callback will be passed to the newTransaction method).
            <paragraph>
                The transaction must monopolize the database connection. Therefore, during transaction creation, 
                <emphasis>
                    DbClient
                 needs to select an idle connection from its own connection pool and hand it over to transaction object management. This has a problem. If all connections in the DbClient are executing sql or other transactions, the interface will block until there is an idle connection.
            <paragraph>
                The framework also provides an asynchronous interface for creating transactions, as follows:
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                void newTransactionAsync(const std::function<void(const std::shared_ptr<Transaction> &)> &callback);
            <paragraph>
                This interface returns the transaction object through the callback function, does not block the current thread, and ensures high concurrency of the application. Users can use it or the synchronous version according to the actual situation.
        <section ids="transaction-interface" names="transaction\ interface">
            <title>
                Transaction Interface
            <paragraph>
                The 
                <emphasis>
                    Transaction
                 interface is almost identical to 
                <emphasis>
                    DbClient
                , except for the following two differences:
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>
                            <emphasis>
                                Transaction
                             provides a 
                            <emphasis>
                                rollback()
                             interface that allows the user to roll back the transaction under any circumstances. Sometimes, the transaction has been automatically rolled back, and then calling the 
                            <emphasis>
                                rollback()
                             interface has no negative impact, so explicitly using the rollback() interface is a good strategy to at least ensure that it is not committed incorrectly.
                    <list_item>
                        <paragraph>
                            The user cannot call the transaction’s 
                            <emphasis>
                                newTransaction()
                             interface, which is easy to understand. Although the database has the concept of a sub-transaction, the framework does not currently support it.
            <paragraph>
                In fact, 
                <emphasis>
                    Transaction
                 is designed as a subclass of 
                <emphasis>
                    DbClient
                , in order to maintain the consistency of these interfaces, and at the same time, it also creates convenient conditions for the use of ORM.
            <paragraph>
                The framework currently does not provide an interface to control transaction isolation levels, that is, the isolation level is the default level of the current database service.
        <section ids="transaction-life-cycle" names="transaction\ life\ cycle">
            <title>
                Transaction Life Cycle
            <paragraph>
                The smart pointer of the transaction object is held by the user. When it has unexecuted sql, the framework will hold it, so don’t worry about the transaction object being destructed when there is still unexecuted sql. In addition, the transaction object smart pointer is often caught and used in the result callback of one of its interfaces. This is the normal way to use, don’t worry that the circular reference will cause the transaction object to never be destroyed, because the framework will help the user break the circular reference automatically.
        <section ids="one-example" names="one\ example">
            <title>
                One Example
            <paragraph>
                For the simplest example, suppose there is a task table from which the user selects an unprocessed task and changes it to the state being processed. To prevent concurrent race conditions, we use the 
                <emphasis>
                    Transaction
                 class, the program is as follows:
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                {
                    auto transPtr = clientPtr->newTransaction();
                    transPtr->execSqlAsync( "select * from tasks where status=$1 for update order by time",
                                            "none",
                                            [=](const Result &r) {
                                                if (r.size() > 0)
                                                {
                                                    std::cout << "Got a task!" << std::endl;
                                                    *transPtr << "update tasks set status=$1 where task_id=$2"
                                                            << "handling"
                                                            << r[0]["task_id"].as<int64_t>()
                                                            >> [](const Result &r)
                                                                {
                                                                    std::cout << "Updated!";
                                                                    ... do something about the task;
                                                                }
                                                            >> [](const DrogonDbException &e)
                                                                {
                                                                    std::cerr << "err:" << e.base().what() << std::end;
                                                                };
                                                }
                                                else
                                                {
                                                    std::cout << "No new tasks found!" << std::endl;
                                                }
                                            },
                                            [](const DrogonDbException &e) {
                                                std::cerr << "err:" << e.base().what() << std::end;
                                            });
                }
            <paragraph>
                In this case, select for update is used to avoid concurrent modifications. The update statement is completed in the result callback of the select statement. The outermost braces are used to limit the scope of the transPtr so that it can be destroyed in time after the execution of sql to end the transaction.
