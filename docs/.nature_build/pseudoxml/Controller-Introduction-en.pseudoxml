<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Controller-Introduction-en.rstd">
    <section ids="controller-introduction" names="controller\ introduction">
        <title>
            Controller Introduction
        <section ids="controller" names="controller">
            <title>
                Controller
            <paragraph>
                The controller is very important in web application development. It processes the request sent by the browser and then generates a response to the browser. The drogon framework has helped us to handle the network transmission, Http protocol analysis and so on. We only need to pay attention to the logic of the controller; each controller object can have one or more processing functions (generally called handlers), and the interface of the function is generally defined as follows:
            <index entries="['single',\ 'handlerName\ (C++\ function)',\ '_CPPv311handlerNameRK14HttpRequestPtrRRNSt8functionIFvRK15HttpResponsePtrEEEz',\ '',\ None]">
            <desc desctype="function" domain="cpp" noindex="False" objtype="function">
                <desc_signature first="False" ids="_CPPv311handlerNameRK14HttpRequestPtrRRNSt8functionIFvRK15HttpResponsePtrEEEz _CPPv211handlerNameRK14HttpRequestPtrRRNSt8functionIFvRK15HttpResponsePtrEEEz" is_multiline="True" names="handlerName">
                    <desc_signature_line add_permalink="True" xml:space="preserve">
                        Void
                         
                        <desc_name xml:space="preserve">
                            handlerName
                        <desc_parameterlist xml:space="preserve">
                            <desc_parameter noemph="True" xml:space="preserve">
                                <desc_annotation xml:space="preserve">
                                    const
                                 
                                HttpRequestPtr
                                 
                                &
                                <emphasis>
                                    req
                            <desc_parameter noemph="True" xml:space="preserve">
                                std
                                ::
                                function
                                <
                                void
                                <desc_parameterlist xml:space="preserve">
                                    <desc_parameter noemph="True" xml:space="preserve">
                                        <desc_annotation xml:space="preserve">
                                            const
                                         
                                        HttpResponsePtr
                                        &
                                >
                                 
                                &
                                &
                                <emphasis>
                                    callback
                            <desc_parameter noemph="True" xml:space="preserve">
                                ...
                <desc_content>
            <paragraph>
                Where 
                <emphasis>
                    req
                 is the object of the Http request (wrapped by the smart pointer), the 
                <emphasis>
                    callback
                 is the callback function object that the framework passes to the controller, and the controller generates the response object (also wrapped by the smart pointer) and then passes the object to the drogon through the callback. Then the framework will send the response content to the browser for you. The last part 
                <emphasis>
                    …
                 is a list of parameters. The drogon maps the parameters in the Http request to the corresponding parameter parameters according to the mapping rules. This is very convenient for application development.
            <paragraph>
                Obviously, this is an asynchronous interface, one can call the callback after completing the time-consuming operation at other threads;
            <paragraph>
                Drogon have three types controllers, HttpSimpleController, HttpController, and WebSocketController. When you use them, the corresponding class template needs to be inherited. For example, a custom class “MyClass” declaration of HttpSimpleController is as follows:
            <container classes="literal-block-wrapper" ids="id1" literal_block="True">
                <caption>
                    <emphasis>
                        MyClass.h
                <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                    class MyClass:public drogon::HttpSimpleController<MyClass>
                    {
                    public:
                        //TestController(){}
                        virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                            std::function<void (const HttpResponsePtr &)> &&callback) override;
                    
                        PATH_LIST_BEGIN
                        PATH_ADD("/json");
                        PATH_LIST_END
                    };
        <section ids="controller-life-cycle" names="controller\ life\ cycle">
            <title>
                Controller life cycle
            <paragraph>
                A controller registered to a drogon framework will have at most only one instance and will not be destroyed during the entire application run, so users can declare and use member variables in the controller class. Note that when the handler of the controller is called, it is in a multi-threaded environment (when the number of IO threads of the framework is configured to be greater than 1), if you need to access non-temporary variables, please do the concurrent protection work.
