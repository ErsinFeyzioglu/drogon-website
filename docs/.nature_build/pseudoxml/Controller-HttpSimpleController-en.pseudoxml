<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Controller-HttpSimpleController-en.rstd">
    <section ids="controller-httpsimplecontroller" names="controller\ httpsimplecontroller">
        <title>
            Controller HttpSimpleController
        <paragraph>
            You could use the 
            <emphasis>
                drogon_ctl
             command line tool to quickly generate custum controller class source files based on 
            <emphasis>
                HttpSimpleController
            , the command format is as bellow:
        <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">
            drogon_ctl create controller <[namespace::]class_name>
        <paragraph>
            We create one controller class named 
            <emphasis>
                TestCtrl
            :
        <literal_block highlight_args="{}" language="bash" linenos="False" xml:space="preserve">
            drogon_ctl create controller TestCtrl
        <paragraph>
            As you can see, there are two new files, TestCtrl.h and TestCtrl.cc. Now, let’s have a look at them:
        <container classes="literal-block-wrapper" ids="id1" literal_block="True">
            <caption>
                <strong>
                    TestCtrl.h：
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                #pragma once
                #include <drogon/HttpSimpleController.h>
                using namespace drogon;
                class TestCtrl:public drogon::HttpSimpleController<TestCtrl>
                {
                public:
                    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                        std::function<void (const HttpResponsePtr &)> &&callback)override;
                    PATH_LIST_BEGIN
                    //list path definitions here;
                    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
                    PATH_LIST_END
                };
        <container classes="literal-block-wrapper" ids="id2" literal_block="True">
            <caption>
                <strong>
                    TestCtrl.cc
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                #include "TestCtrl.h"
                void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                    std::function<void (const HttpResponsePtr &)> &&callback)
                {
                    //write your application logic here
                }
        <paragraph>
            Each HttpSimpleController class can only define one Http request handler, and it is defined by a virtual function override.
        <paragraph>
            The route (or called mapping) from the URL path to the handler is done by a macro. You could add multipath mappings with the 
            <emphasis>
                PATH_ADD
             macro. All 
            <emphasis>
                PATH_ADD
             statements should be set between the 
            <emphasis>
                PATH_LIST_BEGIN
             and 
            <emphasis>
                PATH_LIST_END
             macro statements.
        <paragraph>
            The first parameter is the path to be map, parameters behind the path are constraints on this path. Currently, two types of constraints are supported. One is the 
            <emphasis>
                HttpMethod
             enum Type, which means the Http method allowed. The other type is the name of the 
            <emphasis>
                HttpFilter
             class. One can configure any number of these two types of constraints and there are no order requirements for them. For Filter, please refer to Filter.
        <paragraph>
            Users can register the same Simple Controller to multiple paths, or register multiple Simple Controllers on the same path (using different HTTP methods).
        <paragraph>
            You could define an HttpResponse class variable, and then use the callback() to return it:
        <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
            //write your application logic here
            auto resp=HttpResponse::newHttpResponse();
            resp->setStatusCode(k200OK);
            resp->setContentTypeCode(CT_TEXT_HTML);
            resp->setBody("Your Page Contents");
            callback(resp);
        <paragraph>
            <strong>
                The mapping from the above path to the handler is done at compile time. In fact, the drogon framework also provides an interface for runtime completion mapping. The runtime mapping allows the user to map or modify the mapping through configuration files or other user interfaces without Recompile this program (For performance reasons, it is forbidden to add any controller mapping after running app().run() method).
