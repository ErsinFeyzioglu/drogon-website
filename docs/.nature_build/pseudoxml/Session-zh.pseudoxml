<document source="C:\Users\86175\.github\drogon-all\drogon_web_community\drogon-website\docs\source\Session-zh.rstd">
    <section ids="id1" names="会话">
        <title>
            会话
        <paragraph>
            <problematic ids="id3" refid="id2">
                *
            会话（Session）*是web应用的重要概念，用于在服务端保存客户端的状态，一般和浏览器的cookie配合，drogon提供了对会话的支持。drogon默认关闭会话选择，你也可以通过如下接口关闭或打开：
        <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
            void disableSession();
            void enableSession(const size_t timeout=0);
        <paragraph>
            都是通过*HttpAppFramework*单例调用，timeout参数代表了会话失效的时间，单位是秒，框架默认值是1200，即如果用户20分钟以上没有访问应用，则他对应的会话就失效了。timeout设置为0表示drogon将在整个生存期保留用户的会话；
        <paragraph>
            打开会话特性前请确定你的客户端支持cookie，否则，drogon会为每次不含SessionID的请求创建新的会话，这会白白浪费内存和计算资源。
        <section ids="id4" names="会话对象">
            <title>
                会话对象
            <paragraph>
                drogon的会话对象类型是*drogon::Session*，它和*HttpViewData*非常类似，可以通过关键字存取任意类型的对象；支持并发读写；具体的使用请参考Session class的说明；
            <paragraph>
                drogon框架会把会话对象放到HttpRequest对象里传递给用户，用户可以通过HttpRequest类的如下接口获取Session对象。
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                SessionPtr session() const;
            <paragraph>
                获得的是Session对象的智能指针，通过它可以存取各种对象；
        <section ids="id5" names="会话的例子">
            <title>
                会话的例子
            <paragraph>
                我们这次加一个需要会话支持的功能，比如，我们要限制用户的访问频度，某一次访问后，如果10秒以内再次访问，就返回错误，否则返回ok。我们需要在会话里记录上次访问的时间，然后和本次访问的时间做比较，就可以实现这个功能。
            <paragraph>
                我们创建一个Filter来实现这个功能，假设类名是TimeFilter，实现如下：
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                #include "TimeFilter.h"
                #include <trantor/utils/Date.h>
                #include <trantor/utils/Logger.h>
                #define VDate "visitDate"
                void TimeFilter::doFilter(const HttpRequestPtr &req,
                                        FilterCallback &&cb,
                                        FilterChainCallback &&ccb)
                {
                    trantor::Date now=trantor::Date::date();
                    LOG_TRACE<<"";
                    if(req->session()->find(VDate))
                    {
                        auto lastDate=req->session()->get<trantor::Date>(VDate);
                        LOG_TRACE<<"last:"<<lastDate.toFormattedString(false);
                        req->session()->insert(VDate,now);
                        LOG_TRACE<<"update visitDate";
                        if(now>lastDate.after(10))
                        {
                            //10 sec later can visit again;
                            ccb();
                            return;
                        }
                        else
                        {
                            Json::Value json;
                            json["result"]="error";
                            json["message"]="Access interval should be at least 10 seconds";
                            auto res=HttpResponse::newHttpJsonResponse(json);
                            cb(res);
                            return;
                        }
                    }
                    LOG_TRACE<<"first access,insert visitDate";
                    req->session()->insert(VDate,now);
                    ccb();
                }
            <paragraph>
                我们再注册一个lambda表达式到/slow路径上，同时附加上TimeFilter，代码如下：
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                drogon::HttpAppFramework::instance()
                            .registerHttpMethod("/slow",
                                               [=](const HttpRequestPtr &req,
                                                   std::function<void (const HttpResponsePtr &)> &&callback)
                                               {
                                                   Json::Value json;
                                                   json["result"]="ok";
                                                   auto resp=HttpResponse::newHttpJsonResponse(json);
                                                   callback(resp);
                                               },
                                               {Get,"TimeFilter"});
            <paragraph>
                调用框架接口打开会话
            <literal_block highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">
                drogon::HttpAppFramework::instance().enableSession(1200);
            <paragraph>
                用cmake重新编译整个工程，运行目标程序webapp，就可以通过浏览器看到效果了。
