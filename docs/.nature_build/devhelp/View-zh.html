
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>视图</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="会话" href="Session-zh.html" />
    <link rel="prev" title="过滤器" href="Filter-zh.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Session-zh.html" title="会话"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Filter-zh.html" title="过滤器"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">drogon v1.0.0-beta21 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index-zh.html" accesskey="U">中文文档</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>视图</h1>
<div class="section" id="id2">
<h2>视图介绍</h2>
<p>虽然目前前端渲染技术大行其道，使后端应用服务只需要返回相应数据给前端即可，不过，一个好的web框架还是应该提供后端渲染技术，使服务端程序可以动态生成HTML页面。视图（View）可以帮助使用者生成这些页面，顾名思义，它只负责做跟展示相关的工作，而复杂的业务逻辑都应该交给控制器完成。</p>
<p>最早的web应用程序都是把HTML嵌入到程序编码里，达到动态生成HTML页面的目的，不过这样做有效率低、不直观等诸多缺点，于是出现了诸如JSP等语言，反其道而行之，把程序代码嵌入到HTML页面里。drogon采用的当然是后一种方案，不过，很明显，由于C++是编译执行的，我们需要把这种嵌入了C++代码的页面转换成C++源程序，才能编译进应用程序。所以，drogon定义了自己专门的CSP(C++ Server Pages)描述语言，使用命令行工具drogon_ctl可以把csp文件转换成C++源文件以供编译。</p>
</div>
<div class="section" id="drogoncsp">
<h2>Drogon的csp</h2>
<p>drogon的csp方案很简单，我们用特殊的标记符号把C++代码嵌入到HTML页面里就可以了。其中：</p>
<blockquote>
<div><ul class="simple">
<li>夹在标签*&lt;%inc*和*%&gt;*之间的内容被视为需要引用的头文件部分，这里只能写入*#include*语句，如*&lt;%inc#include “xx.h” %&gt;*,不过很多常见的头文件drogon都自动包含了，用户基本上用不到这个标签；</li>
<li>夹在标签*&lt;%c++*和*%&gt;*之间的所有内容都被视为C++的代码,如*&lt;c++ std:string name=”drogon”; %&gt;*；</li>
<li><dl class="first docutils">
<dt>C++的代码一般都会原封不动的转移到目标源文件中，除了下面两种特殊标记：</dt>
<dd><ul class="first last">
<li><em>&#64;&#64;*代表控制器传过来的data变量，类型是*HttpViewData</em>，可以从中获取需要的内容；</li>
<li><a href="#id3"><span class="problematic" id="id4">*</span></a>$$*代表表示页面内容的流对象，可以把需要显示的内容通过&lt;&lt;操作符显示在页面上；</li>
</ul>
</dd>
</dl>
</li>
<li>夹在标签*[[<em>和</em>]]*之间的内容被认为是变量名字，view会以这个名字为keyword从控制器传过来的数据里找到对应的变量，并把它输出到页面的对应位置，变量名字前后的空格会被省略，<em>[[*和</em>]]*不要分行写，同时，出于性能考虑，只支持三种字符串数据类型*(const char *,std::string和const std::string*，因为输出时涉及数据类型判断，过多类型会导致过多的条件语句)，其他数据类型请用上面提到的方式输出(或者将需要输出的变量以string类型存入data中);</li>
<li>夹在标签*{%*和*%}*之间的内容被认为是C++程序里变量的名字或表达式（而不是控制器传过来的数据的keyword），view会把该变量的内容或表达式的值输出到页面的对应位置。容易知道*{%val.xx%}*等效于*&lt;%c++$$&lt;&lt;val.xx;%&gt;*,只是前者更为简单直观。同样的，两个标签不要分行写；</li>
<li>夹在标签*&lt;%view*和*%&gt;*之间的内容被认为是子视图的名字，框架会找到相应的子视图并把它的内容填充到该标签所在位置；视图名字前后的空格会被忽略，同时*&lt;%view*和*%&gt;*不要分行写，子视图和父视图共用控制器的数据, 可以多级嵌套但不要循环嵌套。</li>
<li>夹在标签*&lt;%layout*和*%&gt;*之间的内容被认为是布局的名字，框架会找到相应的布局并把本视图的内容填充到该布局的某个位置（在布局中由占位符*[[]]*标定该位置）；布局名字前后的空格会被忽略，同时*&lt;%layout*和*%&gt;*不要分行写，可以多级嵌套但不要循环嵌套。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id5">
<h2>视图的使用</h2>
<p>drogon应用程序的http响应都是由控制器handler生成的，所以，由视图渲染的响应也由handler生成，通过调用如下接口生成:</p>
<p>这个接口是HttpResponse类的静态方法，它有两个参数：</p>
<blockquote>
<div><ul class="simple">
<li>viewName: 视图的名字，传入的csp文件名(<strong>扩展名可省略</strong>);</li>
<li>data: 控制器的handler传给视图的数据，类型是*HttpViewData*，这是个特殊的map，可以存入和取出任意类型的对象，具体使用请参考HttpViewData API说明；</li>
</ul>
</div></blockquote>
<p>可以看到，控制器不需要引用视图的头文件，控制器和视图实现了很好的解耦；他们唯一的联系是data变量，对data的内容，控制器和视图要有一致的约定；</p>
</div>
<div class="section" id="id6">
<h2>一个简单的例子</h2>
<p>现在我们做一个例子，把浏览器发来的HTTP请求的参数显示在返回的html页面里。</p>
<p>我们这里直接用HttpAppFramework的接口定义handler，在main文件中，调用run()方法之前加入如下代码：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">drogon</span><span class="o">::</span><span class="n">HttpAppFramework</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span>
        <span class="p">.</span><span class="n">registerHttpMethod</span><span class="p">(</span><span class="s">&quot;/list_para&quot;</span><span class="p">,</span>
                           <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">HttpRequestPtr</span> <span class="o">&amp;</span><span class="n">req</span><span class="p">,</span>
                               <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="k">const</span> <span class="n">HttpResponsePtr</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span>
                           <span class="p">{</span>
                                <span class="k">auto</span> <span class="n">para</span><span class="o">=</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">getParameters</span><span class="p">();</span>
                                <span class="n">HttpViewData</span> <span class="n">data</span><span class="p">;</span>
                                <span class="n">data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span><span class="s">&quot;ListParameters&quot;</span><span class="p">);</span>
                                <span class="n">data</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;parameters&quot;</span><span class="p">,</span><span class="n">para</span><span class="p">);</span>
                                <span class="k">auto</span> <span class="n">resp</span><span class="o">=</span><span class="n">HttpResponse</span><span class="o">::</span><span class="n">newHttpViewResponse</span><span class="p">(</span><span class="s">&quot;ListParameters.csp&quot;</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
                                <span class="n">callback</span><span class="p">(</span><span class="n">resp</span><span class="p">);</span>
                           <span class="p">});</span>
</pre></div>
</div>
<p>上面这段代码把一个lambda表达式handler注册到*/list_para*路径上，获取请求的参数传递给视图显示。 然后进入views文件夹，创建一个视图文件ListParameters.csp，内容如下：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;%c++
    auto <span class="nv">para</span><span class="o">=</span>@@.get&lt;std::unordered_map&lt;std::string,std::string&gt;&gt;<span class="o">(</span><span class="s2">&quot;parameters&quot;</span><span class="o">)</span><span class="p">;</span>
%&gt;
&lt;head&gt;
    &lt;meta <span class="nv">charset</span><span class="o">=</span><span class="s2">&quot;UTF-8&quot;</span>&gt;
    &lt;title&gt;<span class="o">[[</span> title <span class="o">]]</span>&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%c++ <span class="k">if</span><span class="o">(</span>para.size<span class="o">()</span>&gt;0<span class="o">){</span>%&gt;
    &lt;H1&gt;Parameters&lt;/H1&gt;
    &lt;table <span class="nv">border</span><span class="o">=</span><span class="s2">&quot;1&quot;</span>&gt;
    &lt;tr&gt;
        &lt;th&gt;name&lt;/th&gt;
        &lt;th&gt;value&lt;/th&gt;
    &lt;/tr&gt;
    &lt;%c++ <span class="k">for</span><span class="o">(</span>auto iter:para<span class="o">){</span>%&gt;
    &lt;tr&gt;
        &lt;td&gt;<span class="o">{</span>%iter.first%<span class="o">}</span>&lt;/td&gt;
        &lt;td&gt;&lt;%c++ <span class="nv">$$</span>&lt;&lt;iter.second<span class="p">;</span>%&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;%c++<span class="o">}</span>%&gt;
    &lt;/table&gt;
    &lt;%c++ <span class="o">}</span><span class="k">else</span><span class="o">{</span>%&gt;
    &lt;H1&gt;no parameter&lt;/H1&gt;
    &lt;%c++<span class="o">}</span>%&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>我们可以通过下面的命令将ListParameters.csp文件转换成c++源文件：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>drogon_ctl create view ListParameters.csp
</pre></div>
</div>
<p>运行完毕后，当前目录会出现ListParameters.h和ListParameters.cc两个源文件，就可以用来编译进web应用程序里了。</p>
<p>用cmake重新编译整个工程，运行目标程序webapp，就可以在浏览器里测试效果了，在地址栏输入http://localhost/list_para?p1=a&amp;p2=b&amp;p3=c，就可以看到如下页面：</p>
<p>view page</p>
<p>后端渲染的html页面就这样简单的加上了。虽然页面简陋点，但不影响我们说明视图的用法。</p>
</div>
<div class="section" id="csp">
<h2>csp文件的自动化处理</h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意：如果你的工程是使用drogon_ctl命令创建的，那么本节描述的内容已经由该命令自动帮你做了。</p>
</div>
<p>显然，每次修改csp文件都需要手动运行drogon_ctl命令显得太不方便了，我们可以把drogon_ctl的处理放进CMakeLists.txt文件里，仍以前面的例子为例，假设我们把所有的csp文件都放到views文件夹里，则CMakeLists.txt可以添加如下处理：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">FILE</span><span class="p">(</span><span class="n">GLOB</span> <span class="n">SCP_LIST</span> <span class="n">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_SOURCE_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">views</span><span class="cm">/*.csp)</span>
<span class="cm">foreach(cspFile ${SCP_LIST})</span>
<span class="cm">    message(STATUS &quot;cspFile:&quot; ${cspFile})</span>
<span class="cm">    EXEC_PROGRAM(basename ARGS &quot;-s .csp ${cspFile}&quot; OUTPUT_VARIABLE classname)</span>
<span class="cm">    message(STATUS &quot;view classname:&quot; ${classname})</span>
<span class="cm">    add_custom_command(OUTPUT ${classname}.h ${classname}.cc</span>
<span class="cm">        COMMAND drogon_ctl</span>
<span class="cm">        ARGS create view ${cspFile}</span>
<span class="cm">        DEPENDS ${cspFile}</span>
<span class="cm">        VERBATIM )</span>
<span class="cm">set(VIEWSRC ${VIEWSRC} ${classname}.cc)</span>
<span class="cm">endforeach()</span>
</pre></div>
</div>
<p>然后在add_executable语句中添加新的源文件集合${VIEWSRC},如下：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Add_executable</span><span class="p">(</span><span class="n">webapp</span> <span class="n">$</span><span class="p">{</span><span class="n">SRC_DIR</span><span class="p">}</span> <span class="n">$</span><span class="p">{</span><span class="n">VIEWSRC</span><span class="p">})</span>
</pre></div>
</div>
<p>上述措施在drogon_ctl create project命令生成的工程里已经写入CMakeLists.txt文件，用户在views文件夹创建的csp文件都会被自动转换并编译进应用程序。</p>
</div>
<div class="section" id="id7">
<h2>视图的动态编译和加载</h2>
<p>drogon提供了在应用运行期动态编译和加载csp文件的方法，使用如下接口设置：</p>
<p>该接口是*HttpAppFramework*的成员方法，参数是一个字符串数组，代表视图csp文件所在目录的列表。调用这个接口后，drogon将自动搜索这些目录，发现新的或者被修改的csp文件后，都将自动生成源文件、编译成动态库文件并加载到应用里，整个过程应用程序无需重启。用户可以自行实验，观察csp的修改带来的页面变化。</p>
<p>很显然，该功能依赖于开发环境，如果drogon和webapp都在这台服务器编译，则动态加载csp页面也应该没有问题；</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意：动态加载的视图不能静态编译进程序，也就是说，如果一个视图已经静态编译进程序，那么它无法通过动态加载更新，你可以单独建一个动态视图路径，并在开发阶段把视图移动到这个路径进行调试（linux操作系统没有这个问题）。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意: 该特性最好用于在开发阶段方便调整页面，生产环境部署还是建议直接编译成目标文件运行，这主要是出于安全性和稳定性考虑。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意: 如果加载时遇到*symbol not found*错误，请使用*cmake .. -DCMAKE_ENABLE_EXPORTS=on*或取消CMakeLists.txt最后一行对*set_property(TARGET ${PROJECT_NAME} PROPERTY ENABLE_EXPORTS ON)*的注释，并重新编译你的工程</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Session-zh.html" title="会话"
             >next</a> |</li>
        <li class="right" >
          <a href="Filter-zh.html" title="过滤器"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">drogon v1.0.0-beta21 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index-zh.html" >中文文档</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, an-tao.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.9.
    </div>
  </body>
</html>