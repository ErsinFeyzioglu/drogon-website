
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Drogon Internals Manual &#8212; Drogon documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="#" />
    <link rel="search" title="Search" href="#" />
    <!-- <link rel="next" title="Driver Design &amp; Internals" href="DriverInternals.html" />
    <link rel="prev" title="Drogon Formatted Status" href="DrogonFormattedStatus.html" />  -->
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Drogon documentation</span></a></h1>
        <h2 class="heading"><span>“Drogon” Internals Manual</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
        <p>
        «&#160;&#160;::&#160;&#160;
        <a class="uplink" href="#">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="#">Drogon Design &amp; Internals</a>&#160;&#160;»
        </p>
      </div>
<div class="content">  
<div class="section" id="drogon-cfe-internals-manual">
    <h1>“Drogon” CFE Internals Manual<a class="headerlink" href="#" >¶</a></h1>
    <div class="contents local topic" id="contents">
    <ul class="simple">
    <li><a class="reference internal" href="#introduction" id="id3">Introduction</a></li>
    <li><a class="reference internal" href="#Overview" id="id4">Overview</a></li>
    <li><a class="reference internal" href="#Installation" id="id5">Installation</a>
      <ul>
        <li><a class="reference internal" href="#System-Requirements" id="id6">The System Requirements</a>
          <ul>
            <li><a class="reference internal" href="#Library-Dependencies" id="id7">Library-Dependencies</a></li>
            <li><a class="reference internal" href="#trantor" id="id8">trantor</a></li>
            <li><a class="reference internal" href="#jsoncpp" id="id9">jsoncpp</a></li>
            <li><a class="reference internal" href="#libuuid" id="id10">libuuid</a></li>
            <li><a class="reference internal" href="#zlib" id="id11">zlib</a></li>
            <li><a class="reference internal" href="#OpenSSL" id="id12">OpenSSL</a></li>
            <li><a class="reference internal" href="#c-ares" id="id13">c-ares</a></li>
            <li><a class="reference internal" href="#libbrotli" id="id114">libbrotli</a></li>
            <li><a class="reference internal" href="#boost" id="id115">boost</a></li>
            <li><a class="reference internal" href="#the-client-development-libraries-of-postgreSQL" id="id116">the client development libraries of postgreSQL</a></li>
            <li><a class="reference internal" href="#gtest" id="id117">gtest</a></li>
          </ul>
        </li>
        <li><a class="reference internal" href="#System-Preparation-Examples" id="id14">System Preparation Examples</a>
            <ul>
              <li><a class="reference internal" href="#ubuntu1804id" id="id15">Ubuntu 18.04</a></li>
              <li><a class="reference internal" href="#centos75id" id="id16">CentOS 7.5</a></li>
            </ul>
        </li>
        <li><a class="reference internal" href="#Database-Environment" id="id17">Database Environment</a>
          <ul>
            <li><a class="reference internal" href="#postgresqlenv" id="id18">PostgreSQL</a>
              <ul>
                <li><a href="#postgresql_install_in_ubuntu16" title="postgresql install in ubuntu 16">ubuntu 16</a></li>
                <li><a href="#postgresql_install_in_ubuntu18" title="postgresql install in ubuntu 18">ubuntu 18</a></li>
                <li><a href="#postgresql_install_in_centos" title="postgresql install in centos">centos 7</a></li>
                <li><a href="#postgresql_install_in_macos" title="postgresql install in macos">macos</a></li>
              </ul>
            </li>
            <li><a class="reference internal" href="#mysqlenv" id="id19">MySQL</a>
              <ul>
                <li><a href="#mysql_install_in_ubuntu" title="mysql install in ubuntu">ubuntu</a></li>
                <li><a href="#mysql_install_in_centos7" title="mysql install in centos7">centos7</a></li>
                <li><a href="#mysql_install_in_macos" title="mysql install in macos">macos</a></li>
              </ul>
            </li>
            <li><a class="reference internal" href="#sqlite3env" id="id20">Sqlite3</a>
              <ul>
                <li><a href="#sqlite3_install_in_ubuntu" title="sqlite3 install in ubuntu">ubuntu</a></li>
                <li><a href="#sqlite3_install_in_centos" title="sqlite3 install in centos">centos</a></li>
                <li><a href="#sqlite3_install_in_macos" title="sqlite3 install in macos">macos</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a class="reference internal" href="#Drogon-Installation" id="id21">Drogon-Installation</a></li>
        <li><a class="reference internal" href="#Include-drogon-source-code-locally" id="id22">Include drogon source code locally</a></li>
        <li><a class="reference internal" href="#Use-vcpkg" id="id23">Use vcpkg</a></li>
        <li><a class="reference internal" href="#Use-Docker-Image" id="id24">Use Docker Image</a></li>        
    </ul>
    </li>
    <li>
      <a class="reference internal" href="#Quick-Start" id="id25">Quick Start</a>
      <ul>
        <li><a class="reference internal" href="#Static-Site" id="id26">Static Site</a></li>
        <li><a class="reference internal" href="#Dynamic-Site" id="id27">Dynamic Site Site</a></li>  
      </ul>
    </li> 
    <li>
      <a class="reference internal" href="#Controller-Introduction" id="id28">Controller Introduction</a>
      <ul>
        <li><a class="reference internal" href="#Controller" id="id29">Controller</a></li>
        <li><a class="reference internal" href="#Controller-life-cycle" id="id30">Controller life cycle</a></li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#Controller-HttpSimpleController" id="id31">Controller HttpSimpleController</a>
    </li>
    <li>
      <a class="reference internal" href="#Controller-HttpController" id="id32">Controller HttpController</a>
      <ul>
        <li><a class="reference internal" href="#Generation" id="id33">Generation</a></li>
        <li><a class="reference internal" href="#Usage" id="id34">Usage</a></li>
        <li><a class="reference internal" href="#Parameters-mapping" id="id35">Parameters mapping</a></li>
        <li><a class="reference internal" href="#multiple-path-mapping" id="id36">multiple path mapping</a></li>
        <li><a class="reference internal" href="#Regular-expression" id="id37">Regular expression</a></li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#Controller-WebSocketController" id="id38">Controller WebSocketController</a>
      <ul>
        <li><a class="reference internal" href="#WebSocketController" id="id39">WebSocketController</a></li>
        <li><a class="reference internal" href="#WebSocketConnection" id="id40">WebSocketConnection</a></li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#Filter" id="id41">Filter</a>
      <ul>
        <li><a class="reference internal" href="#Built_in_Filter" id="id42">Built-in Filter</a></li>
        <li><a class="reference internal" href="#Custom_Filter" id="id43">Custom Filter</a></li>
        <li><a class="reference internal" href="#Filter_Registration" id="id44">Filter Registration</a></li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#View" id="id45">View</a>
      <ul>
        <li><a class="reference internal" href="#Views_Introduction" id="id46">Views Introduction</a></li>
        <li><a class="reference internal" href="#Drogon_s_CSP" id="id47">Drogon's CSP</a></li>
        <li><a class="reference internal" href="#The_use_of_views" id="id48">The use of views</a></li>  
        <li><a class="reference internal" href="#A_simple_example" title="A simple example" id="id49">A simple example</a></li>     
        <li><a class="reference internal" href="#Automated_processing_of_csp_files" title="Automated processing of csp files" id="id50">Automated processing of csp files</a></li>
        <li><a class="reference internal" href="#Dynamic_compilation_and_loading_of_views" id="id51" title="Dynamic compilation and loading of views">Dynamic compilation and loading of views</a></li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#Session" id="id52">Session</a>
      <ul>
        <li><a class="reference internal" href="#Session_object" id="id53">Session object</a></li>
        <li><a class="reference internal" href="#Examples_of_sessions" id="id54">Examples of sessions</a> </li>
      </ul>
    </li>
    <li>
      <a class="reference internal" href="#Database_General" id="id55">Database General</a>
      <li><a class="reference internal" href="#General" id="id56">General</a></li>
      <li><a class="reference internal" href="#DbClient" id="id57">DbClient</a>
          <ul>
            <li><a class="reference internal" href="#Database_DbClient" id="id60">DataBase DbClient</a>
              <ul>
                <li><a class="reference internal" href="#DbClient_Object_Construction" id="id61">DbClient Object Construction</a>  </li>
                <li><a class="reference internal" href="#Execution_Interface" id="id62">Execution Interface</a>
                  <ul>
                    <li><a class="reference internal" href="#Execution_Interface_execSqlAsync" id="id63">execSqlAsync</a></li>
                    <li><a class="reference internal" href="#Execution_Interface_execSqlAsyncFuture" id="id64">execSqlAsyncFuture</a> </li>
                    <li><a class="reference internal" href="#Execution_Interface_execSqlSync" id="id65">execSqlSync</a></li>
                    <li><a class="reference internal" href="#Execution_Interface_operator" id="id66">operator&lt;&lt;</a> </li>
                  </ul>
                </li>
                <li><a class="reference internal" href="#Summary" id="67">Summary</a></li>
              </ul>
            </li>
          </ul>
        </li>
      <li><a class="reference internal" href="#Transaction" id="id58">Transaction</a>
          <ul>
            <li><a class="reference internal" href="#DataBase_Transaction" id="id68">DataBase Transaction</a>
              <ul>
                <li><a class="reference internal" href="#Transaction_Creation" id="id69">Transaction Creation</a></li>
                <li><a class="reference internal" href="#Transaction_Interface" id="id70">Transaction Interface</a></li>
                <li><a class="reference internal" href="#Transaction_Life_Cycle" id="id71">Transaction Life Cycle</a></li>
                <li><a class="reference internal" href="#One_Example" id="id72">One_Example</a></li>
              </ul>
            </li>
          </ul>
      </li>
      <li><a class="reference internal" href="#ORM" id="id59">ORM</a>
        <ul><li>
          <a class="reference internal" href="#DataBase_ORM" id="id73">DataBase ORM</a>
          <ul>
            <li><a class="reference internal" href="#ORM_Model" id="id74">Model</a> </li>
            <li><a class="reference internal" href="#ORM_Model_Class_Interface" id="id75">Model Class Interface</a> </li>
            <li><a class="reference internal" href="#ORM_Mapper_Class_Template" id="id76">Mapper Class Template</a> </li>
            <li><a class="reference internal" href="#ORM_Criteria" id="id77">Criteria</a> </li>
            <li><a class="reference internal" href="#ORM_Mapper_s_Chain_Interface" id="id78">Mapper's Chain Interface</a> </li>
            <li><a class="reference internal" href="#ORM_Relationships" id="id79">Relationships</a>
              <ul>
                <li><a class="reference internal" href="#ORM_Relationships_has_one" id="id80">has one</a></li>
                <li><a class="reference internal" href="#ORM_Relationships_has_many" id="id81">has many</a></li>
                <li><a class="reference internal" href="#ORM_Relationships_many_to_many" id="id82">many to many</a></li>
                <li><a class="reference internal" href="#ORM_Relationships_Restful_API_controllers" id="id83">Restful API controllers</a></li>                
              </ul>
            </li>
          </ul>
        </li></ul>
      </li>
      <li><a class="reference internal" href="#DataBase_FastDbClient" id="id84">DataBase FastDbClient</a> 
        <ul>
          <li><a class="reference internal" href="#FasstDbClient_Create_and_Get" id="id85">Create and Get</a></li>
          <li><a class="reference internal" href="#FasstDbClient_Usage" id="id86">Usage</a></li>
        </ul>
      </li>
      <li><a class="reference internal" href="#Plugins" id="id87">Plugins</a>
        <ul>
          <li><a class="reference internal" href="#plugins_Configuration" title="Definition" id="id88">Configuration</a></li>
          <li><a class="reference internal" href="#plugins_Definition" title="Definition" id="id89">Definition</a></li>
          <li><a class="reference internal" href="#plugins_Getting_Instance" title="Getting Instance" id="id90">Getting Instance</a></li>
          <li><a class="reference internal" href="#plugins_Life_Cycle" title="Life Cycle" id="id91">Life Cycle</a></li>
        </ul>
      </li>
      <li><a class="reference internal" href="#Configuration_File" id="id92" title="Configuration File">Configuration File</a>
          <ul>
            <li><a class="reference internal" href="#Configuration_File_Details" id="id93" title="Configuration File Details">Configuration File Details</a></li>
            <li><a class="reference internal" href="#Configuration_SSL" id="id94" title="SSL">SSL</a> </li>
            <li><a class="reference internal" href="#listeners" id="id95" title="listeners">listeners</a></li>
            <li><a class="reference internal" href="#db_clients" id="id96" title="db_clients">db_clients</a></li>
            <li><a class="reference internal" href="#threads_num" id="id97" title="threads_num">threads_num</a></li>
            <li><a class="reference internal" href="#Session_configuration_file" id="id98" title="Session">Session</a></li>
            <li><a class="reference internal" href="#document_root" id="id99" title="document_root">document_root</a></li>
            <li><a class="reference internal" href="#upload_path" id="id100" title="upload_path">upload_path</a></li>
            <li><a class="reference internal" href="#file_types" id="id101" title="file_types">file_types</a></li>
            <li><a class="reference internal" href="#Connection_number_control" id="id102" title="Connection number control">Connection number control</a></li>
            <li><a class="reference internal" href="#Log_option" id="id103" title="Log option">Log option</a></li>
            <li><a class="reference internal" href="#Application_control" id="id104" title="Application control">Application control</a></li>
            <li><a class="reference internal" href="#use_sendfile" id="id105" title="use_sendfile">use_sendfile</a></li>
            <li><a class="reference internal" href="#use_gzip" id="id106" title="use_gzip">use_gzip</a></li>
            <li><a class="reference internal" href="#static_files_cache_time" id="id107" title="static_files_cache_time">static_files_cache_time</a></li>
            <li><a class="reference internal" href="#simple_controllers_map" id="id108" title="simple_controllers_map">simple_controllers_map</a></li>
            <li><a class="reference internal" href="#Idle_connection_timeout_control" id="id109" title="Idle connection timeout control">Idle connection timeout control</a></li>
            <li><a class="reference internal" href="#Dynamic_view_loading" id="id110" title="Dynamic view loading">Dynamic view loading</a></li>
            <li><a class="reference internal" href="#Server_header_field" id="id111" title="Server header field">Server header field</a></li>
            <li><a class="reference internal" href="#Keepalive_requests" id="id112" title="Keepalive requests">Keepalive requests</a></li>
            <li><a class="reference internal" href="#Pipelining_requests" id="id113" title="Pipelining requests">Pipelining requests</a></li>                
          </ul>
      </li>
      <li><a class="reference internal" href="#AOP_Aspect_Oriented_Programming" id="id114" title="AOP Aspect Oriented Programming" >AOP Aspect Oriented Programming</a>
        <ul>
          <li><a class="reference internal" href="#Predefined_joinpoints" id="id115" title="Predefined joinpoints">Predefined joinpoints</a> </li>
          <li><a class="reference internal" href="#AOP_schematic" id="id116" title="AOP schematic">AOP schematic</a> </li>
        </ul>
      </li>
      <li><a class="reference internal" href="#Benchmarks" id="id117" title="Benchmarks">Benchmarks</a>
          <ul>
            <li><a class="reference internal" href="#Test_environment" id="id118" title="Test environment">Test environment</a></li>
            <li><a class="reference internal" href="#Test_plan_and_results" id="id119" title="Test plan and results">Test plan and results</a></li>
          </ul>
      </li>
      <li><a class="reference internal" href="#Coz" id="id120" title="Coz">Coz</a>
        <ul>
          <li><a class="reference internal" href="#Causal_profiling_with_coz">Causal profiling with coz</a> </li>
        </ul>
      </li>
    </li>
    </ul>
    </div>
    <div class="section" id="introduction">
    <h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" >¶</a></h2>
    <p>This document describes some of the more important Functions and internal design
    decisions made in the Drogon front-end.  The purpose of this document is to
    both capture some of this high level information and also describe some of the
    design decisions behind it.  This is meant for people interested in hacking on
    Drogon, not for front-users.  The description below is categorized by libraries,
    and does not describe any of the clients of the libraries.</p>
    </div>
    <div class="section" id="Overview">
    <h2><a class="toc-backref" href="#id4">Overview</a><a class="headerlink" href="#llvm-support-library" >¶</a></h2>
    <p>Drogon is a C++14/17-based HTTP application framework. Drogon can be used to easily build various types of web application server programs using C++.<br/>
    Drogon is the name of a dragon in the American TV series "Game of Thrones" that I really like.<br/>
    Drogon's main application platform is Linux. It also supports Mac OS, FreeBSD and Windows.<br/>
    Its main features are as follows:<br/>
      <ul>
        <li>Use a non-blocking I/O network lib based on epoll (kqueue under macOS/FreeBSD) to provide high-concurrency, high-performance network IO, please visit the TFB Tests Results for more details.</li>
        <li>Provide a completely asynchronous programming mode.</li>
        <li>Support Http1.0/1.1 (server side and client side).</li>
        <li>Based on template, a simple reflection mechanism is implemented to completely decouple the main program framework, controllers and views.</li>
        <li>Support cookies and built-in sessions.</li>
        <li>Support back-end rendering, the controller generates the data to the view to generate the Html page. Views are described by CSP template files, C++ codes are embedded into Html pages through CSP tags. And the drogon command-line tool automatically generates the C++ code files for compilation.</li>
        <li>Support view page dynamic loading (dynamic compilation and loading at runtime).</li>
        <li>Provide a convenient and flexible routing solution from the path to the controller handler.</li>
        <li>Support filter chains to facilitate the execution of unified logic (such as login verification, Http Method constraint verification, etc.) before handling HTTP requests.</li>
        <li>Support https (based on OpenSSL);</li>
        <li>Support WebSocket (server side and client side);</li>
        <li>Support JSON format request and response, very friendly to the Restful API application development;</li>
        <li>Support file download and upload;</li>
        <li>Support gzip, brotli compression transmission;</li>
        <li>Support pipelining;</li>
        <li>Provide a lightweight command line tool, drogon_ctl, to simplify the creation of various classes in Drogon and the generation of view code;</li>
        <li>Support non-blocking I/O based asynchronously reading and writing database (PostgreSQL and MySQL(MariaDB) database);</li>
        <li>Support asynchronously reading and writing sqlite3 database based on thread pool;</li>
        <li>Support ARM Architecture;</li>
        <li>Provide a convenient lightweight ORM implementation that supports for regular object-to-database bidirectional mapping;</li>
        <li>Support plugins which can be installed by the configuration file at load time;</li>
        <li>Support AOP with build-in joinpoints.</li>
      </ul>
    </p>
    </div>
    <div class="section" id="Installation">
    <h2><a class="toc-backref" href="#id5">Installation</a><a class="headerlink" href="#Installation" title="Installation">¶</a></h2>
    <p>This section takes Linux as an example to introduce the installation process. Other systems are similar.</p>
    <div class="section" id="System-Requirements">
    <h3><a class="toc-backref" href="#id6">System-Requirements</a><a class="headerlink" href="#System-Requirements" title="System-Requirements">¶</a></h3>
    <p>
      <ul>
        <li>The Linux kernel should be not lower than 2.6.9, 64-bit version;</li>
        <li>The gcc version is not less than 5.4.0;</li>
        <li>Use cmake as the build tool, and the cmake version should be not less than 3.5;</li>
        <li>Use git as the version management tool;</li>
      </ul>
    </p>
    <div class="section" id="Library-Dependencies">
    <h4><a class="toc-backref" href="#id7">Library Dependencies</a><a class="headerlink" href="#Library-Dependencies" title="Library-Dependencies">¶</a></h4>
      <p>
        <ul>
          <li><a href="#id8" id="trantor" title="trantor">trantor</a>, a non-blocking I/O C++ network library, also developed by the author of Drogon, has been used as a git repository submodule, no need to install in advance;</li>
          <li><a href="#installjsoncpp" id="jsoncpp" title="jsoncpp">jsoncpp</a>,JSON's c++ library, the version should be <b>no less than 1.7</b>;</li>
          <li><a href="#installlibuuid" id="libuuid" title="libuuid">libuuid</a>,generating c library of uuid;</li>
          <li><a href="#installzlib" id="zlib" title="zlib">zlib</a>,used to support compressed transmission;</li>
          <li><a href="#installOpenSSL" id="OpenSSL" title="OpenSSL">OpenSSL</a>,not mandatory, if the OpenSSL library is installed, drogon will support HTTPS as well, otherwise drogon only supports HTTP.</li>
          <li><a href="#id13" id="c-ares" title="c-ares">c-ares</a>, not mandatory, if the c-ares library is installed，drogon will be more efficient with DNS;</li>
          <li><a href="#id114" id="libbrotli" title="libbrotli">libbrotli</a>, not mandatory, if the libbrotli library is installed, drogon will support brotli compression when sending HTTP responses;</li>
          <li><a href="#id115" id="boost" title="boost">boost</a>, the version should be no less than 1.61, is required only if the C++ compiler does not support C++ 17.</li>
          <li><a href="#id116" id="the-client-development-libraries-of-postgreSQL" title="the client development libraries of postgreSQL">the client development libraries of postgreSQL</a>, mariadb and sqlite3, not mandatory, if one or more of them is installed, drogon will support access to the according database.</li>
          <li><a href="#id117" id="gtest" title="gtest" >gtest</a>, not mandatory, if the gtest library is installed, the unit tests can be compiled.</li>
        </ul>
      </p>
    </div>
    <div class="section" id="System-Preparation-Examples">
    <h4><a class="toc-backref" href="#id14">System Preparation Examples</a><a class="headerlink" href="#System-Preparation-Examples" >¶</a></h4>
    <h5><a href="#id15" id="ubuntu1804id">Ubuntu 18.04</a></h5>
      <p>Environment</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        sudo apt install git
        sudo apt install gcc
        sudo apt install g++
        sudo apt install cmake
      </pre></div>
      </div>
      <p><a href="#jsoncpp" id="installjsoncpp" title="install jsoncpp">jsoncpp</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        sudo apt install libjsoncpp-dev
      </pre></div>
      </div>
      <p>Notes: see <a href="#jsoncppinstallincentos" >Jsoncpp installation in Centos</a>,which made in source.</p>
      <p><a href="#libuuid" id="installlibuuid" title="install installlibuuid">UUID</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        sudo apt install uuid-dev
      </pre></div>
      </div>
      <p>Notes: see <a href="#libuuidinstallincentos" >Jsoncpp installation </a>in Centos.</p>
      <p><a href="#OpenSSL" id="installOpenSSL" title="install installOpenSSL">OpenSSL</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        sudo apt install openssl
        sudo apt install libssl-dev
      </pre></div>
      </div>
      <p>Notes: see <a href="#opensslinstallincentos" >OpenSSL installation </a>in Centos.</p>
      <p><a href="#zlib" id="installzlib" title="install installzlib">zlib</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        sudo apt install zlib1g-dev
      </pre></div>
      </div>
      <p>Notes: see <a href="#zlibinstallincentos" >Zlib installation </a>in Centos.</p>
      <h5><a href="#id16" id="centos75id">CentOS 7.5</a></h5>
      <p>Environment</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        yum install git
        yum install gcc
        yum install gcc-c++
      </pre></div>
      </div>
      <p>The default installed cmake version is too low, use source installation</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        git clone https://github.com/Kitware/CMake
        cd CMake/
        ./bootstrap && make && make install
      </pre></div>
      </div>
      <p>Upgrade gcc</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        yum install centos-release-scl
        yum install devtoolset-8
        scl enable devtoolset-8 bash
      </pre></div>
      </div>
      <p><b>Note: Command scl enable devtoolset-8 bash only activate the new gcc temporarily until the session is end. If you want to always use the new gcc, you could run command echo "scl enable devtoolset-8 bash" >> ~/.bash_profile, system will automatically activate the new gcc after restarting.</b></p>
      <p><a href="#jsoncpp" id="jsoncppinstallincentos">jsoncpp</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        git clone https://github.com/open-source-parsers/jsoncpp
        cd jsoncpp/
        mkdir build
        cd build
        cmake ..
        make && make install
      </pre></div>
      </div>
      <p><a href="#libuuid" id="libuuidinstallincentos">uuid</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        yum install libuuid-devel
      </pre></div>
      </div>
      
      <p><a href="#OpenSSL" id="opensslinstallincentos">OpenSSL</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        yum install openssl-devel
      </pre></div>
      </div>
      
      <p><a href="#zlib" id="zlibinstallincentos">zlib</a></p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        yum install zlib-devel
      </pre></div>
      </div>

      <div class="section" id="Database-Environment">
        <h4><a class="toc-backref" href="#id17">Database Environment</a><a class="headerlink" href="#Database-Environment" >¶</a></h4>

        <p><a id="postgresqlenv" title="postgresqlenv">PostgreSQL</a></p>
        <p><a href="#" id="postgresql_install_in_ubuntu16">ubuntu 16</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          sudo apt-get install postgresql-server-dev-all
        </pre></div>
        </div>
        <p><a href="#" id="postgresql_install_in_ubuntu18">ubuntu 18</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          sudo apt-get install postgresql-all
        </pre></div>
        </div>
        <p><a href="#" id="postgresql_install_in_centos">centos 7</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          yum install postgresql-devel
        </pre></div>
        </div>
        <p><a href="#" id="postgresql_install_in_macos">macos</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          brew install postgresql
        </pre></div>
        </div>
        <p><a id="mysqlenv" title="mysqlenv">MySQL</a></p>
        <p><b>Notes:MySQL's native library does not support asynchronous read and write. Fortunately, MySQL also has a version of MariaDB maintained by the original developer community. This version is compatible with MySQL, and its development library supports asynchronous read and write. Therefore, Drogon uses the MariaDB development library to provide the right MySQL support, as a best practice，your operating system shouldn't install both Mysql and MariaDB at the same time.</b></p>
        <p><a href="#" id="mysql_install_in_ubuntu">ubuntu</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          sudo apt install libmariadbclient-dev
        </pre></div>
        </div>
        <p><a href="#" id="mysql_install_in_centos7">centos 7</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          yum install mariadb-devel
        </pre></div>
        </div>
        <p><a href="#" id="mysql_install_in_macos">macos</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          brew install mariadb
        </pre></div>
        </div>
        
        <p><a id="sqlite3env" href="#20" title="sqlite3">Sqlite3</a></p>
        <p><a href="#" id="sqlite3_install_in_ubuntu">ubuntu</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          sudo apt-get install libsqlite3-dev
        </pre></div>
        </div>
        <p><a href="#" id="sqlite3_install_in_centos">cenots7</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          yum install sqlite-devel
        </pre></div>
        </div>
        <p><a href="#" id="sqlite3_install_in_macos">macos</a></p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          brew install sqlite3
        </pre></div>
        </div>
        <p><b>Note: Some of the above commands only install the development library. If you want to install a server also, please use Google search yourself.</b></p>
      </div>
        <div class="section" id="Drogon-Installation">
          <h4><a class="toc-backref" href="#id21">Drogon Installation</a><a class="headerlink" href="#System-Preparation-Examples" >¶</a></h4>
            <p>Assuming that the above environment and library dependencies are all ready, the installation process is very simple;</p>
            <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              cd $WORK_PATH
              git clone https://github.com/an-tao/drogon
              cd drogon
              git submodule update --init
              mkdir build
              cd build
              cmake ..
              make && sudo make install
            </pre></div>
            </div>
            <p>The default is to compile the debug version. If you want to compile the release version, the cmake command should take the following parameters:</p>
            <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              cmake -DCMAKE_BUILD_TYPE=Release .. 
              </pre></div>
            </div>
            <p>After the installation is complete, the following files will be installed in the system（One can change the installation location with the CMAKE_INSTALL_PREFIX option）:</p>
            <ul>
              <li>The header file of drogon is installed into /usr/local/include/drogon</li>
              <li>The drogon library file libdrogon.a is installed into /usr/local/lib</li>
              <li>Drogon's command line tool drogon_ctl is installed into /usr/local/bin</li>
              <li>The trantor header file is installed into /usr/local/include/trantor</li>
              <li>The trantor library file libtrantor.a is installed into /usr/local/lib</li>
            </ul>
          </div>
          <div class="section" id="Include-drogon-source-code-locally">
            <h4><a class="toc-backref" href="#id22">Include drogon source code locally</a><a class="headerlink" href="#System-Preparation-Examples" >¶</a></h4>
            <p>Of course, you can also include the drogon source in your project. Suppose you put the drogon under the third_party of your project directory (don't forget to update submodule in the drogon source directory). Then, you only need to add the following two lines to your project's cmake file:</p>
            <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              add_subdirectory(third_party/drogon)
              target_link_libraries(${PROJECT_NAME} PRIVATE drogon)
              </pre></div>
            </div>
          </div>
          <div class="section" id="Use-vcpkg">
            <h4><a class="toc-backref" href="#id23">Use vcpkg</a><a class="headerlink" href="#System-Preparation-Examples" >¶</a></h4>
            <p>The easiest way to install drogon on windows is to use vcpkg</p>
            <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              vcpkg.exe install drogon
              </pre></div>
            </div>
            <p>Or</p>
            <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              vcpkg.exe install drogon:x64-windows
              </pre></div>
            </div>
          </div>
          <div class="section" id="Use-Docker-Image">
            <h4><a class="toc-backref" href="#id24">Use Docker Image</a><a class="headerlink" href="#System-Preparation-Examples" >¶</a></h4>
            <p>We also provide a pre-build docker image on the <a href="https://hub.docker.com/r/drogonframework/drogon">docker hub</a>. All dependencies of Drogon and Drogon itself are already installed in the docker environment, where users can build Drogon-based applications directly.</p>
          </div>
    </div>


      
     <!-- <li>Make sure that your expression’s constructor properly computes the flags
    for type dependence (i.e., the type your expression produces can change
    from one instantiation to the next), value dependence (i.e., the constant
    value your expression produces can change from one instantiation to the
    next), instantiation dependence (i.e., a template parameter occurs
    anywhere in your expression), and whether your expression contains a
    parameter pack (for variadic templates).  Often, computing these flags
    just means combining the results from the various types and
    subexpressions.</li> -->
    <!-- <li>Add <code class="docutils literal notranslate"><span class="pre">TransformXXX</span></code> and <code class="docutils literal notranslate"><span class="pre">RebuildXXX</span></code> functions to the <code class="docutils literal notranslate"><span class="pre">TreeTransform</span></code>
    class template in <code class="docutils literal notranslate"><span class="pre">Sema</span></code>.  <code class="docutils literal notranslate"><span class="pre">TransformXXX</span></code> should (recursively)
    transform all of the subexpressions and types within your expression,
    using <code class="docutils literal notranslate"><span class="pre">getDerived().TransformYYY</span></code>.  If all of the subexpressions and
    types transform without error, it will then call the <code class="docutils literal notranslate"><span class="pre">RebuildXXX</span></code>
    function, which will in turn call <code class="docutils literal notranslate"><span class="pre">getSema().BuildXXX</span></code> to perform
    semantic analysis and build your expression.</li> -->
    <!-- <li>To test template instantiation, take those tests you wrote to make sure
    that you were type checking with type-dependent expressions and dependent
    types (from step #2) and instantiate those templates with various types,
    some of which type-check and some that don’t, and test the error messages
    in each case.</li> -->
    </ul>
    </li>
    <!-- <li>There are some “extras” that make other features work better.  It’s worth
    handling these extras to give your expression complete integration into
    Drogon:<ul>
    <li>Add code completion support for your expression in
    <code class="docutils literal notranslate"><span class="pre">SemaCodeComplete.cpp</span></code>.</li>
    <li>If your expression has types in it, or has any “interesting” features
    other than subexpressions, extend libclang’s <code class="docutils literal notranslate"><span class="pre">CursorVisitor</span></code> to provide
    proper visitation for your expression, enabling various IDE features such
    as syntax highlighting, cross-referencing, and so on.  The
    <code class="docutils literal notranslate"><span class="pre">c-index-test</span></code> helper program can be used to test these features.</li>
    </ul>
    </li> -->
    </ol>
    </div>
    </div>
    <div class="section" id="Quick-Start">
      <h2><a class="toc-backref" href="#id25">Quick-Start</a><a class="headerlink" href="#Quick-Start" >¶</a></h2>
    </div>
    <div class="section" id="Static-Site">
      <h2><a class="toc-backref" href="#id26">Static Site</a><a class="headerlink" href="#Static-Site" >¶</a></h2>
      <p>Let's start with a simple example that introduces the usage of drogon. In this example we create a project using the command line tool drogon_ctl:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create project your_project_name
      </pre></div>
      </div>
      <p>There are several useful folders in the project directory already:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        ├── build                         Build folder
        ├── CMakeLists.txt                Project cmake configuration file
        ├── config.json                   Drogon application configuration file
        ├── controllers                   The folder where the controller source files are stored
        ├── filters                       The folder where the filter files are stored
        ├── main.cc                       Main program
        ├── models                        The folder of the database model file
        │   └── model.json
        └── views                         The folder where view csp files are stored
      </pre></div>
      </div>
      <p>Users can put various files (such as controllers, filters, views, etc.) into corresponding folders. For more convenience and less error, we strongly recommend that users create their own web application projects using the drogon_ctl command. See drogon_ctl for more details.</p>
      <p>Let's look at the main.cc file:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include <drogon/HttpAppFramework.h>
        int main() {
            //Set HTTP listener address and port
            drogon::app().addListener("0.0.0.0",80);
            //Load config file
            //drogon::app().loadConfigFile("../config.json");
            //Run HTTP framework,the method will block in the internal event loop
            drogon::app().run();
            return 0;
        }
      </pre></div>
      </div>
      <p>Then build your project as below:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        cd build
        cmake ..
        make
      </pre></div>
      </div>
      <p>After the compilation is complete, run the target ./your_project_name.</p>
      <p>Now, we add one simply static file index.html to the Http root path:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        echo '&lt;h1&gt;Hello Drogon!&lt;/h1&gt;' >>index.html
      </pre></div>
      </div>
      <p>Now, we add one simply static file index.html to the Http root path:</p>
      <p>The default root path is "./", this could be modified by config.json also, See <a href="https://github.com/an-tao/drogon/wiki/10-Configureation-File" title="Configureation File">Configureation File</a> for more details. Then you can visit this page by URL "http://localhost" or"http://localhost/index.html" (or the IP of the server where your wepapp running).</p>
      <br/>
      <br/>
      <br/>
      <p>Hello Drogon!</p>
      <p>If server cannot find the the page you have requested, it return 404 page: 404 page</p>
      <p>Note: Make sure your server firewall have allowed the 80 port, otherwise you won't see these pages.</p>
      <p>We could copy the directory and files of a static website to the startup directory of this running webapp, then we can access them from the browser. The file types supported by drogon are "html", "js", "css", "xml", "xsl", "txt", "svg", "ttf", "otf", "woff2", "woff" , "eot", "png", "jpg", "jpeg", "gif", "bmp", "ico", "icns", etc by default. Drogon also provides interfaces to change these file types. For details, please refer to the <a href="https://github.com/an-tao/drogon/wiki/API-HttpAppFramework" title="HttpAppFramework API">HttpAppFramework API</a>.</p>
    </div>
    <div class="section" id="Dynamic-Site">
      <h2><a class="toc-backref" href="#id27">Dynamic Site</a><a class="headerlink" href="#Dynamic-Site" >¶</a></h2>
      <p>Let's see how to add controllers to this application， and let the controller respond contents.</p>
      <p>One can use the drogon_ctl command line tool to generate controller source files. Let's run it in the controllers directory:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller TestCtrl
      </pre></div>
      </div>
      <p>As you can see, there are two new files, TestCtrl.h and TestCtrl.cc：</p>
      <p>TestCtrl.h is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #pragma once
        #include &lt;drogon/HttpSimpleController.h&gt;
        using namespace drogon;
        class TestCtrl:public drogon::HttpSimpleController&lt;TestCtrl&gt;
        {
        public:
            virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)override;
            PATH_LIST_BEGIN
            //list path definitions here;
            //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
            PATH_LIST_END
        };
      </pre></div>
      </div>
      <p>TestCtrl.cc is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include "TestCtrl.h"
        void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                              std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)
        {
            //write your application logic here
        }
      </pre></div>
      </div>
      <p>Let's edit the two files and let the controller handle the function response to a simple "Hello World!"</p>
      <p>TestCtrl.h is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #pragma once
        #include &lt;drogon/HttpSimpleController.h&gt;
        using namespace drogon;
        class TestCtrl:public drogon::HttpSimpleController&lt;TestCtrl&gt;
        {
        public:
            virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)override;
            PATH_LIST_BEGIN
            //list path definitions here;
            //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
            PATH_ADD("/",Get,Post);
            PATH_ADD("/test",Get);
            PATH_LIST_END
        };
      </pre></div>
      </div>
      <p>Use PATH_ADD to map processing functions on the two paths '/' and '/test' respectively, and adding constraints on these path.</p>
      <p>TestCtrl.cc is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include "TestCtrl.h"
        void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                              std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)
        {
            //write your application logic here
            auto resp=HttpResponse::newHttpResponse();
            resp->setStatusCode(k200OK);
            resp->setContentTypeCode(CT_TEXT_HTML);
            resp->setBody("Hello World!");
            callback(resp);
        }
      </pre></div>
      </div>
      <p>Recompile this project with cmake, then run the target ./your_project_name:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        cd ../build
        cmake ..
        make
        ./your_project_name
      </pre></div>
      </div>
      <p>Typing "http://localhost/" or "http://localhost/test" in the browser address bar, and you will see "Hello World!" in the browser.</p>
      <br/>
      <p><b>Note: If your server both have static and dynamic resource, Drogon use dynamic resource first, In this example，the respond of http://localhost/ is Hello Word! in TestCtrl controller instead of Hello Drogon! in static file index.html.</b></p>
      <br/>
      <p>We see that adding a controller to an application is very simple. You only need to add the corresponding source file. Even the main file does not need to be modified. This low-coupling design is very effective for web application development.</p>
      <br/>
      <p><b>Note: Drogon has no restrictions to the location of the controllers source file, you could save it at the project directory also, even you could define new directory in the CMakeLists.txt, it is recommended to use the controllers directory for the convenience of management.</b></p>
    </div>
    <div class="section" id="Controller-Introduction">
      <h2><a class="toc-backref" href="#id28">Controller Introduction</a><a class="headerlink" href="#Controller-Introduction" >¶</a></h2>
    </div>
    <div class="section" id="Controller">
      <h2><a class="toc-backref" href="#id29">Controller</a><a class="headerlink" href="#Controller" >¶</a></h2>
      <p>The controller is very important in web application development. It processes the request sent by the browser and then generates a response to the browser. The drogon framework has helped us to handle the network transmission, Http protocol analysis and so on. We only need to pay attention to the logic of the controller; each controller object can have one or more processing functions (generally called handlers), and the interface of the function is generally defined as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        Void handlerName(const HttpRequestPtr &req,
                  std::function<void (const HttpResponsePtr &)> &&callback, 
                 ...);
      </pre></div>
      </div>
      <p>Where req is the object of the Http request (wrapped by the smart pointer), the callback is the callback function object that the framework passes to the controller, and the controller generates the response object (also wrapped by the smart pointer) and then passes the object to the drogon through the callback. Then the framework will send the response content to the browser for you. The last part ... is a list of parameters. The drogon maps the parameters in the Http request to the corresponding parameter parameters according to the mapping rules. This is very convenient for application development.</p>
      <br>
      <p>Obviously, this is an asynchronous interface, one can call the callback after completing the time-consuming operation at other threads.</p>
      <p>Drogon have three types controllers, HttpSimpleController, HttpController, and WebSocketController. When you use them, the corresponding class template needs to be inherited. For example, a custom class "MyClass" declaration of HttpSimpleController is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        class MyClass:public drogon::HttpSimpleController<MyClass>
          {
          public:
              //TestController(){}
              virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                   std::function<void (const HttpResponsePtr &)> &&callback) override;
          
              PATH_LIST_BEGIN
              PATH_ADD("/json");
              PATH_LIST_END
          };
      </pre></div>
      </div>
    </div>
    <div class="section" id="Controller-life-cycle">
      <h2><a class="toc-backref" href="#id30">Controller life cycle</a><a class="headerlink" href="#Controller-life-cycle" >¶</a></h2>
      <p>A controller registered to a drogon framework will have at most only one instance and will not be destroyed during the entire application run, so users can declare and use member variables in the controller class. Note that when the handler of the controller is called, it is in a multi-threaded environment (when the number of IO threads of the framework is configured to be greater than 1), if you need to access non-temporary variables, please do the concurrent protection work.</p>
    </div>
    <div class="section" id="Controller-HttpSimpleController">
      <h2><a class="toc-backref" href="#id31">Controller HttpSimpleController</a><a class="headerlink" href="#Controller-HttpSimpleController" >¶</a></h2>
      <p>You could use the drogon_ctl command line tool to quickly generate custum controller class source files based on HttpSimpleController, the command format is as bellow:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller &lt;[namespace::]class_name&gt;
      </pre></div>
      </div>
      <p>We create one controller class named TestCtrl:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller TestCtrl
      </pre></div>
      </div>
      <p>As you can see, there are two new files, TestCtrl.h and TestCtrl.cc. Now, let's have a look at them:</p>
      <p>TestCtrl.h：</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #pragma once
        #include &lt;drogon/HttpSimpleController.h&gt;
        using namespace drogon;
        class TestCtrl:public drogon::HttpSimpleController&lt;TestCtrl&gt;
        {
        public:
            virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,
                                                std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)override;
            PATH_LIST_BEGIN
            //list path definitions here;
            //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);
            PATH_LIST_END
        };
      </pre></div>
      </div>
      <p>TestCtrl.cc:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include "TestCtrl.h"
        void TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,
                                              std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)
        {
            //write your application logic here
        }
      </pre></div>
      </div>
      <p>Each HttpSimpleController class can only define one Http request handler, and it is defined by a virtual function override.</p>
      <br/>
      <p>The route (or called mapping) from the URL path to the handler is done by a macro. You could add multipath mappings with the <b>PATH_ADD</b> macro. <b>All PATH_ADD</b> statements should be set between the <b>PATH_LIST_BEGIN</b> and <b>PATH_LIST_END</b> macro statements.</p>
      <br/>
      <p>The first parameter is the path to be map, parameters behind the path are constraints on this path. Currently, two types of constraints are supported. One is the <b>HttpMethod</b> enum Type, which means the Http method allowed. The other type is the name of the <b>HttpFilter</b> class. One can configure any number of these two types of constraints and there are no order requirements for them. For Filter, please refer to Filter.</p>
      <br/>
      <p>Users can register the same Simple Controller to multiple paths, or register multiple Simple Controllers on the same path (using different HTTP methods).</p>
      <p>You could define an HttpResponse class variable, and then use the callback() to return it:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //write your application logic here
        auto resp=HttpResponse::newHttpResponse();
        resp->setStatusCode(k200OK);
        resp->setContentTypeCode(CT_TEXT_HTML);
        resp->setBody("Your Page Contents");
        callback(resp);
      </pre></div>
      </div>
      <p><b>The mapping from the above path to the handler is done at compile time. In fact, the drogon framework also provides an interface for runtime completion mapping. The runtime mapping allows the user to map or modify the mapping through configuration files or other user interfaces without Recompile this program (For performance reasons, it is forbidden to add any controller mapping after running app().run() method).</b></p>
    </div>
    <div class="section" id="Controller-HttpController">
      <h2><a class="toc-backref" href="#id32">Controller HttpController</a><a class="headerlink" href="#Controller-HttpController" >¶</a></h2>
      <h3><a href="#id33" id="Generation" title="Generation">Generation</a></h3>
      <p>You can use the <b>drogon_ctl</b> command line tool to quickly generate custum controller class source files based on <b>HttpController</b>, the command format is as bellow:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller -h &lt;[namespace::]class_name&gt;
      </pre></div>
      </div>
      <p>We create one controller class named <b>User</b>, under namespace <b>demo v1</b>:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller -h demo::v1::User
      </pre></div>
      </div>
      <p>As you can see, two files have been added to the current directory, demo_v1_User.h and demo_v1_User.cc.</p>
      <p>demo_v1_User.h is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #pragma once
        #include &lt;drogon/HttpController.h&gt;
        using namespace drogon;
        namespace demo
        {
            namespace v1
            {
                class User:public drogon::HttpController&lt;User&gt;
                {
                public:
                    METHOD_LIST_BEGIN
                        //use METHOD_ADD to add your custom processing function here;
                    METHOD_LIST_END
                    //your declaration of processing function maybe like this:
                };
            }
        }
      </pre></div>
      </div>
      <p>demo_v1_User.cc is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include "demo_v1_User.h"
        using namespace demo::v1;
        //add definition of your processing function here
      </pre></div>
      </div>
      <h3><a href="#id34" id="Usage" title="Usage">Usage</a></h3>
        <p>Let's edit the two files:</p>
        <p>demo_v1_User.h is as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          #pragma once
          #include &lt;drogon/HttpController.h&gt;
          using namespace drogon;
          namespace demo
          {
              namespace v1
              {
                  class User:public drogon::HttpController&lt;User&gt;
                  {
                  public:
                      METHOD_LIST_BEGIN
                          //use METHOD_ADD to add your custom processing function here;
                          METHOD_ADD(User::login,"/token?userId={1}&passwd={2}",Post);
                          METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get);
                      METHOD_LIST_END
                      //your declaration of processing function maybe like this:
                      void login(const HttpRequestPtr &req,
                                std::function&lt;void (const HttpResponsePtr &)&gt; &&callback,
                                std::string &&userId,
                                const std::string &password);
                      void getInfo(const HttpRequestPtr &req,
                                  std::function&lt;void (const HttpResponsePtr &)&gt; &&callback,
                                  std::string userId,
                                  const std::string &token) const;
                  };
              }
          }
        </pre></div>
        </div>
        <p>demo_v1_User.cc is as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          #include "demo_v1_User.h"
          using namespace demo::v1;
          //add definition of your processing function here

          void User::login(const HttpRequestPtr &req,
                    std::function&lt;void (const HttpResponsePtr &)&gt; &&callback,
                    std::string &&userId,
                    const std::string &password)
          {
              LOG_DEBUG&lt;&lt;"User "&lt;&lt;userId&lt;&lt;" login";
              //Authentication algorithm, read database, verify identity, etc...
              //...
              Json::Value ret;
              ret["result"]="ok";
              ret["token"]=drogon::utils::getUuid();
              auto resp=HttpResponse::newHttpJsonResponse(ret);
              callback(resp);
          }
          void User::getInfo(const HttpRequestPtr &req,
                      std::function&lt;void (const HttpResponsePtr &)&gt; &&callback,
                      std::string userId,
                      const std::string &token) const
          {
              LOG_DEBUG&lt;&lt;"User "&lt;&lt;userId&lt;&lt;" get his information";

              //Verify the validity of the token, etc.
              //Read the database or cache to get user information
              Json::Value ret;
              ret["result"]="ok";
              ret["user_name"]="Jack";
              ret["user_id"]=userId;
              ret["gender"]=1;
              auto resp=HttpResponse::newHttpJsonResponse(ret);
              callback(resp);
          }
        </pre></div>
        </div>
        <p>Each HttpController class can define many Http request handlers. Since the number of functions can be arbitrarily large, it is unrealistic to overload them with virtual functions. We need to register the handler itself (not the class) in the framework.</p>
        <br/>
        <p>The mapping from the URL path to the handler is done by macros. You can add a multipath map with the <b>METHOD_ADD</b> macro or the <b>ADD_METHOD_TO</b> macro. All <b>METHOD_ADD</b> and <b>ADD_METHOD_TO</b> statements should be sandwiched between the <b>METHOD_LIST_BEGIN</b> and <b>METHOD_LIST_END</b> macro statements.</p>
        <br/>
        <p>The <b>METHOD_ADD</b> macro automatically prefixes the namespace and class name in the path map. Therefore, in this example, the login function is registered to the <b>/demo/v1/user/token</b> path, and the getInfo function is registered to the <b>/demo/v1/user/xxx/info</b> path. Constraints are similar to the <b>PATH_ADD</b> macro of HttpSimpleController and not be described here.</p>
        <br/>
        <p>The <b>ADD_METHOD_TO</b> macro acts almost as much as the former, except that it does not automatically add any prefixes, i.e. the path registered by the macro is an absolute path.</p>
        <br/>
        <p>We see that <b>HttpController</b> provides a more flexible path mapping mechanism, we can put a class of functions in a class.</p>
        <br/>
        <p>In addition, you can see that the macros provide a method for parameters mapping. We can map the parameters on the path to the parameter list of the function. The number of URL path parameter corresponds to the function parameter's position, this is very convenient. The common types which can be converted by string type all can be used as function parameters (such as std::string, int, float, double, etc.), the drogon framework will automatically help you convert the type, this is very convenient for developing. Note that lvalue references must be of type const.</p>
        <br/>
        <p>The same path can be mapped multiple times, distinguished from each other by Http Method, which is legal and is a common practice of the Restful API,</p><p>such as:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          METHOD_LIST_BEGIN
          METHOD_ADD(Book::getInfo,"/{1}?detail={2}",Get);
          METHOD_ADD(Book::newBook,"/{1}",Post);
          METHOD_ADD(Book::deleteOne,"/{1}",Delete);
          METHOD_LIST_END
        </pre></div>
        </div>
        <p>When you use the <b>ADD_METHOD</b> macro and the class belongs to some namespace, you should add namespace to the access url, in this example, use <b>http://localhost/demo/v1/user/token?userid=xxx&passwd=xxx</b> or <b>http://localhost/demo/v1/user/xxxxx/info?token=xxxx</b> to access.</p>
        <br/>
        <p>The placeholders of path parameters can be written in several ways:</p>
        <ul>          
          <li><b>{}</b>: The position on the path is the position of the function parameter, which indicates that the path parameter maps to the corresponding position of the handler parameters.</li>
          <li><b>{1},{2}</b>: The path parameters with a number in are mapped to the handler parameters specified by the number.</li>
          <li><b>{anystring}</b>: Strings here have no practical effect, but can improve the readability of the program, equivalent to <b>{}</b>.</li>
          <li><b>{1:anystring},{2:xxx}</b>: The number before the colon represents the position, and the string behind it does not actually work, but can improve the readability of the program, which is equivalent to the <b>{1}</b> and <b>{2}</b>.</li>
        </ul>
        <p>The latter two writes are recommended, and if the path parameters and function parameters are in the same order, the third is enough. It is easy to know that the following writes are equivalent:</p>
        <ul>
          <li>"/users/{}/books/{}"</li>
          <li>"/users/{}/books/{2}"</li>
          <li>"/users/{user_id}/books/{book_id}"</li>
          <li>"/users/{1:user_id}/books/{2}"</li>
        </ul>
        <p><b>Note: Path matching is not case sensitive, parameter names are case sensitive, (Parameter values ​​can be mixed in uppercase and lowercase and passed unchanged to the controller)</b></p>

      <h3><a href="#id35" id="Parameters-mapping" title="Parameters-mapping">Parameters mapping</a></h3>
        <p>Through the previous description, we know that the parameters on the path and the query parameters after the question mark can be mapped to the parameter list of the handler function. The type of the target parameter needs to meet the following conditions:</p>
        <ul>
          <li>Must be one of a value type, a constant left value reference, or a non-const right value reference. It cannot be a non-const lvalue reference. It is recommended to use an rvalue reference so that the user can dispose of it at will.</li>
          <li>Basic types such as int, long, long long, unsigned long, unsigned long long, float, double, long double, etc can be used as parameter types.</li>
          <li>std::string</li>
          <li>Any type that can be assigned using the stringstream >> operator</li>
        </ul>
        <p><b>In addition, the drogon framework also provides a mapping mechanism from the HttpRequestPtr object to any type of parameter.</b>
          When the number of mapping parameters in your handler parameter list is more than the parameters on the path, the extra parameters will be converted by the <b>HttpRequestPtr</b> object. The user can define any type of conversion, the way to define this conversion is to specialize the <b>fromRequest</b> template (which is defined in the <b>HttpRequest.h</b> header file) in the drogon namespace, for example, say we need to make a RESTful interface to create a new user, we define the user's structure as follows:
        </p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        namespace myapp{
          struct User{
              std::string userName;
              std::string email;
              std::string address;
          };
          }
          namespace drogon
          {
          template &lt;&gt;
          inline myapp::User fromRequest(const HttpRequest &req)
          {
              auto json = req.getJsonObject();
              myapp::User user;
              if(json)
              {
                  user.userName = (*json)["name"].asString();
                  user.email = (*json)["email"].asString();
                  user.address = (*json)["address"].asString();
              }
              return user;
          }          
          }
        </pre></div>
        </div>
        <p>With the above definition and template specialization, we can define the path map and handler as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        class UserController:public drogon::HttpController&lt;UserController&gt;
          {
          public:
              METHOD_LIST_BEGIN
                  //use METHOD_ADD to add your custom processing function here;
                  ADD_METHOD_TO(UserController::newUser,"/users",Post);
              METHOD_LIST_END
              //your declaration of processing function maybe like this:
              void newUser(const HttpRequestPtr &req,
                           std::function&lt;void (const HttpResponsePtr &)&gt; &&callback,
                           myapp::User &&pNewUser) const;
          };
        </pre></div>
        </div>
        <p>It can be seen that the third parameter of <b>myapp::User</b> type has no corresponding placeholder on the mapping path, and the framework regards it as a parameter converted from the <b>req</b> object, and obtains this parameter through the user-specialized function template. This is very convenient for users.</p>
        <p>Further, some users do not need to access the HttpRequestPtr object except for their custom type data, so he can put the custom object in the position of the first parameter, and the framework can also correctly complete the mapping, such as the above example. It can also be written as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          class UserController:public drogon::HttpController&lt;UserController&gt;
            {
            public:
                METHOD_LIST_BEGIN
                    //use METHOD_ADD to add your custom processing function here;
                    ADD_METHOD_TO(UserController::newUser,"/users",Post);
                METHOD_LIST_END
                //your declaration of processing function maybe like this:
                void newUser(myapp::User &&pNewUser,
                             std::function&lt;void (const HttpResponsePtr &)&gt; &&callback) const;
            };
        </pre></div>
        </div>
      <h3><a href="#id36" id="multiple-path-mapping" title="multiple-path-mapping">multiple path mapping</a></h3>
        <p>Drogon supports the use of regular expressions in path mapping, which can be used outside the '{}' curly brackets, for example:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          ADD_METHOD_TO(UserController::handler1,"/users/.*",Post); /// Match any path prefixed with `/users/`
          ADD_METHOD_TO(UserController::handler2,"/{name}/[0-9]+",Post); ///Match any path composed with a name string and a number.
        </pre></div>
      <h3><a href="#id37" id="Regular-expression" title="Regular-expression">Regular expression</a></h3>
      <p>The above method has limited support for regular expressions. If users want to use regular expressions freely, drogon provides the <b>ADD_METHOD_VIA_REGEX</b> macro to achieve this, such as:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        ADD_METHOD_VIA_REGEX(UserController::handler1,"/users/(.*)",Post); /// Match any path prefixed with `/users/` and map the rest of the path to a parameter of the handler1.
        ADD_METHOD_VIA_REGEX(UserController::handler2,"/.*([0-9]*)",Post); /// Matche any path that ends in a number and map that number to a parameter of the handler2.
        ADD_METHOD_VIA_REGEX(UserController::handler3,"/(?!data).*",Post); /// Matches any path that does not start with '/data'
      </pre></div>
      </div>
      <p>As can be seen, parameter mapping can also be done using regular expressions, and all strings matched by subexpressions will be mapped to the parameters of the handler in order.</p>
      <br/>
      <p><b>It should be noted that when using regular expressions, you should pay attention to matching conflicts (multiple different handlers are matched). When conflicts happen in the same controller, drogon will only execute the first handler (the one registered in the framework first). When conflicts happen between different controllers, which handler to be executed is uncertain. Therefore, users need to avoid this kind of conflicts.</b></p>
    </div>
    </div>
    <div class="section" id="Controller-WebSocketController">
      <h2><a class="toc-backref" href="#id38">Controller WebSocketController</a><a class="headerlink" href="#Controller-WebSocketController" >¶</a></h2>
      <h3><a href="#id39" id="WebSocketController" title="id39">WebSocketController</a></h3>
      <p>As the name implies, <b>WebSocketController</b> is used to process websocket logic. Websocket is a persistent HTTP-based connection scheme. At the beginning of the websocket, there is an HTTP format request and response exchange. After the websocket connection is established, all messages are transmitted on the websocket. The message is wrapped in a fixed format. There is no limit to the message content and the order in which messages are transmitted.</p>
      <p>The source file of the <b>WebSocketController</b> can be generated by the <b>drogon_ctl</b> tool. The command format is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller -w &lt;[namespace::]class_name&gt;
      </pre></div>
      </div>
      <p>Suppose we want to implement a simple echo function through websocket, that is, the server simply sends back the message sent by the client. We can create the implementation class EchoWebsock of <b>WebSocketController</b> through <b>drogon_ctl</b>, as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create controller -w EchoWebsock
      </pre></div>
      </div>
      <p>The command will generate two files of <b>EchoWebsock.h</b> and <b>EchoWebsock.cc</b>,as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //EchoWebsock.h
        #pragma once
        #include <drogon/WebSocketController.h>
        using namespace drogon;
        class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
        {
        public:
            virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                          std::string &&)override;
            virtual void handleNewConnection(const HttpRequestPtr &,
                                            const WebSocketConnectionPtr&)override;
            virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
            WS_PATH_LIST_BEGIN
            //list path definitions here;
            WS_PATH_LIST_END
        };
      </pre></div>
      </div>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //EchoWebsock.cc
        #include "EchoWebsock.h"
        void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
        {
            //write your application logic here
        }
        void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
        {
            //write your application logic here
        }
        void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
        {
            //write your application logic here
        }
      </pre></div>
      </div>
      <p>After edited:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //EchoWebsock.h
        #pragma once
        #include <drogon/WebSocketController.h>
        using namespace drogon;
        class EchoWebsock:public drogon::WebSocketController<EchoWebsock>
        {
        public:
            virtual void handleNewMessage(const WebSocketConnectionPtr&,
                                          std::string &&)override;
            virtual void handleNewConnection(const HttpRequestPtr &,
                                            const WebSocketConnectionPtr&)override;
            virtual void handleConnectionClosed(const WebSocketConnectionPtr&)override;
            WS_PATH_LIST_BEGIN
            //list path definitions here;
            WS_PATH_ADD("/echo");
            WS_PATH_LIST_END
        };
      </pre></div>
      </div>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //EchoWebsock.cc
        #include "EchoWebsock.h"
        void EchoWebsock::handleNewMessage(const WebSocketConnectionPtr &wsConnPtr,std::string &&message)
        {
            //write your application logic here
            wsConnPtr->send(message);
        }
        void EchoWebsock::handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConnPtr)
        {
            //write your application logic here
        }
        void EchoWebsock::handleConnectionClosed(const WebSocketConnectionPtr &wsConnPtr)
        {
            //write your application logic here
        }
      </pre></div>
      </div>
      <p>First, in this example, the controller is registered to the <b>/echo</b> path via the <b>WS_PATH_ADD</b> macro. The usage of the <b>WS_PATH_ADD</b> macro is similar to the macros of other controllers introduced earlier. One can also register the path with several Filters. Since websocket is handled separately in the framework, it can be repeated with the paths of the first two controllers（<b>HttpSimpleController</b> and <b>HttpApiController</b>） without affecting each other.</p>
      <p>Secondly, in the implementation of the three virtual functions in this example, only the handleNewMessage has the substance, but simply sends the received message back to the client through the send interface.Compile this controller into the framework, you can see the effect, please test it yourself.</p>
      <p><b>Note: Like the usual HTTP protocol, http websocket can be sniffed. If security is required, encryption should be provided by HTTPS. Of course, it is also possible for users to complete encryption and decryption on the server and client side, but HTTPS is more convenient. The underlying layer is handled by drogon, and users only need to care about business logic.</b></p>
      <p>The user-defined websocket controller class inherits from the <b>drogon::WebSocketController</b> class template. The template parameter is a subclass type. The user needs to implement the following three virtual functions to process the establishment, shutdown, and messages of the websocket:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        virtual void handleNewConnection(const HttpRequestPtr &req,const WebSocketConnectionPtr &wsConn);
        virtual void handleNewMessage(const WebSocketConnectionPtr &wsConn,std::string &&message);
        virtual void handleConnectionClosed(const WebSocketConnectionPtr &wsConn);
      </pre></div>
      </div>
      <p>Easy to Known:</p>
      <ul>
        <li><b>handleNewConnection</b> is called after the websocket is established. req is the setup request sent by the client. At this time, the framework has returned the response. What users can do is to get some additional information through req, such as token. wsConn is a smart pointer to this websocket object, and the commonly used interface will be discussed later.</li>
        <li><b>handleNewMessage</b> is called after the websocket receives the new message. The message is stored in the message variable. Note that the message is the message payload. The framework has finished the decapsulation and decoding of the message. The user can directly process the message itself.</li>
        <li><b>handleConnectionClosed</b> is called after the websocket connection is closed, and the user can do some finishing work.</li>
      </ul>
      <h3><a href="#id40" id="WebSocketConnection" title="id40">WebSocketConnection</a></h3>
      <p>The common interfaces of the WebSocketConnection object are as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        //Send a websocket message, the encoding and encapsulation 
        //of the message are the responsibility of the framework
        void send(const char *msg,uint64_t len);
        void send(const std::string &msg);

        //Local and remote addresses of the websocket
        const trantor::InetAddress &localAddr() const;
        const trantor::InetAddress &peerAddr() const;

        //The connection state of the weosocket
        bool connected() const;
        bool disconnected() const;

        //close websocket
        void shutdown();//close write
        void forceClose();//close

        //set up and get the context of the websocket, and store some business data from users.
        //the any type means that you can store any type of object.
        void setContext(const any &context);
        const any &getContext() const;
        any *getMutableContext();
      </pre></div>
      </div>

    </div>
    <div class="section" id="Filter">
      <h2><a class="toc-backref" href="#id41">Filter</a><a class="headerlink" href="#Filter" >¶</a></h2>
      <p>In HttpController's <a href="#Controller-HttpController">example</a>, the getInfo method should check whether the user is logged in before returning the user's information. We can write this logic in the getInfo method, but obviously, checking the user's login membership is general logic which will be used by many interfaces, it should be extracted separately and configured before calling handler, which is what filters do. After the drogon framework completes the URL path matching, it first calls the filters registered on the path in turn, and only when all the filters allow "pass", the corresponding handler will be called;</p>
      <h3><a href="#id42" id="Built_in_Filter" title="built in filter">Built-in Filter</a></h3>
      <p>Drogon contains the following common filters:</p>
        <ul>
          <li><b>drogon::IntranetIpFilter</b>: allow HTTP requests from intranet IP only, or return the 404 page.</li>
          <li><b>drogon::LocalHostFilter</b>: allow HTTP requests from 127.0.0.1 or ::1 only, or return the 404 page.</li>
        </ul>
      <h3><a href="#id43" id="Custom_Filter" title="custom filter">Custom Filter</a></h3>
      <p>Of course, users can customize the filter, you need to inherit the HttpFilter class template, the template type is the subclass type, for example, if you want to create a LoginFilter, you could define it as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        class LoginFilter:public drogon::HttpFilter<LoginFilter>
          {
          public:
              virtual void doFilter(const HttpRequestPtr &req,
                                    FilterCallback &&fcb,
                                    FilterChainCallback &&fccb) override ;
          };
      </pre></div>
      </div>
      <p>You could create filter by the drogon_ctl command, see drogon_ctl.</p>
      <p>You need to override the doFilter virtual function of the parent class to implement the filter logic;</p>        
      <p>This virtual function has three parameters, which are:</p>
      <ul>
        <li>req: http request;</li>
        <li>fcb: filter callback function, the function type is void (HttpResponsePtr), when the filter determines that the request is not valid, the specific response is returned to the browser through this callback;</li>
        <li>fccb: filter chain callback function, the function type is void (), when the filter determines that the request is legal, tells drogon to call the next filter or the final handler through this callback;</li>
      </ul>
      <p>The specific implementation can refer to the implementation of the drogon built-in filter.</p>
      <h3><a href="#id44" id="Filter_Registration" title="Filter_Registration">Built-in Filter</a></h3>
      <p>The registration of filters is always accompanied by the registration of controllers.the macros (PATH_ADD, METHOD_ADD, etc.) mentioned earlier can add the name of one or more filters at the end; for example, we change the registration line of the previous <b>getInfo</b> method to the following form:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get,"LoginFilter");
      </pre></div>
      </div>
      <p>After the path is successfully matched, the <b>getInfo</b> method will be called only when the following conditions were met:</p>
      <ul>
        <li>The request must be an HTTP Get request;</li>
        <li>The requesting party must have logged in;</li>
      </ul>
      <p>As you can see, the configuration and registration of filters are very simple. The controller source file that registers filters does not need to include the filter's header file. The filter and controller are fully decoupled.</p>
      <p><b>Note: If the filter is defined in the namespace, you must write the namespace completely when you register the filter.</b></p>

    </div>
    <div class="section" id="View">
      <h2><a class="toc-backref" href="#id45">View</a><a class="headerlink" href="#View" >¶</a></h2>
      <h3><a href="#id46" id="Views_Introduction" title="built in filter">Views Introduction</a></h3>
      <p>Although the front-end rendering technology is popular, the back-end application service only needs to return the corresponding data to the front-end. However, a good web framework should provide back-end rendering technology, so that the server program can dynamically generate HTML pages. Views can help users generate these pages. As the name implies, it is only responsible for doing the work related to the presentation, and the complex business logic should be handed over to the controller.</p>
      <p>The earliest web applications embed HTML into the program code to achieve the purpose of dynamically generating HTML pages, but this is inefficient, not intuitive, and so on. So there are languages such as JSP, which are the opposite. , embed the program code into the HTML page. The drogon is of course the latter solution. However, it is obvious that since C++ is compiled and executed, we need to convert the page embedded in C++ code into a C++ source program to compile into the application. Therefore, drogon defines its own specialized CSP (C++ Server Pages) description language, using the command line tool drogon_ctl to convert CSP files into C++ source files for compilation.</p>
      <h3><a href="#id47" id="Drogon_s_CSP" title="built in filter">Drogon's CSP</a></h3>
      <p>Drogon's CSP solution is very simple, we use special markup symbols to embed C++ code into the HTML page. among them:</p>
      <ul>
        <li>The content between the tags &lt;%inc and %&gt; is considered to be the part of the header file that needs to be referenced. Only the #include statement can be written here, such as &lt;%inc#include "xx.h" %&gt;, but many common header files are automatically included by drogon. The user basically does not use this tag;</li>
        <li>Everything between the tags &lt;%c++ and %&gt; is treated as C++ code, such as &lt;c++ std:string name="drogon"; %&gt;;</li>
        <li>C++ code is generally transferred to the target source file intact, except for the following two special tags:</li>
              <ul><li>@@ represents the data variable passed by the controller, from which you can get the content you want to display;</li>
              <li>$$ represents a stream object representing the content of the page, and the content to be displayed can be displayed on the page by the &lt;&lt; operator;</li></ul>
        <li>The content sandwiched between the tags [[ and ]] is considered to be the variable name. The view will use the name as the key to find the corresponding variable from the data passed from the controller and output it to the page. Spaces before and after the variable name will be omitted. Paired [[ and ]] should be on the same line. And for performance reasons, only three string data types are supported(const char *, std::string and const std::string), other data types should be output in the above-mentioned way(by $$);</li>
        <li>The content sandwiched between the tags {% and %} is considered to be the name of a variable or an expression of the C++ program (not the keyword of the data passed by the controller), and the view will output the contents of the variable or the value of the expression to the page. It's easy to know that {%val.xx%} is equivalent to &lt;%c++$$&lt;&lt;val.xx;%&gt;, but the former is simpler and more intuitive. Similarly, do not write two tags in separate lines;</li>
        <li>The content sandwiched between the tags &lt;%view and %&gt; is considered to be the name of the sub-view. The framework will find the corresponding sub-view and fill its contents to the location of the tag; the spaces before and after the view name will be ignored. Do not write &lt;%view and %&gt; in separate lines. Can use multiple levels of nesting, but not loop nesting;</li>
        <li>The content between the tags &lt;%layout and %&gt; is considered as the name of the layout. The framework will find the corresponding layout and fill the content of this view to a position in the layout (in the layout the placeholder [[]] marks this position); spaces before and after the layout name will be ignored, and &lt;%layout and %&gt; should not be written in separate lines. You can use multiple levels of nesting, but not loop nesting. One template file can only inherit from one base layout, multiple inheritance from different layouts is not supported.</li>
      </ul>
      <h3><a href="#id48" id="The_use_of_views" title="built in filter">The use of views</a></h3>
        <p>The http response of the drogon application is generated by the controller handler, so the response rendered by the view is also generated by the handler, generated by calling the following interface:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          static HttpResponsePtr newHttpViewResponse(const std::string &viewName,
                                           const HttpViewData &data);
        </pre></div>
        </div>
        <p>This interface is a static method of the HttpResponse class, which has two parameters:</p>
        <ul>
          <li><b>viewName</b>: the name of the view, the name of the incoming csp file (<b>the extension can be omitted</b>);</li>
          <li><b>data</b>: The controller's handler passes the data to the view. The type is <b>HttpViewData</b>. This is a special map. You can save and retrieve any type of object. For details, please refer to [HttpViewData API] (API-HttpViewData) Description</li>
        </ul>
        <p>As you can see, the controller does not need to reference the header file of the view. The controller and the view are well decoupled; their only connection is the data variable.</p>
        <h3><a href="#id49" id="A_simple_example" title="built in filter">A simple example</a></h3>
        <p>Now let's make a view that displays the parameters of the HTTP request sent by the browser in the returned html page.</p>
        <p>This time we directly define the handler with the HttpAppFramework interface. In the main file, add the following code before calling the run() method:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          drogon::HttpAppFramework::instance()
          .registerHttpMethod("/list_para",
                                [=](const HttpRequestPtr &req,
                                    std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)
                                {
                                      auto para=req->getParameters();
                                      HttpViewData data;
                                      data.insert("title","ListParameters");
                                      data.insert("parameters",para);
                                      auto resp=HttpResponse::newHttpViewResponse("ListParameters.csp",data);
                                      callback(resp);
                                });
        </pre></div>
        </div>
        <p>The above code registers a lambda expression handler on the <b>/list_para path</b>, passing the requested parameters to the view display. Then, Go to the views folder and create a view file ListParameters.csp with the following contents:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          &lt;!DOCTYPE html&gt;
          &lt;html&gt;
          &lt;%c++
            auto para=@@.get&lt;std::unordered_map&lt;std::string,std::string&gt;&gt;("parameters");
          %&gt;
          &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;title&gt;[[ title ]]&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;%c++ if(para.size()&gt;0){%&gt;
            &lt;H1&gt;Parameters&lt;/H1&gt;
            &lt;table border="1"&gt;
            &lt;tr&gt;
              &lt;th&gt;name&lt;/th&gt;
              &lt;th&gt;value&lt;/th&gt;
            &lt;/tr&gt;
            &lt;%c++ for(auto iter:para){%&gt;
            &lt;tr&gt;
              &lt;td&gt;{%iter.first%}&lt;/td&gt;
              &lt;td&gt;&lt;%c++ $$&lt;&lt;iter.second;%&gt;&lt;/td&gt;
            &lt;/tr&gt;
            &lt;%c++}%&gt;
            &lt;/table&gt;
            &lt;%c++ }else{%&gt;
            &lt;H1&gt;no parameter&lt;/H1&gt;
            &lt;%c++}%&gt;
          &lt;/body&gt;
          &lt;/html&gt;

      </pre></div>
      </div>
      <p>We can use <b>drogon_ctl</b> command tool to convert ListParameters.csp into C++ source files as bellow:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create view ListParameters.csp
      </pre></div>
      </div>
      <p>After the operation is finished, two source files, ListParameters.h and ListParameters.cc, will appear in the current directory, which can be used to compile into the web application;</p>
      <p>Recompile the entire project with cmake, run the target program webapp, you can test the effect in the browser, enter <b>http://localhost/list_para?p1=a&p2=b&p3=c</b> in the address bar, you can see the following page :</p>
      <b><a href="#">VIEW_PAGES</a></b>
      <p>The html page rendered by the backend is simply added.</p>
      <h3><a href="#id50" id="Automated_processing_of_csp_files" title="built in filter">Automated processing of csp files</a></h3>
        <p><b>Note: If your project is create by the <strong>drogon_ctl</strong> command, the work described in this section is done automatically by <strong>drogon_ctl</strong>.</b></p>
        <p>Obviously, it is too inconvenient to manually run the drogon_ctl command every time you modify the csp file. We can put the processing of drogon_ctl into the CMakeLists.txt file. Still use the previous example as an example. Let's assume that we put all the csp files In the views folder, CMakeLists.txt can be added as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            FILE(GLOB SCP_LIST ${CMAKE_CURRENT_SOURCE_DIR}/views/*.csp)
            foreach(cspFile ${SCP_LIST})
                message(STATUS "cspFile:" ${cspFile})
                EXEC_PROGRAM(basename ARGS "-s .csp ${cspFile}" OUTPUT_VARIABLE classname)
                message(STATUS "view classname:" ${classname})
                add_custom_command(OUTPUT ${classname}.h ${classname}.cc
                    COMMAND drogon_ctl
                    ARGS create view ${cspFile}
                    DEPENDS ${cspFile}
                    VERBATIM )
              set(VIEWSRC ${VIEWSRC} ${classname}.cc)
            endforeach()
        </pre></div>
        </div>
        <p>Then add a new source file collection ${VIEWSRC} to the add_executable statement as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          Add_executable(webapp ${SRC_DIR} ${VIEWSRC})
        </pre></div>
        </div>
      <h3><a href="#id51" id="Dynamic_compilation_and_loading_of_views" title="built in filter">Dynamic compilation and loading of views</a></h3>      
      <p>Drogon provides a way to dynamically compile and load csp files during the application runtime, using the following interface:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void enableDynamicViewsLoading(const std::vector<std::string> &libPaths);
      </pre></div>
      </div>
      <p>The interface is a member method of <b>HttpAppFramework</b>, and the parameter is an array of strings representing a list of directories in which the view csp file is located. After calling this interface, drogon will automatically search for csp files in these directories. After discovering new or modified csp files, the source files will be automatically generated, compiled into dynamic library files and loaded into the application. The application process does not need to be restarted. Users can experiment on their own and observe the page changes caused by the modification of csp file.</p>
      <p>Obviously, this function depends on the development environment. If both drogon and webapp are compiled on this server, there should be no problem in dynamically loading the csp page.</p>
      <p><b>Note: Dynamic views should not be compiled into the application statically. This means that if the view is statically compiled, it cannot be updated via dynamic view loading. You can create a directory outside the compilation folder and move views into it during development.</b></p>
      <p><b>Note: This feature is best used to adjust the HTML page during the development phase. In the production environment, it is recommended to compile the csp file directly into the target file. This is mainly for security and stability.</b></p>        
      <p><b>Note: If a <strong>symbol not found</strong> error occurs while loading a dynamic view, please use the <strong>cmake .. -DCMAKE_ENABLE_EXPORTS=on</strong> to configure your project, or uncomment the last line <strong>(set_property(TARGET ${PROJECT_NAME} PROPERTY ENABLE_EXPORTS ON))</strong> in your project's CMakeLists.txt, and then rebuild the project</b></p>
    </div>
    <div class="section" id="Session">
      <h2><a class="toc-backref" href="#id52">Session</a><a class="headerlink" href="#id52" >¶</a></h2>
      <p><b>Session</b> is an important concept of the web application. It is used to save the state of the client on the server. Generally, it cooperates with the browser's <b>cookie</b>, and drogon provides support for the session. Drogon <b>close</b> the session selection by default, you can also close or open it through the following interface:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void disableSession();
        void enableSession(const size_t timeout=0);  
      </pre></div>
      </div>
      <p>The above methods are all called through the <b>HttpAppFramework</b> singleton. The timeout parameter represents the time when the session is invalid. The unit is second. The default value is 1200. That is, if the user does not access the web application for more than 20 minutes, the corresponding session will be invalid. Setting timeout to 0 means that drogon will retain the user's session for the entire lifetime;</p>
      <p>Make sure your client supports cookies before opening the session feature. Otherwise, drogon will create a new session for each request without <b>SessionID</b> cookie, which will waste memory and computing resources.</p>
      <h3><a href="#id53" id="Session_object" title="Session object">Session object</a></h3>
      <p>The session object type of drogon is <b>drogon::Session</b>, which is very similar to <b>HttpViewData</b>. It can access any type of object through keywords; support concurrent reading and writing; please refer to the description of Session class for specific usage;</p>
      <p>The drogon framework will pass the session object to the <b>HttpRequest</b> object and pass it to the user. The user can get the Session object through the following interface of the <b>HttpRequest</b> class.</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        SessionPtr session() const;
        </pre></div>
        </div>
      <p>The interface returns a smart pointer of the <b>Session</b> object, through which various objects can be accessed;</p>
      <h3><a href="#id54" id="Examples_of_sessions" title="Examples_of_sessions">Examples of sessions</a></h3>
      <p>We add a feature that requires session support. For example, we want to limit the user's access frequency. After a visit, if it is accessed again within 10 seconds, it will return an error, otherwise it will return ok. We need to record the last access time in the session, and then compare it with the time of this visit, you can achieve this function.</p>
      <p>We create a Filter to implement this function, assuming the class name is TimeFilter, the implementation is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #include "TimeFilter.h"
        #include &lt;trantor/utils/Date.h&gt;
        #include &lt;trantor/utils/Logger.h&gt;
        #define VDate "visitDate"
        void TimeFilter::doFilter(const HttpRequestPtr &req,
                                  FilterCallback &&cb,
                                  FilterChainCallback &&ccb)
        {
            trantor::Date now=trantor::Date::date();
            LOG_TRACE&lt;&lt;"";
            if(req-&gt;session()-&gt;find(VDate))
            {
                auto lastDate=req-&gt;session()-&gt;get&lt;trantor::Date&gt;(VDate);
                LOG_TRACE&lt;&lt;"last:"&lt;&lt;lastDate.toFormattedString(false);
                req-&gt;session()-&gt;insert(VDate,now);
                LOG_TRACE&lt;&lt;"update visitDate";
                if(now&gt;lastDate.after(10))
                {
                    //10 sec later can visit again;
                    ccb();
                    return;
                }
                else
                {
                    Json::Value json;
                    json["result"]="error";
                    json["message"]="Access interval should be at least 10 seconds";
                    auto res=HttpResponse::newHttpJsonResponse(json);
                    cb(res);
                    return;
                }
            }
            LOG_TRACE&lt;&lt;"first access,insert visitDate";
            req-&gt;session()-&gt;insert(VDate,now);
            ccb();
        }
      </pre></div>
      </div>
      <p>We then register a lambda expression to the <b>/slow</b> path and attach the TimeFilter with the following code:</p>        
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon::HttpAppFramework::instance()
            .registerHttpMethod("/slow",
                                   [=](const HttpRequestPtr &req,
                                       std::function&lt;void (const HttpResponsePtr &)&gt; &&callback)
                                   {
                                       Json::Value json;
                                       json["result"]="ok";
                                       auto resp=HttpResponse::newHttpJsonResponse(json);
                                       callback(resp);
                                   },
                                   {Get,"TimeFilter"});
      </pre></div>
      </div>
      <p>Call the framework interface to open the session:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon::HttpAppFramework::instance().enableSession(1200);
        </pre></div>
        </div>
      <p>Recompile the entire project with cmake, run the target program webapp, and you can see the effect through the browser.</p>
    </div>
    <div class="section" id="Database_General">
      <h2><a class="toc-backref" href="#id55">Database General</a><a class="headerlink" href="#id55" >¶</a></h2>
      <h3><a href="#id56" id="General" title="General">General</a></h3>
      <p><b>Drogon</b> has built-in database read/write engine. The operation of database connection is based on non-blocking I/O technology. Therefore, the application works in an efficient non-blocking asynchronous mode from the bottom to the upper layer, which ensures Drogon's high concurrency performance. Currently, Drogon supports PostgreSQL and MySQL databases. If you want to use a database, the development environment of the corresponding database must be installed first. Drogon will automatically detect the header files and library files of these libraries and compile the corresponding parts. For the preparation of the database development environment, see <a href="#id17">Development Environment</a>.</p>
      <p><b>Drogon</b> supports the sqlite3 database in order to support lightweight applications. The asynchronous interface is implemented through the thread pool, which is the same as the interfaces of the aforementioned databases.</p>
      <h3><a href="#id57" id="DbClient" title="DbClient">DbClient</a></h3>
      <p>The basic class of Drogon's database is <b>DbClient</b> (this is an abstract class, the specific type depends on the interface that constructs it). Unlike a generic database interface, a <b>DbClient</b> object does not represent a single database connection. It can contain one or more database connections, so you can think of it as a <b>connection pool object</b>.</p>
      <p><b>DbClient</b> provides both synchronous and asynchronous interfaces. The asynchronous interface also supports both blocking and non-blocking modes. Of course, for the cooperation with the Drogon asynchronous framework, it is recommended that you use the the asynchronous interface with non-blocking mode.</p>
      <p>Usually, when an asynchronous interface is called, <b>DbClient</b> will randomly select one of the idle connections it manages to perform related query operations. When the result returns, <b>DbClient</b> will process the data and return it to the caller through the callback function object; Without an idle connection, the execution content will be cached. Once a connection has executed its own sql request, the pending command will be fetched from the cache to execute.</p>
      <p>For details on DbClient, see <a href="#">DbClient</a>.</p>
      <h3><a href="#id58" id="Transaction" title="Transaction">Transaction</a></h3>
      <p>The transaction object can be generated by <b>DbClient</b> to support transaction operations. In addition to the extra <b>rollback()</b> interface, the transaction object is basically the same as <b>DbClient</b>. The transaction class is <b>Transaction</b>. For details of the <a href="#">Transaction</a> class, see <a href="#">Transaction</a>.</p>
      <h3><a href="#id59" id="ORM" title="ORM">ORM</a></h3>
      <p>Drogon also provides support for <b>ORM</b>. Users can use the drogon_ctl command to read the tables in the database and generate the corresponding model source code. Then, execute the database operations of these models through the <b>Mapper&lt;MODEL&gt;</b> class template. Mapper provides simple and convenient interfaces for standard database operations, allowing users to make the additions, deletions, and changes to the table without writing sql statements. For ORM, please refer to <a href="#">ORM</a></p>      
    </div>
    <div class="section" id="Database_DbClient">
      <h2><a class="toc-backref" href="#id60">Database DbClient</a><a class="headerlink" href="#id60" >¶</a></h2>
      <h3><a href="#id61" id="DbClient_Object_Construction" title="DbClient_Object_Construction">DbClient Object Construction</a></h3>
      <p>There are two ways to construct a DbClient object. One is through the static method of the DbClient class. You can see the definition in the DbClient.h header file, as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        #if USE_POSTGRESQL
        static std::shared_ptr&lt;DbClient&gt; newPgClient(const std::string &connInfo, const size_t connNum);
        #endif
        #if USE_MYSQL
            static std::shared_ptr&lt;DbClient&gt; newMysqlClient(const std::string &connInfo, const size_t connNum);
        #endif
      </pre></div>
      </div>
      <p>Use the above interface to get the smart pointer of the DbClient implementation object. The parameter connInfo is a connection string. Set a series of connection parameters in the form of key=value. For details, please refer to the comments in the header file. The parameter connNum is the number of database connections of DbClient, which has a key impact on concurrency. Please set it according to the actual situation.</p>            
      <p>The object obtained by the above method, the user has to find a way to persist it, such as putting it in some global container. <b>Creating a temporary object and then releasing it after use is a very unrecommended solution</b> for the following reasons:</p>
      <ul>
        <li>This will waste time creating connections and disconnections, increasing system latency;</li>
        <li>The interface is also a non-blocking interface. That is to say, when the user gets the DbClient object, the connection managed by the it has not been established yet. The framework does not (intentionally) provide a callback interface for successful connection establishment. Do you still have to sleep before starting the query?? This is contrary to the original intention of the asynchronous framework.</li>
      </ul>
      <p>Therefore, DbClient objects should be built at the beginning of the program and held and used throughout the life time. Obviously, this work can be done entirely by the framework. So the drogon framework provides the second build method, which is built by configuration file or the <b>createDbClient()</b> method. For the configuration method of the configuration file, see <a href="#">db_clients</a>.</p>
      <p>When needed, the DbClient smart pointer is obtained through the interface of the framework. The interface is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        orm::DbClientPtr getDbClient(const std::string &name = "default");
      </pre></div>
      </div>
      <p>The parameter name is the value of the name configuration option in the configuration file to distinguish multiple different DbClient objects of the same application. The connections managed by DbClient are always reconnected, so users don't need to care about the connection status. They are almost always connected. <b>Note</b>: This method cannot be called before running app.run(), otherwise the user will get an empty shared_ptr.</p>
      <h3><a href="#id62" id="Execution_Interface" title="Execution_Interface">Execution Interface</a></h3>
      <p>DbClient provides several different interfaces to users, as listed below:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        /// Asynchronous mothod
        template &lt;
                typename FUNCTION1,
                typename FUNCTION2,
                typename... Arguments&gt;
        void execSqlAsync(const std::string &sql,
                          FUNCTION1 &&rCallback,
                          FUNCTION2 &&exceptCallback,
                          Arguments &&... args) noexcept;
                          
        /// Asynchronous mothod by 'future'
        template <typename... Arguments>
        std::future&lt;const Result&gt; execSqlAsyncFuture(const std::string &sql,
                                                     Arguments &&... args) noexcept;
                                                     
        /// Synchronous method
        template &lt;typename... Arguments&gt;
        const Result execSqlSync(const std::string &sql,
                                 Arguments &&... args) noexcept(false);
                                 
        /// Streaming-type method
        internal::SqlBinder operator&lt;&lt;(const std::string &sql);
        </pre></div>
        </div>
        <p>Since the number and type of binding parameters cannot be predetermined, these methods are function templates.</p>
        <p>The properties of these methods are shown in the following table:</p>
        <table border="1" class="docutils">
          <colgroup>
            <col width="25%" />
            <col width="25%" />
            <col width="25%" />
            <col width="25%" />
            </colgroup>
          <thead valign="bottom">
          <tr class="row-odd">
          <th class="head">Methods</th>
          <th class="head">Synchronous/Asynchronous</th>
          <th class="head">Blocking/Non-blocking</th>
          <th class="head">Exception</th>
          </tr>
          </thead>
          <tbody valign="top">
          <tr class="row-even">
          <td >void execSqlAsync</td>
          <td >Asynchronous</td>
          <td >Non-blocking</td>
          <td >Will not throw an exception</td>
          </tr>
          <tr class="row-odd">
          <td >std::future execSqlAsyncFuture</td>
          <td >Asynchronous</td>
          <td >Block when calling the get method of the future</td>
          <td >May throw an exception when calling the get method of the future</td>
          </tr>
          <tr class="row-even">
          <td >const Result execSqlSync</td>
          <td >Synchronous</td>
          <td >Blocking</td>
          <td >May throw an exception</td>
          </tr>
          <tr>
          <td >internal::SqlBinder operator&lt;&lt;</td>
          <td >Asynchronous</td>
          <td >Default non-blocking</td>
          <td >Will not throw an exception</td>
          </tr>
          </tbody>
          </table>
          <p>You may be confused about the combination of asynchronous and blocking. In general, the synchronization method involving network IO is blocking, and the asynchronous method is non-blocking. However, the asynchronous method can also work in blocking mode, meaning that this method will Block until the callback function has finished executing. When the asynchronous method of DbClient works in blocking mode, the callback function will be executed in the thread of the caller, and then the method will return.</p>
          <p>If your application involves high-concurrency scenarios, please use asynchronous non-blocking methods. If it is in a low concurrent scene (such as a network device management page), you can choose synchronization methods for convenience and intuitiveness.</p>

      <h4><a href="#id63" id="Execution_Interface_execSqlAsync" title="Execution_Interface_execSqlAsync">execSqlAsync</a></h4>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          template &lt;typename FUNCTION1,
          typename FUNCTION2,
          typename... Arguments&gt;
          void execSqlAsync(const std::string &sql,
                  FUNCTION1 &&rCallback,
                  FUNCTION2 &&exceptCallback,
                  Arguments &&... args) noexcept;
        </pre></div>
        </div>
        <p>This is the most commonly used asynchronous interface, working in non-blocking mode;</p>
        <p>The parameter <b>sql</b> is a string of sql statements. If there are placeholders for binding parameters, use the placeholder rules of the corresponding database. For example, PostgreSQL placeholders are $1, $2 ..., while MySQL placeholders are <b>?</b>.</p>
        <p>The indefinite parameter <b>args</b> represents the bound parameter, which can be zero or more. The number of parameters is the same as the number of placeholders in the sql statement. The types can be the following:</p>
          <ul>            
            <li>Integer type: can be an integer of various word lengths, and should match the database field type;</li>
            <li>Floating point type: can be <b>float</b> or <b>double</b>, should match the database field type;</li>
            <li>String type: can be <b>std::string</b> or <b>const char[]</b>, corresponding to the string type of the database or other types that can be represented by strings;</li>
            <li>Date type: <b>trantor::Date</b> type, corresponding to the database date, datetime, timestamp types.</li>
            <li>Binary type: <b>std::vector&lt;char&gt;</b> type, corresponding to PostgreSQL's bytea type or Mysql's blob type;</li>
          </ul>
        <p>These parameters can be left or right, can be variables or literal constants, and users are free to use them.</p>
        <p>The parameters rCallback and exceptCallback represent the result callback function and the exception callback function, respectively, which have a fixed definition, as follows:</p>
        <ul>
          <li>The result callback function: the call type is void (const Result &), various callable objects conforming to this call type, std::function, lambda, etc. can be passed as parameters;</li>
          <li>Exception callback function: the call type is void (const DrogonDbException &), which can pass various callable objects that are consistent with this call type;</li>
        </ul>
        <p>After the execution of sql is successful, the execution result is wrapped by the Result class and passed to the user through the result callback function; if there is any exception in the sql execution, the exception callback function is executed, and the user can obtain the exception information from the DrogonDbException object.</p>
        <p>Let us give an example:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          auto clientPtr = drogon::app().getDbClient();
          clientPtr-&gt;execSqlAsync("select * from users where org_name=$1",
                                      [](const Result &r) {
                                          std::cout &lt;&lt; r.size() &lt;&lt; " rows selected!" &lt;&lt; std::endl;
                                          int i = 0;
                                          for (auto row : r)
                                          {
                                              std::cout &lt;&lt; i++ &lt;&lt; ": user name is " &lt;&lt; row["user_name"].as<std::string>() &lt;&lt; std::endl;
                                          }
                                      },
                                      [](const DrogonDbException &e) {
                                          std::cerr &lt;&lt; "error:" &lt;&lt; e.base().what() &lt;&lt; std::endl;
                                      },
                                      "default");
        </pre></div>
        </div>
        <p>From the example we can see that the Result object is a std standard compatible container, support iterators, you can get the object of each row through the range loop. the various interfaces of Result, Row and Field objects, please refer to the source code.</p>
        <p>The DrogonDbException class is the base class for all database exceptions. Please refer to the comments in the source code.</p>
      <h4><a href="#id64" id="Execution_Interface_execSqlAsyncFuture" title="Execution_Interface_execSqlAsyncFuture">execSqlAsyncFuture</a></h4>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          template &lt;typename... Arguments&gt;
          std::future&lt;const Result&gt; execSqlAsyncFuture(const std::string &sql,
                                             Arguments &&... args) noexcept;
          </pre></div>
          </div>
          <p>The asynchronous future interface omits the two callback parameters of the previous interface. Calling this interface will immediately return a future object. The user must call the get() method of the future object to get the returned result. The exception is obtained through the try/catch mechanism. if the get() method isn't in the <b>try/catch</b>, and there is no <b>try/catch</b> in the entire call stack, the program will exit when the sql execution exception occurs.</p>
          <p>For example:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
              auto f = clientPtr->execSqlAsyncFuture("select * from users where org_name=$1",
                                        "default");
              try
              {
                  auto result = f.get(); // Block until we get the result or catch the exception;
                  std::cout &lt;&lt; r.size() &lt;&lt; " rows selected!" &lt;&lt; std::endl;
                  int i = 0;
                  for (auto row : r)
                  {
                      std::cout &lt;&lt; i++ &lt;&lt; ": user name is " &lt;&lt; row["user_name"].as&lt;std::string&gt;() &lt;&lt; std::endl;
                  }
              }
              catch (const DrogonDbException &e)
              {
                  std::cerr &lt;&lt; "error:" &lt;&lt; e.base().what() &lt;&lt; std::endl;
              }
            </pre></div>
          </div>          
      <h4><a href="#id65" id="Execution_Interface_execSqlSync" title="Execution_Interface_execSqlSync">execSqlSync</a></h4>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        template <typename... Arguments>
          const Result execSqlSync(const std::string &sql,
                                   Arguments &&... args) noexcept(false);
      </pre></div>
      </div>
      <p>Synchronous interface is the most simple and intuitive, the input parameters are sql string and bound parameters, return a Result object, the call will block the current thread, and throw an exception when an error occurs, so also pay attention to catch exception with <b>try/catch</b>.</p>
      <p>E.g:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        try
        {
            auto result = clientPtr->execSqlSync("update users set user_name=$1 where user_id=$2",
                                                "test", 
                                                1); // Block until we get the result or catch the exception;
            std::cout &lt;&lt; r.affectedRows() &lt;&lt; " rows updated!" &lt;&lt; std::endl;
        }
        catch (const DrogonDbException &e)
        {
            std::cerr &lt;&lt; "error:" &lt;&lt; e.base().what() &lt;&lt; std::endl;
        }
        </pre></div>
        </div>

      <h4><a href="#id66" id="Execution_Interface_operator" title="Execution_Interface_operator"> operator&lt;&lt</a></h4>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        internal::SqlBinder operator<<(const std::string &sql);
      </pre></div></div>
      <p>The streaming interface is special. It inputs the sql statement and parameters in turn through the &lt;&lt; operator, and specifies the result callback function and the exception callback function through the &gt;&gt; operator. For example, the previous example of selecting, using the streaming interface is Look like this:</p>  
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        *clientPtr  &lt;&lt; "select * from users where org_name=$1"
        &lt;&lt; "default" 
        &gt;&gt; [](const Result &r) 
            {
                std::cout &lt;&lt; r.size() &lt;&lt; " rows selected!" &lt;&lt; std::endl;
                int i = 0;
                for (auto row : r)
                {
                    std::cout &lt;&lt; i++ &lt;&lt; ": user name is " &lt;&lt; row["user_name"].as<std::string>() &lt;&lt; std::endl;
                }
            }
        &gt;&gt; [](const DrogonDbException &e) 
            {
                std::cerr &lt;&lt; "error:" &lt;&lt; e.base().what() &lt;&lt; std::endl;
            };
        </pre></div></div>
      <p>This usage is completely equivalent to the first asynchronous non-blocking interface, and which interface is used depends on the user's usage habits. If you want it to work in blocking mode, you can use &lt;&lt; to enter a <b>Mode::Blocking</b> parameter, which is not described here.</p>        
      <p>In addition, the streaming interface has a special usage. Using a special result callback, the framework can pass the result to the user row by row. The call type of this callback is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void (bool,Arguments...);
      </pre></div>
      </div>
      <p>When the first bool parameter is true, it means that the result is a empty row, that is, all the results have been returned, this is the last callback; Behind is a series of parameters, corresponding to the value of each column of a row of records, the framework will do type conversion, of course, the user should also pay attention to the type of matching. These types can be const-type lvalue references, or rvalue references, and of course value types.</p>
      <p>Let's rewrite the previous example with this callback:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        int i = 0;
        *clientPtr  &lt;&lt; "select user_name, user_id from users where org_name=$1"
                    &lt;&lt; "default" 
                    &gt;&gt; [&i](bool isNull, const std::string &name, int64_t id) 
                            {
                            if (!isNull)
                                std::cout &lt;&lt; i++ &lt;&lt; ": user name is " &lt;&lt; name &lt;&lt; ", user id is " &lt;&lt; id &lt;&lt; std::endl;
                            else
                                std::cout &lt;&lt; i &lt;&lt; " rows selected!" &lt;&lt; std::endl;
                            } 
                    &gt;&gt; [](const DrogonDbException &e) 
                        {
                            std::cerr &lt;&lt; "error:" &lt;&lt; e.base().what() &lt;&lt; std::endl;
                        };
              </pre></div>
              </div>
      <p>It can be seen that the values ​​of the user_name and user_id fields in the select statement are respectively assigned to the name and id variables in the callback function, and the user does not need to handle these conversions by themselves, which obviously provides a certain convenience, and the user can use it flexibly.</p>
      <p><b>Note: It is important to emphasize that in asynchronous programming the user must pay attention to the variable i in the above example. The user must ensure that the variable i is valid when the callback occurs because it is caught by the reference. The callback will be called in another thread, and the current context may have failed when the callback occurred. Programmers typically use smart pointers to hold temporarily created variables and then capture them through callbacks to ensure the validity of the variables.</b></p>
      <h3><a href="#id67" id="Summary" title="Summary">Summary</a></h3>
      <p>Each DbClient object has one or multiple its own EventLoop threads controlling the database connection IO, accepting the request via an asynchronous or synchronous interface, and returning the result via a callback function.</p>
      <p>Blocking interfaces of DbClient only block the caller thread, as long as the caller thread is not the EventLoop thread, it will not affect the normal operation of the EventLoop thread. When the callback function is called, the program inside the callback is run on the EventLoop thread. Therefore, do not perform any blocking operations within the callback, otherwise it will affect the concurrency performance of database read and write. Anyone familiar with non-blocking I/O programming should understand this constraint.</p>
    </div>
    <div class="section" id="DataBase_Transaction">
      <h2><a class="toc-backref" href="#id68">DataBase Transaction</a><a class="headerlink" href="#id68" >¶</a></h2>
      <p><b>Transactions</b> are an important feature of relational databases, and Drogon provides transaction support with the <b>Transaction</b> class.</p>
      <p>Objects of the <b>Transaction</b> class are created by <b>DbClient</b>, and many transaction-related operations are performed automatically:</p>
      <ul>        
        <li>At the beginning of the <b>Transaction</b> object creation, the begin statement is automatically executed to <b>start</b> the transaction;</li>
        <li>When the <b>Transaction</b> object is destructed, the <b>commit</b> statement is automatically executed to end the transaction;</li>
        <li>If there is an exception that causes the transaction to fail, the <b>rollback</b> statement is automatically executed to `roll back the transaction;</li>
        <li>If the transaction has been rolled back, then the sql statement will return an exception (throw an exception or perform an exception callback);</li>
      </ul>
      <h3><a href="#id69" id="Transaction_Creation" title="Transaction_Creation">Transaction Creation</a></h3>
      <p>The method of transaction creation is provided by <b>DbClient</b> as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        std::shared_ptr&lt;Transaction&gt; newTransaction(const std::function&lt;void(bool)&gt; &commitCallback = std::function&lt;void(bool)&gt;())
        </pre></div>
        </div>
        <p>This interface is very simple, it returns a smart pointer to a <b>Transaction</b> object. Obviously, when the smart pointer loses all the holders and destructs the transaction object, the transaction ends. The parameter <b>commitCallback</b> is used to return whether the transaction commit is successful. It should be noted that this callback is only used to indicate whether the <b>commit</b> command is successful. If the transaction is automatically or manually rolled back during execution, the <b>callback</b> will not be executed. Generally, the <b>commit</b> command will succeed，the bool type parameter of this callback is true. Only some special cases, such as the connection disconnection during the commit process, will cause the <b>commitCallback</b> to notify the user that the commit fails, at this time, the state of the transaction on the server is not certain, the user needs to deal with this situation specially. Of course, considering that this situation rarely occurs, with non-critical services the user can choose to ignore this event by ignoring the <b>commitCallback</b> parameter when creating the transaction (The default empty callback will be passed to the newTransaction method).</p>
        <p>The transaction must monopolize the database connection. Therefore, during transaction creation, <b>DbClient</b> needs to select an idle connection from its own connection pool and hand it over to transaction object management. This has a problem. If all connections in the <b>DbClient</b> are executing sql or other transactions, the interface will block until there is an idle connection.</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void newTransactionAsync(const std::function<void(const std::shared_ptr<Transaction> &)> &callback);
      </pre></div>
      </div>
      <p>This interface returns the transaction object through the callback function, does not block the current thread, and ensures high concurrency of the application. Users can use it or the synchronous version according to the actual situation.</p>
      <h3><a href="#id70" id="Transaction_Interface" title="Transaction_Interface">Transaction Interface</a></h3>
        <p>The <b>Transaction</b> interface is almost identical to <b>DbClient</b>, except for the following two differences:</p>
        <ul>
          <li><b>Transaction</b> provides a <b>rollback()</b> interface that allows the user to roll back the transaction under any circumstances. Sometimes, the transaction has been automatically rolled back, and then calling the <b>rollback()</b> interface has no negative impact, so explicitly using the rollback() interface is a good strategy to at least ensure that it is not committed incorrectly.
          </li><li>The user cannot call the transaction's <b>newTransaction()</b> interface, which is easy to understand. Although the database has the concept of a sub-transaction, the framework does not currently support it.
        </li>
        </ul>
        <p>In fact, <b>Transaction</b> is designed as a subclass of <b>DbClient</b>, in order to maintain the consistency of these interfaces, and at the same time, it also creates convenient conditions for the use of <a href="#">ORM</a>.</p>
        <p>The framework currently does not provide an interface to control transaction isolation levels, that is, the isolation level is the default level of the current database service.</p>
      <h3><a href="#id71" id="Transaction_Life_Cycle" title="Transaction_Life_Cycle">Transaction Life Cycle</a></h3>
        <p>The smart pointer of the transaction object is held by the user. When it has unexecuted sql, the framework will hold it, so don't worry about the transaction object being destructed when there is still unexecuted sql. In addition, the transaction object smart pointer is often caught and used in the result callback of one of its interfaces. This is the normal way to use, don't worry that the circular reference will cause the transaction object to never be destroyed, because the framework will help the user break the circular reference automatically.</p>
      <h3><a href="#id72" id="One_Example" title="Transaction One_Example">One Example</a></h3>
        <p>For the simplest example, suppose there is a task table from which the user selects an unprocessed task and changes it to the state being processed. To prevent concurrent race conditions, we use the <b>Transaction</b> class, the program is as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          {
            auto transPtr = clientPtr->newTransaction();
            transPtr->execSqlAsync( "select * from tasks where status=$1 for update order by time",
                                    "none",
                                    [=](const Result &r) {
                                        if (r.size() > 0)
                                        {
                                            std::cout &lt;&lt; "Got a task!" &lt;&lt; std::endl;
                                            *transPtr &lt;&lt; "update tasks set status=$1 where task_id=$2"
                                                      &lt;&lt; "handling"
                                                      &lt;&lt; r[0]["task_id"].as<int64_t>() 
                                                      &gt;&gt; [](const Result &r) 
                                                         {
                                                            std::cout &lt;&lt; "Updated!";
                                                            ... do something about the task;
                                                         } 
                                                      &gt;&gt; [](const DrogonDbException &e) 
                                                         {
                                                            std::cerr &lt;&lt; "err:" &lt;&lt; e.base().what() &lt;&lt; std::end;
                                                         };
                                        }
                                        else
                                        {
                                            std::cout &lt;&lt; "No new tasks found!" &lt;&lt; std::endl;
                                        }
                                    },
                                    [](const DrogonDbException &e) {
                                        std::cerr &lt;&lt; "err:" &lt;&lt; e.base().what() &lt;&lt; std::end;
                                    });
        }
      </pre></div></div>
      <p>In this case, select for update is used to avoid concurrent modifications. The update statement is completed in the result callback of the select statement. The outermost braces are used to limit the scope of the transPtr so that it can be destroyed in time after the execution of sql to end the transaction.</p>

    </div>
    <div class="section" id="DataBase_ORM">
      <h2><a class="toc-backref" href="#id73">DataBase ORM</a><a class="headerlink" href="#id73" >¶</a></h2>
      <h3><a href="#id74" id="ORM_Model" title="Model">Model</a></h3>
      <p>Using Drogon's ORM, you first need to create model classes. Drogon's command-line program drogon_ctl provides the ability to generate model classes. The program reads tables information from a user-specified database and automatically generates multiple source files for the model classes based on this information. When the user uses the model, please include the corresponding header file.</p>
      <p>Obviously, each Model class corresponds to a specific database table, and an instance of a model class, corresponds a row of records in the table.</p>
      <p>The command to create model classes is as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        drogon_ctl create model &lt;model_path&gt;
        </pre></div>
        </div>
       <p>The last parameter is the path to store model classes. There must be a configuration file model.json in the path to configure the connection parameters of drogon_ctl to the database. It is a file in JSON format and supports comments. The examples are as follows:</p>
       <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
      {
        "rdbms":"postgresql",
        "host":"127.0.0.1",
        "port":5432,
        "dbname":"test",
        "user":"test",
        "passwd":"",
        "tables":[]
      }
        </pre></div>
        </div>
        <p>The configured parameters are the same as the application's configuration file. Please refer to <a href="#">Configuration File</a>.</p>
        <p>The <b>tables</b> configuration option is unique to the model configuration. It is an array of strings. Each string represents the name of the table to be converted into a model class. If this option is empty, all tables will be used to generate model classes.</p>
        <p>The models directory and the corresponding model.json file have been created in advance in the project directory created with the <b>drogon_ctl create project</b> command. The user can edit the configuration file and create model classes with the drogon_ctl command.</p>

      <h3><a href="#id75" id="ORM_Model_Class_Interface" title="ORM_Model_Class_Interface">Model Class Interface</a></h3>
        <p>There are mainly two types of interfaces that the user directly uses, getter interfaces and setter interfaces.</p>
        <p>There are two types of getter interfaces:</p>
        <ul>
          <li>An interface of the form like <b>getColumnName</b> gets the smart pointer of the field. The return value is a pointer instead of a value is primarily used for the NULL field. The user can determine whether the field is a NULL field by determining whether the pointer is empty.
          </li><li>An interface of the form like <b>getValueOfColumnName</b>, hence the name, is the value obtained. For efficiency reasons, the interface returns a constant reference. If the corresponding field is NULL, the interface returns the default value given by the function parameter.
        </li>
        </ul>
        <p>In addition, the binary block type (blob, bytea) has a special interface, in the form of <b>getValueOfColumnNameAsString</b>, which loads the binary data into the std::string object and returns it to the user.</p>
        <p>The setter interface is used to set the value of the corresponding field, in the form of <b>setColumnName</b>, and the parameter type and field type correspond. Automatically generated fields (such as self-incrementing primary keys) do not have a setter interface.</p>
        <p>The toJson() interface is used to convert the model object into a JSON object. The binary block type is base64 encoded. Please experiment with it yourself.</p>
        <p>The static members of the Model class represent the information of the table. For example, the name of each field can be obtained through the <b>Cols</b> static member, which is convenient to use in an editor that supports automatic prompting.</p>
      <h3><a href="#id76" id="ORM_Mapper_Class_Template" title="Mapper_Class_Template">Mapper_Class_Template</a></h3>
        <p>The mapping between the model object and the database table is performed by the Mapper class template. The Mapper class template encapsulates common operations such as adding, deleting, and changing, so that the user can perform the above operations without writing a SQL statement.</p>
        <p>The construction of the Mapper object is very simple. The template parameter is the type of the model you want to access. The constructor has only one parameter, which is the DbClient smart pointer mentioned earlier. As mentioned earlier, the Transaction class is a subclass of DbClient, so you can also construct a Mapper object with a smart pointer to a transaction, which means that the Mapper mapping also supports transactions.</p>
        <p>Like DbClient, Mapper also provides asynchronous and synchronous interfaces. The synchronous interface is blocked and may throw an exception. The returned future object is blocked in get() and may throw an exception. The normal asynchronous interface does not throw an exception, but returns the result through two callbacks (result callback and exception callback). The type of the exception callback is the same as that in the DbClient interface. The result callback is also divided into several categories according to the interface function. The list is as follows (T is the template parameter, which is the type of the model):</p>
        <br>
        <p><b>Note: When using a transaction, the exception does not necessarily cause a rollback. Transactions will not be rolled back in the following cases: When the findByPrimaryKey interface does not find a qualified row, when the findOne interface finds fewer or more than one record, the mapper will throw an exception or enter an exception callback, the exception type is UnexpectedRows. If the business logic needs to be rolled back in this condition, please explicitly call the rollback() interface.</b></p>
                
      <h3><a href="#id77" id="ORM_Criteria" title="Criteria">Criteria</a></h3>
        <p>In the previous section, many interfaces required input criteria object parameters. The criteria object is an instance of the Criteria class, indicating a certain condition, such as a field greater than, equal to, less than a given value, or a condition such as <b>is Null</b>.</p>
        <p>The constructor of a criteria object is very simple. Generally, the first argument is the name of the field, the second argument is the enumeration value representing the comparison type, and the third argument is the value being compared. If the comparison type is IsNull or IsNotNull, the third parameter is not required.</p>
        <p>E.g:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          Criteria("user_id",CompareOperator::EQ,1);
        </pre></div>
        </div>
        <p>The above example shows that the field user_id is equal to 1 as a condition. In practice, we prefer to write the following:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        Criteria(Users::Cols::_user_id,CompareOperator::EQ,1);
        </pre></div>
        </div>
        <p>This is equivalent to the previous one, but this can use the editor's automatic prompts, which is more efficient and less prone to errors;</p>
        <p>Criteria objects support AND and OR operations. The sum of two criteria objects constructs a new criteria object, which makes it easy to construct nested conditions. For example:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          Mapper<Users> mp(dbClientPtr);
            auto users = mp.findBy(
            (Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Smith")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,0))
            ||(Criteria(Users::Cols::_user_name,CompareOperator::LIKE,"%Johnson")&&Criteria(Users::Cols::_gender,CompareOperator::EQ,1))
            ));
          </pre></div>
          </div>
          <p>The above program is to query all the men named Smith or the women named Johnson from the users table.</p>
      <h3><a href="#id78" id="ORM_Mapper_s_Chain_Interface" title="Mapper_s_Chain_Interface">Mapper's Chain Interface</a></h3>
          <p>Some common sql constraints, such as limit, offset, etc., Mapper class templates also provide support, provided in the form of a chained interface, meaning that users can string multiple constraints to write. After executing any of the interfaces in Section 10.5.3, these constraints are cleared, that is, they are valid in one operation:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
                Mapper<Users> mp(dbClientPtr);
                auto users = mp.orderBy(Users::Cols::_join_time).limit(25).offset(0).findAll();
          </pre></div>
          </div>
          <p>This program is to select the user list from the <b>users</b> table, return the first page of 25 rows per page.</p>
          <p>Basically, the name of the chain interface expresses its function, so I won't go into details here. Please refer to the Mapper.h header file.</p>

      <h3><a href="#id79" id="ORM_Relationships" title="ORM_Relationships">Relationships</a></h3>
          <p>The relationship between the database tables can be configured through the <b>relationships</b> option in the model.json configuration file. We use manual configuration instead of automatically detecting the foreign key of the table because the actual project does not use foreign keys. It is also very common.</p>
          <p>If the <b>enable</b> option is true, the generated model classes will add corresponding interfaces according to the relationships configuration.</p>
          <p>There are three types of relationships,'has one','has many' and 'many to many'.</p>

      <h3><a href="#id80" id="ORM_Relationships_has_one" title="ORM_Relationships_has_one">has one</a></h3>
          <p><b>has one</b> represents a one-to-one relationship. A record in the original table can be associated with a record in the target table, and vice versa. For example, the products table and skus table have a one-to-one relationship, we can define as follows:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            {
              "type": "has one",
              "original_table_name": "products",
              "original_table_alias": "product",
              "original_key": "id",
              "target_table_name": "skus",
              "target_table_alias": "SKU",
              "target_key": "product_id",
              "enable_reverse": true
            }
          </pre></div>
          </div>
          <p>among them:</p>
          <ul>            
            <li>"type": Indicates that this relationship is one-to-one;</li>
            <li>"original_table_name": the name of the original table (the corresponding method will be added to the model corresponding to this table);</li>
            <li>"original_table_alias": alias (the name in the method, because the one-to-one relationship is singular, so set it to product), if this option is empty, the table name is used to generate the method name;</li>
            <li>"original_key": the associated key of the original table;</li>
            <li>"target_table_name": the name of the target table;</li>
            <li>"target_table_alias": the alias of the target table, if this option is empty, the table name is used to generate the method name;</li>
            <li>"target_key": the associated key of the target table;</li>
            <li>"enable_reverse": Indicate whether to automatically generate a reverse relationship, that is, add a method to obtain records of the original table in the model class corresponding to the target table.</li>
          </ul>
          <p>According to this setting, in the model class corresponding to the products table, the following method will be added:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            /// Relationship interfaces
            void getSKU(const DbClientPtr &clientPtr, 
                        const std::function&lt;void(Skus)&gt; &rcb,
                        const ExceptionCallback &ecb) const;
          </pre></div>
          </div>
          <p>This is an asynchronous interface that returns the SKU object associated with the current product in the callback.</p>
          <p>At the same time, since the enable_reverse option is set to true, the following method will be added to the model class corresponding to the skus table:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          /// Relationship interfaces
          void getProduct(const DbClientPtr &clientPtr, 
                          const std::function&lt;void(Products)&gt; &rcb,
                          const ExceptionCallback &ecb) const;
            </pre></div>
            </div>
      <h3><a href="#id81" id="ORM_Relationships_has_many" title="ORM_Relationships_has_many">has many</a></h3>
          <p><b>has many</b> represents a one-to-many relationship. In such a relationship, the table representing many generally has a field associated with the primary key of another table. For example, products and reviews usually have a one-to-many relationship, we can define as follows:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            {
              "type": "has many",
              "original_table_name": "products",
              "original_table_alias": "product",
              "original_key": "id",
              "target_table_name": "reviews",
              "target_table_alias": "",
              "target_key": "product_id",
              "enable_reverse": true
           }
           </pre></div>
           </div>
        <p>The meaning of each configuration above is the same as the previous example, so I won't repeat it here, because there are multiple reviews for a single product, so there is no need to create an alias of reviews. According to this setting, after running <b>drogon_ctl create model</b>, the following interface will be added to the model corresponding to the products table:</p>  
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          void getReviews(const DbClientPtr &clientPtr, 
          const std::function<void(std::vector<Reviews>)> &rcb,
          const ExceptionCallback &ecb) const;
          </pre></div>
          </div>
        <p>In the model corresponding to the reviews table, the following interface will be added:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void getProduct(const DbClientPtr &clientPtr, 
        const std::function<void(Products)> &rcb,
        const ExceptionCallback &ecb) const;
        </pre></div>
        </div>

      <h3><a href="#id82" id="ORM_Relationships_many_to_many" title="ORM Relationships many to many">Many to Many</a></h3>
        <p>As the name implies, <b>many to many</b> represents a many-to-many relationship. Usually, a many-to-many relationship requires a pivot table. Each record in the pivot table corresponds to a record in the original table and another record in the target table. For example, the <b>products</b> table and <b>carts</b> table have a many-to-many relationship, which can be defined as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          {
            "type": "many to many",
            "original_table_name": "products",
            "original_table_alias": "",
            "original_key": "id",
            "pivot_table": {
                "table_name": "carts_products",
                "original_key": "product_id",
                "target_key": "cart_id"
            },
            "target_table_name": "carts",
            "target_table_alias": "",
            "target_key": "id",
            "enable_reverse": true
          }
        </pre></div>
        </div>
        <p>For the pivot table, there is an additional <b>pivot_table</b> configuration. The options inside easy to understand and are omitted here.</p>
        <p>The model of <b>products</b> generated according to this configuration will add the following method:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          void getCarts(const DbClientPtr &clientPtr, 
          const std::function<void(std::vector<std::pair<Carts,CartsProducts>>)> &rcb,
          const ExceptionCallback &ecb) const;
        </pre></div>
        </div>
        <p>The model class of the carts table will add the following method:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          void getProducts(const DbClientPtr &clientPtr, 
          const std::function<void(std::vector<std::pair<Products,CartsProducts>>)> &rcb,
          const ExceptionCallback &ecb) const;
        </pre></div>
        </div>

      <h3><a href="#id83" id="ORM_Relationships_Restful_API_controllers" title="ORM_Relationships_Restful_API_controllers">Restful API controllers</a></h3>      
        <p><b>drogon_ctl</b> can also generate restful-style controllers for each model (or table) while creating models, so that users can generate APIs that can add, delete, modify, and search tables with zero coding. These APIs support many functions such as quering by primary key, quering by conditions, sorting by specific fields, returning specified fields, and assigning alias for each field to hide the table structure. It is controlled by the <b>restful_api_controllers</b> option in model.json. these options have corresponding comments in the json file.</p>
        <p>It should be noted that the controller of each table is designed to be composed of a base class and a subclass. Among them, the base class and the table are closely related, and the subclass is used to implement special business logic or modify the interface format. The advantage of this design is that when the table structure changes, users can update only the base class without overwriting the subclass(by setting the <b>generate_base_only</b> option to <b>true</b>).</p>
    </div>
    <div class="section" id="DataBase_FastDbClient">
      <h2><a class="toc-backref" href="#id84">DataBase FastDbClient</a><a class="headerlink" href="#id84" >¶</a></h2>
      <p>As the name implies, FastDbClient will provide higher performance than the normal DbClient. Unlike DbClient has own event loop, it shares the event loop with network IO threads and the main thread of the web application, which makes the internal implementation of FastDbClient available in a lock-free mode and more efficient.</p>
      <p>Tests show that FastDbClient has a 10% to 20% performance improvement over DbClient under extremely high load conditions.</p>
      <h3><a href="#id85" id="FasstDbClient_Create_and_Get" title="Model">Create and Get</a></h3>
      <p>FastDbClient must be created automatically by the framework with the configuration file, or by calling the app.createDbClient() interface:</p>
      <p>The sub-option <b>is_fast</b> of the db_client option in the configuration file indicates if the client is a FastDbClient.Or user can create a FastDbClient by calling the app.createDbClient() method with the last parameter set to true.</p>
      <p>The framework creates a separate FastDbClient for each IO's event loop and the main event loop, and each FastDbClient manages several database connections internally. The number of event loop of IO is controlled by the framework's "threads_num" option, which is generally set to the number of CPU cores of the host. The number of the DB connections per event loop is the value of the DB client "connection_number" option. Please refer to <a href="#">Configuration File</a>. Therefore, the total number of DB connections held by FastDbClient is <b>(threads_num+1) * connection_number</b>.</p>
      <p>The interface to get a FastDbClient is similar to the normal DbClient, as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        orm::DbClientPtr getFastDbClient(const std::string &name = "default");
        /// Use drogon::app().getFastDbCLient("clientName") to get a FastDbClient object.
      </pre></div>
      </div>
      <p>It should be pointed out that due to the special nature of FastDbClient, the user must call the above interface in the IO event loop thread or the main thread to get the correct smart pointer. In other threads, only the null pointer can be obtained and cannot be used.</p>
      <h3><a href="#id86" id="FasstDbClient_Usage" title="Model">FasstDbClient Usage</a></h3>
      <p>The use of FastDbClient is almost identical to that of the normal DbClient, except for the following limitations:</p>
      <ul>
        <li>
          Both the get and the use of it must be in the framework's IO event loop thread or the main thread. If it is used in other threads, there will be unpredictable errors (because the lock-free condition is destroyed). Fortunately, most of the application programming is in the IO thread, such as within the processing functions of various controllers, within the filter function of filters. It is easy to know that the various callback functions of the FastDbClient interface are also in the current IO thread, and can be safely nestedly used.
        </li><li>Never use the blocking interface of FastDbClient, because this interface will block the current thread, and the current thread is also the thread that handles the database IO of this object, which will cause permanent blocking, and the user has no chance to get the result.
        </li><li>Synchronous transaction creation interfaces are likely to block (when all connections are busy), so FastDbClient's synchronous transaction creation interface returns null pointers directly. If you want to use transactions on FastDbClient, please use the asynchronous transaction creation interface.
        </li><li>After using the FastDbClient to create an Orm Mapper object, you should also use only asynchronous non-blocking interfaces of the mapper object.
      </li>
      </ul>      
    </div>
    <div class="section" id="Plugins">
      <h2><a class="toc-backref" href="#id87">DataBase FastDbClient</a><a class="headerlink" href="#id87" >¶</a></h2>
      <p>Plugins are use to help users build complex applications. In Drogon, all plugins are built and installed into the application based on the configuration file. Plugins in Drogon are single-instance, and users can implement any functionality they want with plugins.</p>
      <p>When Drogon runs the run() interface, it instantiates each plugin one by one according to the configuration file and calls the <b>initAndStart()</b> interface of them.</p>
      <h3><a href="#id88" id="plugins_Configuration" title="plugins_Configuration">Configuration</a></h3>
      <p>Plugin configuration is done through the configuration file, for example:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "plugins": [
        {
        //name: The class name of the plugin
        "name": "DataDictionary",
        //dependencies: Plugins that the plugin depends on. It can be commented out
        "dependencies": [],
        //config: The configuration of the plugin. This json object is the parameter to initialize the plugin.
        //It can be commented out
        "config": {
        }
        }],
      </pre></div>
      </div>
      <p>It can be seen that there are three configurations for each plugin:</p>
      <ul>
        <li>name: is the class name of the plugin (including the namespace). The framework will create a plugin instance based on the class name. If the item is commented out, the plugin becomes disabled.
        </li><li>dependencies: Is a list of names of other plugins that the plugin depends on. The framework creates and initializes all plugins in a specific order. Prioritize the creation and initialization of plugins that are dependent by others. At the end of the program, plugins are closed and destroyed in reverse order. Please note that circular dependencies in plugins are forbidden. Drogon will report an error and exit the program if it detects a circular dependency. If the item is commented out, the list of dependencies is empty.
        </li><li>config: is the json object used to initialize the plugin, the object is passed as an input parameter to the plugin's <b>initAndStart()</b> interface. If the item is commented out, the json object passed to the <b>initAndStart</b> interface is an empty object;
      </li>
      </ul>
      <h3><a href="#id89" id="plugins_Definition" title="plugins_Definition">Definition</a></h3>
        <p>User-defined plugins must inherit from the drogon::Plugin class template, and the template parameter is the plugin type, such as the following definition:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          class DataDictionary : public drogon::Plugin<DataDictionary>
            {
            public:
                virtual void initAndStart(const Json::Value &config) override;
                virtual void shutdown() override;
                ...
            };
          </pre></div></div>
        <p>One can create source files of plugin by drogon_ctl command:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          drogon_ctl create plugin <[namespace::]class_name>
        </pre></div></div>
      <h3><a href="#id90" id="plugins_Getting_Instance" title="plugins_Getting_Instance">Getting Instance</a></h3>
        <p>The plugin instance is created by drogon, and the user can get the plugin instance through the following interface of drogon:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          template <typename T> T *getPlugin();
          </pre></div></div>
          <p>Or</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          PluginBase *getPlugin(const std::string &name);
          </pre></div></div>
          <p>Obviously, the first method is more convenient. For example, the DataDictionary plugin mentioned above can be obtained like this:</p>  
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          auto *pluginPtr=app().getPlugin&lt;DataDictionary&gt;();
          </pre></div></div>
          <p>Note that it is best to get the plugin after calling the framework's run() interface, otherwise one will get an uninitialized plugin instance (this doesn't necessarily lead to an error, it is ok to just make sure to use the plugin after initialization). Of course, since the plugin is initialized in a dependency order, it is no problem to get the instance of another plugin in the <b>initAndStart()</b> interface.</p>
      <h3><a href="#id91" id="plugins_Life_Cycle" title="plugins_Life_Cycle">Life Cycle</a></h3>
          <p>All plugins are initialized in the run() interface of the framework and are destroyed when the application exits. Therefore, the plugin's lifecycle is almost identical to the application, which is why the getPlugin() interface does not need to return a smart pointer.</p>
    </div>
    <div class="section" id="Configuration_File">
      <h2><a class="toc-backref" href="#id92">Configuration</a><a class="headerlink" href="#id92" >¶</a></h2>
      <p>You can control various behaviors of the Http server by configuring various parameters through multiple interfaces of the DrogonAppFramework instance. However, using a configuration file is a better way for the following reasons:</p>
      <ul>
        <li>Using a configuration file instead of source code can determine the behavior of the application at runtime rather than at compile time, which is undoubtedly a more convenient and flexible way;
        </li><li>Using a configuration file can make the main file more concise;
      </li>
      </ul>
      <p>Based on these additional benefits, it is recommended that application developers use configuration files to configure various parameters of the application.</p>
      <p>The configuration file can be loaded very simply by calling the loadConfigFile() interface before calling the run() interface. The parameter of the loadConfigFile() method is the file name of the configuration file, for example:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        int main()
        {
            drogon::app().loadConfigFile("config.json");
            drogon::app().run();
        }
        </pre></div>
        </div>
        <p>The above program loads the configuration file <b>config.json</b> and then runs the application. The specific listening port, log output, database configuration and so on can be configured by the configuration file. In fact, this program can basically be the entire code of the main file of the web application.</p>
      <h3><a href="#id93" id="Configuration_File_Details" title="Configuration_File_Details">Configuration_File_Details</a></h3>
        <p>An example of a configuration file is at the top level of the source directory, config.example.json. If you use the drogon_ctl create project command to create a project, you can also find the file config.json with the same content in the project directory. So, you basically don't need to create a new configuration file but make some changes to this file to complete the configuration of the web application.</p>
        <p>The file is in <b>JSON</b> format and supports comments. You can comment out the unneeded configuration items with the c++ comment symbols /**/ and //.</p>
        <p>After commenting out a configuration option, the framework initializes it with default values. The default value for each option can be found in the comments in the configuration file.</p>
      <h3><a href="#id94" id="Configuration_SSL" title="Configuration_SSL">SSL</a></h3>
        <p>The ssl option is to configure SSL files of the https service as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "ssl": {
            "cert": "../../trantor/trantor/tests/server.pem",
            "key": "../../trantor/trantor/tests/server.pem"
          }
          </pre></div>
          </div>
          <p>Where cert is the path of the certificate file and key is the path of the private key file. If a file contains both a certificate and a private key, the two paths can be made the same.</p>
          <p>The file is in PEM encoding format.</p>
      <h3><a href="#id95" id="listeners" title="listeners">listeners</a></h3>
          <p>As the name implies, the listeners option is to configure listeners for the web application. It is a JSON array type. Each JSON object represents a listener. The specific configuration is as follows:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            "listeners": [
              {
                "address": "0.0.0.0",
                "port": 80,
                "https": false
              },
              {
                "address": "0.0.0.0",
                "port": 443,
                "https": true,
                "cert": "",
                "key": ""
              }
            ]
          </pre></div>
          </div>
          <p>Among them:</p>
          <ul>
            <li><b>address</b>: With the string type indicates the IP address to be listened to. If this option is not available, the default value "0.0.0.0" is used.
            </li><li><b>port</b>: An integer type option indicating the port to be listened to. It must be a valid port number. There is no default value.
            </li><li><b>https</b>: Boolean type, indicating whether to use https, the default value is false, which means using http.
            </li><li><b>cert</b> and <b>key</b>: The string type, is valid when <b>https</b> is true, indicating the certificate and private key of https. The default value is an empty string, indicating the certificate and private key file configured by the global option <b>ssl</b>;
          </li>
          </ul>
      <h3><a href="#id96" id="db_clients" title="db_clients">db_clients</a></h3>
          <p>This option is used to configure the database client. It is a JSON array type. Each JSON object represents a separate database client. The specific configuration is as follows:</p>
          <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
            "db_clients":[
              {
                "name":"",
                "rdbms": "postgresql",
                "host": "127.0.0.1",
                "port": 5432,
                "dbname": "test",
                "user": "",
                "passwd": "",
                "is_fast": false,
                "connection_number": 1,
                "file_name": ""
              }
            ]
            </pre></div>
            </div>
            <p>Among them:</p>
            <ul>
              <li><b>name</b>: string type, client name, the default value is "default", name is the application developer to get the database client's markup from the framework, if there are multiple clients, the name field must be different;
              </li><li><b>rdbms</b>：A string indicating the type of database server. Currently supports "postgresql" and "mysql", which is not case sensitive;
              </li><li><b>host</b>：String, database server address, <b>localhost</b> is the default value;
              </li><li><b>port</b>：An integer representing the port number of the database server;
              </li><li><b>dbname</b>：String, database name;
              </li><li><b>user</b>：String, user name;
              </li><li><b>passwd</b>：String, password;
              </li><li><b>is_fast</b>：bool，false by default, indicate if the client is a FastDbClient
              </li><li><b>connection_number</b>：A integer indicating the number of connections to the database server, at least 1, the default value is also 1, affecting the concurrent performance of data read and write; If the 'is_fast' is true, the number is the number of connections per event loop, otherwise it is the total number of all connections.
              </li><li><b>filename</b>: The filename of sqlite3 database;
            </li>
            </ul>
      <h3><a href="#id97" id="threads_num" title="threads_num">threads_num</a></h3>
      <p>Suboption belonging to the app option, an integer, the default value is 1, indicating the number of IO threads, which has a clear impact on network concurrency. This number is not as big as possible. Users who understand the non-blocking I/O principle should know that this value should be the same as the number of processors that he expects network IO to occupy. If the value is set to 0, the number of IO threads will be the number of all hardware cores.</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "threads_num": 16,
      </pre></div>
      </div>
      <p>The above example shows that network IO uses 16 threads and can run up to 16 CPU cores under high load conditions.</p>
      <h3><a href="#id98" id="Session_configuration_file" title="Session_configuration_file">Session</a></h3>
      <p>Session-related options are also children of the <b>app</b> option, controlling whether session is used and the session timeout. Such as:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "enable_session": true,
          "session_timeout": 1200,
        </pre></div>
        </div>
        <p>Among them:</p>
        <ul><li><b>enable_session</b>：A Boolean value indicating whether to use a session. The default is false. If the client does not support cookies, set it to false because the framework will create a new session for each request without a session cookie, which will result in completely unnecessary resource and performance loss;
        </li><li><b>session_timeout</b>：An integer value indicating the timeout period of the session, in seconds. The default value is 0, indicating permanent validity. Only works if enable_session is true.
        </li></ul>

      <h3><a href="#id99" id="document_root" title="document_root">document_root</a></h3>
      <p>The suboption of the <b>app</b> option, a string, indicates the document path corresponding to the Http root directory, and is the root path of the static file download. The default value is "./", which indicates the current path of the program running. such as:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "document_root": "./",
        </pre></div>
        </div>

      <h3><a href="#id100" id="upload_path" title="upload_path">upload_path</a></h3>
      <p>The child of the app option, a string, represents the default path for uploading files. The default value is "uploads". If the value is not starting with /, ./ or ../, and this value is not .or..`, then this path is the relative path of the previous document_root entry, otherwise it is an absolute path or a relative path to the current directory. Such as:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "upload_path":"uploads",
        </pre></div>
        </div>

      <h3><a href="#id101" id="file_types" title="file_types">file_types</a></h3>
      <p>The suboption of the app option, an array of strings, with default values ​​as follows, indicates the static file download type supported by the framework. If the requested static file extension is outside of these types, the framework will return a 404 error.</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "file_types": [
          "gif",
          "png",
          "jpg",
          "js",
          "css",
          "html",
          "ico",
          "swf",
          "xap",
          "apk",
          "cur",
          "xml"
        ],
        </pre></div>
        </div>
      <h3><a href="#id102" id="Connection_number_control" title="Connection_number_control">Connection_number_control</a></h3>
        <p>The children of the app option have two options, as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "max_connections": 100000,
          "max_connections_per_ip": 0,
        </pre></div>
        </div>
        <p>Among them:</p>
        <ul><li>max_connections：Integer, the default value is 100000, which means the maximum number of simultaneous concurrent connections; when the number of connections maintained by the server reaches this number, the new TCP connection request will be rejected directly.
        </li><li>max_connections_per_ip：Integer, the default value is 0, which means the maximum number of connections for a single client IP, and 0 means no limit.
        </li></ul>
      <h3><a href="#id103" id="Log_option" title="Log_option">Log_option</a></h3>
      <p>The child of the <b>app</b> item, a JSON object, controls the behavior of the log output as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "log": {
          "log_path": "./",
          "logfile_base_name": "",
          "log_size_limit": 100000000,
          "log_level": "TRACE"
        },
        </pre></div>
        </div>
       <p>Among them:</p>
       <ul><li><b>log_path</b>：String, the default value is an empty string, indicating the path where the log file is stored. If it is an empty string, all logs are output to the standard output.
      </li><li><b>logfile_base_name</b>：A string indicating the basename of the log file. The default value is an empty string which means the basename will be drogon.
      </li><li><b>log_size_limit</b>：A integer, in bytes. The default value is 100000000 (100M). When the size of the log file reaches this value, the log file will be switched.
      </li><li><b>log_level</b>：A string, the default value is "DEBUG", which indicates the lowest level of log output. The optional values ​​are from low to high: "TRACE", "DEBUG", "INFO", "WARN", where the TRACE level is only valid when compiling in DEBUG mode.
      </li></ul>
      <p><b>Note: Drogon's file log uses a non-blocking output structure that can achieve a log output of millions of lines per second and can be used with confidence.</b></p>
      <h3><a href="#id104" id="Application_control" title="Application_control">Application_control</a></h3>
      <p>They are also children of the <b>app</b> option and have two options, as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "run_as_daemon": false,
        "relaunch_on_error": false,
        </pre></div>
        </div>
        <p>Among them：</p>
        <ul><li>run_as_daemon：Boolean value, the default value is false. When it is true, the application will be a child process of the No.1 process in the form of a daemon running in the background of the system.
        </li><li>relaunch_on_error：Boolean value, the default value is false. When it is true, the application will relaunches itself on error.</li>
        </ul>
      <h3><a href="#id105" id="use_sendfile" title="use_sendfile">use_sendfile</a></h3>
      <p>The suboption of app option, boolean, indicates whether the linux system call sendfile is used when sending the file. The default value is true. Using sendfile can improve the sending efficiency and reduce the memory usage of large files. as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "use_sendfile": true,
      </pre></div>
      </div>
      <p><b>Note: Even if this option is true, the sendfile system call will not be used, because the use of sendfile for small files is not necessarily cost-effective, and the framework will decide whether to adopt it according to its own optimization strategy.</b></p>
      <h3><a href="#id106" id="use_gzip" title="use_gzip">use_gzip</a></h3>
        <p>The <b>app</b> suboption, boolean, default value is true, indicating whether the body of the Http response uses compressed transmission. When it is true, compression is used in the following cases:</p>
        <ul>
          <li>The client supports gzip compression;
          </li><li>The Http body is the text type;
          </li><li>The length of the body is greater than a certain value;
          </li>
        </ul>
        <p>The configuration example is as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "use_gzip": true,
          </pre></div>
          </div>
      <h3><a href="#id107" id="static_files_cache_time" title="static_files_cache_time">static_files_cache_time</a></h3>
      <p>The <b>app</b> suboption, integer value, in seconds, indicates the cache time of the static file, that is, for the repeated request for the file during this time, the framework will return the response directly from the memory without reading the file system. The default value is 5 seconds, 0 means always cache (only read the file system once, use with caution), negative value means no cache. as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "static_files_cache_time": 5,
        </pre></div>
        </div>

      <h3><a href="#id108" id="simple_controllers_map" title="simple_controllers_map">simple_controllers_map</a></h3>
        <p>The <b>app</b> suboption, an array of JSON objects, each representing a mapping from the Http path to the HttpSimpleController, this configuration is just an alternative, not necessarily configured here, see HttpSimpleController. The specific configuration is as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "simple_controllers_map": [
          {
            "path": "/path/name",
            "controller": "controllerClassName",
            "http_methods": ["get","post"],
            "filters": ["FilterClassName"]
          }
        ],
        </pre></div>
        </div>
        <p>Among them：</p>
        <ul>
        <li><b>path</b>：String, Http path;
        </li><li><b>controller</b>：String, the name of the HttpSimpleController;
        </li><li><b>http_methods</b>：An array of strings representing the supported Http methods. Requests outside this list will be filtered out, returning a 405 error.
        </li><li><b>filters</b>：String array, list of filters on the path, see <a href="#id41" title="Filter">Filter</a>;
        </li>
        </ul>
  
      <h3><a href="#id109" id="Idle_connection_timeout_control" title="Idle_connection_timeout_control">Idle_connection_timeout_control</a></h3>
        <p>The <b>app</b> suboption, integer value, in seconds, the default value is 60. When a connection exceeds this time without any reading and writing, the connection will be forcibly disconnected. as follows:</p>
        <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
          "idle_connection_timeout":60
        </pre></div>
        </div>

      <h3><a href="#id110" id="Dynamic_view_loading" title="Dynamic_view_loading">Dynamic_view_loading</a></h3>
      <p>The sub-options of the app, which control the enabling and the path of the dynamic view, have two options, as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "load_dynamic_views":true,
        "dynamic_views_path":["./views"],
        </pre></div>
        </div>
        <p>Among them</p>：
        <ul><li>dynamic_views_path：Boolean value, the default value is false. When it is true, the framework searches view files in the view path and dynamically compiles them into .so files, then loads them into the application. When any view file changes, it will also cause automatic compilation and re-loading;
        </li><li>dynamic_views_path：An array of strings, each of which represents the search path of the dynamic view. If the path value is not starting with /, ./ or ../, and the value is not . or .., then This path is the relative path of the previous document_root entry, otherwise it is an absolute path or a relative path to the current directory.
        </li></ul>
        <p>See <a href="#id45" title="view">View</a></p>
      <h3><a href="#id111" id="Server_header_field" title="Server_header_field">Server_header_field</a></h3>
      <p>The sub-option of the app configures the server header field of all responses sent by the framework. The default value is an empty string. When this option is empty, the framework automatically generates a header field of the form <b>Server:drogon/version string</b>. It's as follows: </p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "server_header_field": ""
        </pre></div>
        </div>
      <h3><a href="#id112" id="Keepalive_requests" title="Keepalive_requests">Keepalive_requests</a></h3>
      <p>The <b>keepalive_requests</b> option sets the maximum number of requests that can be served through one keep-alive connection. After the maximum number of requests are made, the connection is closed. The default value of 0 means no limit. It's as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "keepalive_requests": 0
        </pre></div>
        </div>
      <h3><a href="#id113" id="Pipelining_requests" title="Pipelining_requests">Pipelining_requests</a></h3>
      <p>The pipelining_requests sets the maximum number of unhandled requests that can be cached in pipelining buffer. After the maximum number of requests are made, the connection is closed. The default value of 0 means no limit. For details about pipelining, please see the rfc2616-8.1.1.2. It's as follows:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        "pipelining_requests": 0
      </pre></div>
      </div>
    </div>
    <div class="section" id="AOP_Aspect_Oriented_Programming">
      <h2><a class="toc-backref" href="#id114">AOP Aspect Oriented Programming</a><a class="headerlink" href="#id114" >¶</a></h2>
      <p>AOP(Aspect Oriented Programming) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns(Quoted from Wikipedia).</p>
      <p>Limited to the features of the C++ language, Drogon does not provide a flexible AOP solution like Spring, but a simple AOP in which all join points are predefined in the framework, and by using the framework's AOP series interfaces, one can register handlers(called 'advices' in Drogon) onto specific join points.</p>
      <h3><a href="#id115" id="Predefined_joinpoints" title="Predefined joinpoints">Predefined joinpoints</a></h3>
      <p>Drogon provides seven joinpoints for users. When the application runs to the joinpoints, the user-registered handlers(Advices) are called one by one. The description of these joinpoints is as follows:</p>      
      <ul>
        <li>Beginning: As the name implies, the joinpoint is at the beginning of the program. Specifically, all handlers registered at this joinpoint are executed immediately after the app().run() method has finished initializaiton. At this joinpoint, all the controllers, filters, plugins, and database clients have been built completely, users can get the desired object reference or perform some other initialization work here. The advice on the joinpoint is only run once, the call signature of the adivice is void(), the registration interface is registerBeginningAdvice;</li>
        <li>NewConnection: Advices registered to this joinpoint are called when each new TCP connection is established. The call signature of the advice is bool(const trantor::InetAddress &, const trantor::InetAddress &), where the first argument is the remote address of the TCP connection and the second one is the local address. Note that the return type is bool, if the user returns false, the corresponding connection will be disconnected. The registration interface is registerNewConnectionAdvice;</li>
        <li>HttpResponseCreation: Advices registered to this joinpoint are called when each HTTP Response object is created. The call signature of the Advice is void(const HttpResponsePtr &), where the parameter is the newly created object, and the user can perform some unified operations on all Responses with this joinpoint, such as adding a special header, etc. This joinpoint affects all Responses, including 404 or any drogon internal error response, and also including all responses generated by user's application. The registration interface is registerHttpResponseCreationAdvice;</li>
        <li>Sync: This joinpoint is located at the front end of Http request processing. Users can intercept this request by returning a non-empty Response object. The call signature of Advices is HttpRequestPtr(const HttpRequestPtr &). The registration interface is `registerSyncAdvice'.</li>
        <li>Pre-Routing: Advices registered to this joinpoint are called immediately after the request is created and before it matches any handler paths. Advices for the joinpoint have two call signatures, void(const HttpRequestPtr &,AdviceCallback &&,AdviceChainCallback &&) and void(const HttpRequestPtr &), the previous one is exactly the same as the call signature of the filter's doFilter method. In fact, they all run in the same way (please refer to [05-Filter]), users can intercept the client request or let it pass through this joinpoint. The advice with second call signature has no interception capability, but the overhead of it is lower, if the user does not intend to intercept requests, please select this kind of advices. The registration interface is registerPreRoutingAdvice;</li>
        <li>Post-Routing: Advices registered to this joinpoint are called immediately after the request matchs a handler path, The call signatures of Advices are the same as the above joinpoint's. The registration interface is registerPostRoutingAdvice;</li>
        <li>Pre-Handling: Advices registered to this joinpoint are called immediately after the request is approved by all filters and before it is handled, The call signatures of Advices are the same as the above joinpoint's. The registration interface is registerPostRoutingAdvice;</li>
        <li>Post-Handling: Advices registered to this joinpoint are called immediately after the request is handled and a response object is created by the handler, The call signature of Advices is void(const HttpRequestPtr &, const HttpResponsePtr &), The registration interface is registerPostHandlingAdvice;</li>
      </ul>
      <h3><a href="#id116" id="AOP_schematic" title="AOP_schematic">AOP schematic</a></h3>
        <p>The following figure shows the location of the above four joinpoints in the HTTP Requests processing flow, where the red dots represent the joinpoints and the green arrows represent the asynchronous calls.</p>

      </div>
    <div class="section" id="Benchmarks">
      <h2><a class="toc-backref" href="#id117">Benchmarks</a><a class="headerlink" href="#id117" >¶</a></h2>
      <p>As a C++ Http application framework, performance should be one of the focus of attention. This section introduces Drogon's simple tests and achievements;</p>
      <h3><a href="#id118" id="Test_environment" title="Test environment">Test environment</a></h3>
      <ul><li>The system is Linux CentOS 7.4;
      </li><li>The device is a Dell server, the CPU is two Intel(R) Xeon(R) CPUs E5-2670 @ 2.60GHz, 16 cores and 32 threads;
      </li><li>Memory 64GB;
      </li><li>gcc version 7.3.0;
      </li></ul>
      <h3><a href="#id119" id="Test_plan_and_results" title="Test plan and results">Test plan and results</a></h3>
      <p>We just want to test the performance of the drogon framework, so we want to simplify the controller's processing as much as possible. We only do an HttpSimpleController and register it on the <b>/benchmark</b> path. The controller returns &lt;p&gt;Hello, world!&lt;/p&gt; for any request. Set the number of drogon threads to 16. The processing function is as follows and you can find the source code at the <b>drogon/examples/benchmark</b> path:</p>
      <div class="highlight-text notranslate"><div class="highlight"><pre><span></span>
        void BenchmarkCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req, std::function<void (const HttpResponsePtr &)> &&callback)
          {
              //write your application logic here
              auto resp = HttpResponse::newHttpResponse();
              resp->setBody("<p>Hello, world!</p>");
              resp->setExpiredTime(0);
              callback(resp);
          }
        </pre></div>
        </div>
       <p>For comparison, I chose nginx for comparison testing, wrote a <b>hello_world_module</b>, and compiled it with the nginx source. The nginx worker_processes parameter is set to 16.</p>    
       <p>The test tool is <b>httpress</b>, a good performance HTTP stress test tool.</p>
       <p>We adjust the parameters of httpress, test each set of parameters five times, and record the maximum and minimum values ​of the number of requests processed per second. The test results are as follows:</p>
       <table border="1" class="docutils">
        <colgroup>
          <col width="25%" />
          <col width="25%" />
          <col width="25%" />
          <col width="25%" />
        </colgroup>
        <thead valign="bottom">
        <tr class="row-odd">
        <th class="head">Command line</th>
        <th class="head">Description</th>
        <th class="head">Drogon(kQPS)</th>
        <th class="head">nginx(kQPS)</th>
        </tr>
        </thead>
        <tbody valign="top">
        <tr class="row-even">
        <td >httpress -c 100 -n 1000000 -t 16 -k -q URL</td>
        <td >100 connections, 1 million requests, 16 threads,Keep-Alive</td>
        <td >561/552</td>
        <td >330/329</td>
        </tr>
        <tr class="row-odd">
        <td >httpress -c 100 -n 1000000 -t 12 -q URL</td>
        <td >100 connections, 1 million requests, 12 threads, no Keep-Alive</td>
        <td >140/135</td>
        <td >31/49</td>
        </tr>
        <tr class="row-even">
        <td >httpress -c 1000 -n 1000000 -t 16 -k -q URL</td>
        <td >1000 connections, 1 million requests, 16 threads,Keep-Alive</td>
        <td >573/565</td>
        <td >333/327</td>
        </tr>
        <tr class="row-odd">
        <td >httpress -c 1000 -n 1000000 -t 16 -q URL</td>
        <td >1000 connections, 1 million requests, 16 threads,no Keep-Alive</td>
        <td >155/143</td>
        <td >52/50</td>
        </tr>
        <tr class="row-even">
        <td >httpress -c 10000 -n 4000000 -t 16 -k -q URL</td>
        <td >10000 connections, 4 million requests, 16 threads,Keep-Alive</td>
        <td >512/508</td>
        <td >316/314</td>
        </tr>
        <tr class="row-odd">
        <td >httpress -c 10000 -n 1000000 -t 16 -q URL</td>
        <td >10000 connections, 1 million requests, 16 threads,no Keep-Alive</td>
        <td >143/141</td>
        <td >43/40</td>
        </tr>
        </tbody>
        </table>
        <p>As you can see, using the Keep-Alive option on the client side, drogon can process more than 500,000 requests per second in the case where a connection can send multiple requests. This score is quite good. In the case that each request initiates a connection, CPU time will be spent on TCP connection establishment and disconnection, and the throughput will drop to 140,000 requests per second, which is reasonable.</p>
        <p>It's easy to see that drogon has a clear advantage over nginx in the above test. If someone does a more accurate test, please correct me.</p>

      </div>
    <div class="section" id="Coz">
      <h2><a class="toc-backref" href="#id120">Coz</a><a class="headerlink" href="#id120" title="Causal_profiling_with_coz">¶</a></h2>
      <h3><a href="#id120" id="Causal_profiling_with_coz" title="Causal profiling with coz">Causal profiling with coz</a></h3>      
      <p>With coz you can profile two things:</p>
      <ul><li>
      throughput</li><li>
      latency</li></ul>
      <p>If you want to profile throughput of your application, you should switch on the COZ_PROFILING cmake option and include debug information in your exectuable with Debug or RelWithDebInfo release modes in cmake. Doing so will include coz progress points when serving a request. Profiling latency is currently not supported in whole application scope, but can still be done in user code.</p>
      <p>When you're done compiling you application with progress points included. You need to run the executable with the coz profiler, for example coz run --- [path to your executable].</p>
      <p>Lastly, the application needs to be stressed, for best results you need to stress all code paths and run the profile for a good amount of time, 15+ min.</p>
      <p>The final profile will be a profile.coz file created in the current working directory. To view results, open the profile in the official viewer, or you could run a local copy from the official <a href="https://github.com/plasma-umass/coz">git repo</a>.</p>
      <p>Coz also supports scoping source files included for the profile with <b>--source-scope &lt;pattern&gt;</b> or <b>-s &lt;pattern&gt;</b> among other things, that should prove useful.</p>
      <p>For more information checkout:</p>
      <ul><li>coz run --help
      </li><li><a href="https://github.com/plasma-umass/coz">Git repo</a>
      </li><li><a href="https://arxiv.org/pdf/1608.03676v1.pdf">Coz whitepaper</a></li>
      </ul>
      <!--
        <a class="reference internal" href="#Coz" id="id120" title="Coz">Coz</a>
        <ul>
          <li><a class="reference internal" href="#Causal_profiling_with_coz">Causal profiling with coz</a> </li>
        </ul>
      </li>
      -->

<div class="bottomnav" role="navigation" aria-label="bottom navigation">
  <p>
  «&#160;&#160;::&#160;&#160;
  <a class="uplink" href="#">Contents</a>
  &#160;&#160;::&#160;&#160;
  <a href="#">Drogon Design &amp; Internals</a>&#160;&#160;»
  </p>
</div>
</div>
<div class="footer" role="contentinfo">
    &#169; Copyright 2007-2020, The Drogon Team.
</div>
  </body>
</html>
